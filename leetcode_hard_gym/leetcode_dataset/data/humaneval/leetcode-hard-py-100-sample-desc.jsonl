{"task_id": "remove-max-number-of-edges-to-keep-graph-fully-traversable", "prompt": "# Alice and Bob have an undirected graph of `n` nodes and 3 types of edges:\n# Type 1: Can be traversed by Alice only.\n# \n# Type 2: Can be traversed by Bob only.\n# \n# Type 3: Can by traversed by both Alice and Bob.\n# \n# Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.\n# \n# Return the maximum number of edges you can remove, or return `-1` if it's impossible for the graph to be fully traversed by Alice and Bob.\n# \n# \n# Example 1:\n# Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n# Output: 2\n# Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n# \n# \n# Example 2:\n# Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n# Output: 0\n# Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.\n# \n# \n# Example 3:\n# Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\n# Output: -1\n# Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.\n# \n# \n# Constraints:\n# `1 <= n <= 10^5`\n# `1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)`\n# `edges[i].length == 3`\n# `1 <= edges[i][0] <= 3`\n# `1 <= edges[i][1] < edges[i][2] <= n`\n# All tuples `(typei, ui, vi)` are distinct.\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -> int:\n", "entry_point": "remove-max-number-of-edges-to-keep-graph-fully-traversable", "cannonical_solution": "", "test": ""}
{"task_id": "smallest-sufficient-team", "prompt": "# In a project, you have a list of required skills `req_skills`, and a list of people. The `ith` person `people[i]` contains a list of skills that the person has.\n# \n# Consider a sufficient team: a set of people such that for every required skill in `req_skills`, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.\n# \n# For example, `team = [0, 1, 3]` represents the people with skills `people[0]`, `people[1]`, and `people[3]`.\n# \n# Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.\n# \n# It is guaranteed an answer exists.\n# \n# \n# Example 1:\n# Input: req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]\n# Output: [0,2]\n# \n# Example 2:\n# Input: req_skills = [\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"], people = [[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]]\n# Output: [1,2]\n# \n# Constraints:\n# `1 <= req_skills.length <= 16`\n# `1 <= req_skills[i].length <= 16`\n# `req_skills[i]` consists of lowercase English letters.\n# \n# All the strings of `req_skills` are unique.\n# \n# `1 <= people.length <= 60`\n# `0 <= people[i].length <= 16`\n# `1 <= people[i][j].length <= 16`\n# `people[i][j]` consists of lowercase English letters.\n# \n# All the strings of `people[i]` are unique.\n# \n# Every skill in `people[i]` is a skill in `req_skills`.\n# \n# It is guaranteed a sufficient team exists.\ndef smallestSufficientTeam(req_skills: List[str], people: List[List[str]]) -> List[int]:\n", "entry_point": "smallest-sufficient-team", "cannonical_solution": "", "test": ""}
{"task_id": "shortest-subarray-with-sum-at-least-k", "prompt": "# Return the length of the shortest, non-empty, contiguous subarray of `A` with sum at least `K`.\n# \n# If there is no non-empty subarray with sum at least `K`, return `-1`.\n# \n# \n# Example 1:\n# Input: A = [1], K = 1\n# Output: 1\n# \n# Example 2:\n# Input: A = [1,2], K = 4\n# Output: -1\n# \n# Example 3:\n# Input: A = [2,-1,2], K = 3\n# Output: 3\n# Note:\n# `1 <= A.length <= 50000`\n# `-10 ^ 5 <= A[i] <= 10 ^ 5`\n# `1 <= K <= 10 ^ 9`\ndef shortestSubarray(nums: List[int], k: int) -> int:\n", "entry_point": "shortest-subarray-with-sum-at-least-k", "cannonical_solution": "", "test": ""}
{"task_id": "sum-of-distances-in-tree", "prompt": "# An undirected, connected tree with `N` nodes labelled `0...N-1` and `N-1` `edges` are given.\n# \n# The `i`th edge connects nodes `edges[i][0] `and` edges[i][1]` together.\n# \n# Return a list `ans`, where `ans[i]` is the sum of the distances between node `i` and all other nodes.\n# \n# \n# Example 1:\n# Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\n# Output: [8,12,6,10,10,10]\n# Explanation: \n# Here is a diagram of the given tree:\n#   0\n#  / \\\n# 1   2\n#    /|\\\n#   3 4 5\n# We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\n# equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.\n# \n# Note: `1 <= N <= 10000`\ndef sumOfDistancesInTree(n: int, edges: List[List[int]]) -> List[int]:\n", "entry_point": "sum-of-distances-in-tree", "cannonical_solution": "", "test": ""}
{"task_id": "tiling-a-rectangle-with-the-fewest-squares", "prompt": "# Given a rectangle of size `n` x `m`, find the minimum number of integer-sided squares that tile the rectangle.\n# \n# \n# Example 1:\n# Input: n = 2, m = 3\n# Output: 3\n# Explanation: `3` squares are necessary to cover the rectangle.\n# \n# `2` (squares of `1x1`)\n# `1` (square of `2x2`)\n# \n# Example 2:\n# Input: n = 5, m = 8\n# Output: 5\n# \n# Example 3:\n# Input: n = 11, m = 13\n# Output: 6\n# \n# Constraints:\n# `1 <= n <= 13`\n# `1 <= m <= 13`\ndef tilingRectangle(n: int, m: int) -> int:\n", "entry_point": "tiling-a-rectangle-with-the-fewest-squares", "cannonical_solution": "", "test": ""}
{"task_id": "ipo", "prompt": "# Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects. \n# You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n# \n# To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.\n# \n# \n# Example 1:\n# Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].\n# Output: 4\n# Explanation: Since your initial capital is 0, you can only start the project indexed 0.\n# \n#              After finishing it you will obtain profit 1 and your capital becomes 1.\n# \n#              With capital 1, you can either start the project indexed 1 or the project indexed 2.\n# \n#              Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\n# \n#              Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n# \n# Note:\n# You may assume all numbers in the input are non-negative integers.\n# \n# The length of Profits array and Capital array will not exceed 50,000.\n# \n# The answer is guaranteed to fit in a 32-bit signed integer.\ndef findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -> int:\n", "entry_point": "ipo", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-number-of-days-to-eat-n-oranges", "prompt": "# There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows:\n# Eat one orange.\n# \n# If the number of remaining oranges (`n`) is divisible by 2 then you can eat  n/2 oranges.\n# \n# If the number of remaining oranges (`n`) is divisible by 3 then you can eat  2*(n/3) oranges.\n# \n# You can only choose one of the actions per day.\n# \n# Return the minimum number of days to eat `n` oranges.\n# \n# \n# Example 1:\n# Input: n = 10\n# Output: 4\n# Explanation: You have 10 oranges.\n# \n# Day 1: Eat 1 orange,  10 - 1 = 9.  \n# Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)\n# Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. \n# Day 4: Eat the last orange  1 - 1  = 0.\n# \n# You need at least 4 days to eat the 10 oranges.\n# \n# \n# Example 2:\n# Input: n = 6\n# Output: 3\n# Explanation: You have 6 oranges.\n# \n# Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).\n# \n# Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)\n# Day 3: Eat the last orange  1 - 1  = 0.\n# \n# You need at least 3 days to eat the 6 oranges.\n# \n# \n# Example 3:\n# Input: n = 1\n# Output: 1\n# \n# Example 4:\n# Input: n = 56\n# Output: 6\n# \n# Constraints:\n# `1 <= n <= 2*10^9`\ndef minDays(n: int) -> int:\n", "entry_point": "minimum-number-of-days-to-eat-n-oranges", "cannonical_solution": "", "test": ""}
{"task_id": "palindrome-pairs", "prompt": "# Given a list of unique words, return all the pairs of the distinct indices `(i, j)` in the given list, so that the concatenation of the two words `words[i] + words[j]` is a palindrome.\n# \n# \n# Example 1:\n# Input: words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n# Output: [[0,1],[1,0],[3,2],[2,4]]\n# Explanation: The palindromes are [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"]\n# \n# Example 2:\n# Input: words = [\"bat\",\"tab\",\"cat\"]\n# Output: [[0,1],[1,0]]\n# Explanation: The palindromes are [\"battab\",\"tabbat\"]\n# \n# Example 3:\n# Input: words = [\"a\",\"\"]\n# Output: [[0,1],[1,0]]\n# \n# Constraints:\n# `1 <= words.length <= 5000`\n# `0 <= words[i].length <= 300`\n# `words[i]` consists of lower-case English letters.\ndef palindromePairs(words: List[str]) -> List[List[int]]:\n", "entry_point": "palindrome-pairs", "cannonical_solution": "", "test": ""}
{"task_id": "strange-printer-ii", "prompt": "# There is a strange printer with the following two special requirements:\n# On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n# \n# Once the printer has used a color for the above operation, the same color cannot be used again.\n# \n# You are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is the color in the position `(row, col)` of the grid.\n# \n# Return `true` if it is possible to print the matrix `targetGrid`, otherwise, return `false`.\n# \n# \n# Example 1:\n# Input: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\n# Output: true\n# \n# Example 2:\n# Input: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\n# Output: true\n# \n# Example 3:\n# Input: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\n# Output: false\n# Explanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n# \n# \n# Example 4:\n# Input: targetGrid = [[1,1,1],[3,1,3]]\n# Output: false\n# \n# Constraints:\n# `m == targetGrid.length`\n# `n == targetGrid[i].length`\n# `1 <= m, n <= 60`\n# `1 <= targetGrid[row][col] <= 60`\ndef isPrintable(targetGrid: List[List[int]]) -> bool:\n", "entry_point": "strange-printer-ii", "cannonical_solution": "", "test": ""}
{"task_id": "transform-to-chessboard", "prompt": "# An N x N `board` contains only `0`s and `1`s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.\n# \n# What is the minimum number of moves to transform the board into a \"chessboard\" - a board where no `0`s and no `1`s are 4-directionally adjacent? If the task is impossible, return -1.\n# \n# \n# Examples:\n# Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\n# Output: 2\n# Explanation:\n# One potential sequence of moves is shown below, from left to right:\n# 0110     1010     1010\n# 0110 --> 1010 --> 0101\n# 1001     0101     1010\n# 1001     0101     0101\n# The first move swaps the first and second column.\n# \n# The second move swaps the second and third row.\n# \n# Input: board = [[0, 1], [1, 0]]\n# Output: 0\n# Explanation:\n# Also note that the board with 0 in the top left corner,\n# 01\n# 10\n# is also a valid chessboard.\n# \n# Input: board = [[1, 0], [1, 0]]\n# Output: -1\n# Explanation:\n# No matter what sequence of moves you make, you cannot end with a valid chessboard.\n# \n# Note:\n# `board` will have the same number of rows and columns, a number in the range `[2, 30]`.\n# \n# `board[i][j]` will be only `0`s or `1`s.\ndef movesToChessboard(board: List[List[int]]) -> int:\n", "entry_point": "transform-to-chessboard", "cannonical_solution": "", "test": ""}
{"task_id": "count-pairs-with-xor-in-a-range", "prompt": "# Given a (0-indexed) integer array `nums` and two integers `low` and `high`, return the number of nice pairs.\n# \n# A nice pair is a pair `(i, j)` where `0 <= i < j < nums.length` and `low <= (nums[i] XOR nums[j]) <= high`.\n# \n# \n# Example 1:\n# Input: nums = [1,4,2,7], low = 2, high = 6\n# Output: 6\n# Explanation: All nice pairs (i, j) are as follows:\n#     - (0, 1): nums[0] XOR nums[1] = 5 \n#     - (0, 2): nums[0] XOR nums[2] = 3\n#     - (0, 3): nums[0] XOR nums[3] = 6\n#     - (1, 2): nums[1] XOR nums[2] = 6\n#     - (1, 3): nums[1] XOR nums[3] = 3\n#     - (2, 3): nums[2] XOR nums[3] = 5\n# \n# Example 2:\n# Input: nums = [9,8,4,2,1], low = 5, high = 14\n# Output: 8\n# Explanation: All nice pairs (i, j) are as follows:\n# \u200b\u200b\u200b\u200b\u200b    - (0, 2): nums[0] XOR nums[2] = 13\n#     - (0, 3): nums[0] XOR nums[3] = 11\n#     - (0, 4): nums[0] XOR nums[4] = 8\n#     - (1, 2): nums[1] XOR nums[2] = 12\n#     - (1, 3): nums[1] XOR nums[3] = 10\n#     - (1, 4): nums[1] XOR nums[4] = 9\n#     - (2, 3): nums[2] XOR nums[3] = 6\n#     - (2, 4): nums[2] XOR nums[4] = 5\n# \n# Constraints:\n# `1 <= nums.length <= 2 * 104`\n# `1 <= nums[i] <= 2 * 104`\n# `1 <= low <= high <= 2 * 104`\ndef countPairs(nums: List[int], low: int, high: int) -> int:\n", "entry_point": "count-pairs-with-xor-in-a-range", "cannonical_solution": "", "test": ""}
{"task_id": "cracking-the-safe", "prompt": "# There is a box protected by a password. The password is a sequence of `n` digits where each digit can be one of the first `k` digits `0, 1, ..., k-1`.\n# \n# While entering a password, the last `n` digits entered will automatically be matched against the correct password.\n# \n# For example, assuming the correct password is `\"345\"`, if you type `\"012345\"`, the box will open because the correct password matches the suffix of the entered password.\n# \n# Return any password of minimum length that is guaranteed to open the box at some point of entering it.\n# \n# \n# Example 1:\n# Input: n = 1, k = 2\n# Output: \"01\"\n# Note: \"10\" will be accepted too.\n# \n# \n# Example 2:\n# Input: n = 2, k = 2\n# Output: \"00110\"\n# Note: \"01100\", \"10011\", \"11001\" will be accepted too.\n# \n# Note:\n# `n` will be in the range `[1, 4]`.\n# \n# `k` will be in the range `[1, 10]`.\n# \n# `k^n` will be at most `4096`.\ndef crackSafe(n: int, k: int) -> str:\n", "entry_point": "cracking-the-safe", "cannonical_solution": "", "test": ""}
{"task_id": "reverse-pairs", "prompt": "# Given an array `nums`, we call `(i, j)` an important reverse pair if `i < j` and `nums[i] > 2*nums[j]`.\n# \n# You need to return the number of important reverse pairs in the given array.\n# \n# \n# Example1:\n# Input: [1,3,2,3,1]\n# Output: 2\n# \n# Example2:\n# Input: [2,4,3,5,1]\n# Output: 3\n# Note:\n# The length of the given array will not exceed `50,000`.\n# \n# All the numbers in the input array are in the range of 32-bit integer.\ndef reversePairs(nums: List[int]) -> int:\n", "entry_point": "reverse-pairs", "cannonical_solution": "", "test": ""}
{"task_id": "parsing-a-boolean-expression", "prompt": "# Return the result of evaluating a given boolean `expression`, represented as a string.\n# \n# An expression can either be:\n# `\"t\"`, evaluating to `True`;\n# `\"f\"`, evaluating to `False`;\n# `\"!(expr)\"`, evaluating to the logical NOT of the inner expression `expr`;\n# `\"&(expr1,expr2,...)\"`, evaluating to the logical AND of 2 or more inner expressions `expr1, expr2, ...`;\n# `\"|(expr1,expr2,...)\"`, evaluating to the logical OR of 2 or more inner expressions `expr1, expr2, ...`\n# \n# Example 1:\n# Input: expression = \"!(f)\"\n# Output: true\n# \n# Example 2:\n# Input: expression = \"|(f,t)\"\n# Output: true\n# \n# Example 3:\n# Input: expression = \"&(t,f)\"\n# Output: false\n# \n# Example 4:\n# Input: expression = \"|(&(t,f,t),!(t))\"\n# Output: false\n# \n# Constraints:\n# `1 <= expression.length <= 20000`\n# `expression[i]` consists of characters in `{'(', ')', '&', '|', '!', 't', 'f', ','}`.\n# \n# `expression` is a valid expression representing a boolean, as given in the description.\ndef parseBoolExpr(expression: str) -> bool:\n", "entry_point": "parsing-a-boolean-expression", "cannonical_solution": "", "test": ""}
{"task_id": "bricks-falling-when-hit", "prompt": "# You are given an `m x n` binary `grid`, where each `1` represents a brick and `0` represents an empty space. A brick is stable if:\n# It is directly connected to the top of the grid, or\n# At least one other brick in its four adjacent cells is stable.\n# \n# You are also given an array `hits`, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location `hits[i] = (rowi, coli)`. The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the `grid` (i.e., it does not land on other stable bricks).\n# \n# Return an array `result`, where each `result[i]` is the number of bricks that will fall after the `ith` erasure is applied.\n# \n# Note that an erasure may refer to a location with no brick, and if it does, no bricks drop.\n# \n# \n# Example 1:\n# Input: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\n# Output: [2]\n# Explanation: Starting with the grid:\n# [[1,0,0,0],\n#  [1,1,1,0]]\n# We erase the underlined brick at (1,0), resulting in the grid:\n# [[1,0,0,0],\n#  [0,1,1,0]]\n# The two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:\n# [[1,0,0,0],\n#  [0,0,0,0]]\n# Hence the result is [2].\n# \n# \n# Example 2:\n# Input: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\n# Output: [0,0]\n# Explanation: Starting with the grid:\n# [[1,0,0,0],\n#  [1,1,0,0]]\n# We erase the underlined brick at (1,1), resulting in the grid:\n# [[1,0,0,0],\n#  [1,0,0,0]]\n# All remaining bricks are still stable, so no bricks fall. The grid remains the same:\n# [[1,0,0,0],\n#  [1,0,0,0]]\n# Next, we erase the underlined brick at (1,0), resulting in the grid:\n# [[1,0,0,0],\n#  [0,0,0,0]]\n# Once again, all remaining bricks are still stable, so no bricks fall.\n# \n# Hence the result is [0,0].\n# \n# \n# Constraints:\n# `m == grid.length`\n# `n == grid[i].length`\n# `1 <= m, n <= 200`\n# `grid[i][j]` is `0` or `1`.\n# \n# `1 <= hits.length <= 4 * 104`\n# `hits[i].length == 2`\n# `0 <= xi <= m - 1`\n# `0 <= yi <= n - 1`\n# All `(xi, yi)` are unique.\ndef hitBricks(grid: List[List[int]], hits: List[List[int]]) -> List[int]:\n", "entry_point": "bricks-falling-when-hit", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-ways-to-reorder-array-to-get-same-bst", "prompt": "# Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`.\n# \n# For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST.\n# \n# Return the number of ways to reorder `nums` such that the BST formed is identical to the original BST formed from `nums`.\n# \n# Since the answer may be very large, return it modulo `10^9 + 7`.\n# \n# \n# Example 1:\n# Input: nums = [2,1,3]\n# Output: 1\n# Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n# \n# \n# Example 2:\n# Input: nums = [3,4,5,1,2]\n# Output: 5\n# Explanation: The following 5 arrays will yield the same BST: \n# [3,1,2,4,5]\n# [3,1,4,2,5]\n# [3,1,4,5,2]\n# [3,4,1,2,5]\n# [3,4,1,5,2]\n# \n# Example 3:\n# Input: nums = [1,2,3]\n# Output: 0\n# Explanation: There are no other orderings of nums that will yield the same BST.\n# \n# \n# Example 4:\n# Input: nums = [3,1,2,5,4,6]\n# Output: 19\n# \n# Example 5:\n# Input: nums = [9,4,2,1,3,6,5,7,8,14,11,10,12,13,16,15,17,18]\n# Output: 216212978\n# Explanation: The number of ways to reorder nums to get the same BST is 3216212999. Taking this number modulo 10^9 + 7 gives 216212978.\n# \n# \n# Constraints:\n# `1 <= nums.length <= 1000`\n# `1 <= nums[i] <= nums.length`\n# All integers in `nums` are distinct.\ndef numOfWays(nums: List[int]) -> int:\n", "entry_point": "number-of-ways-to-reorder-array-to-get-same-bst", "cannonical_solution": "", "test": ""}
{"task_id": "restore-the-array", "prompt": "# A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits and all we know is that all integers in the array were in the range `[1, k]` and there are no leading zeros in the array.\n# \n# Given the string `s` and the integer `k`. There can be multiple ways to restore the array.\n# \n# Return the number of possible array that can be printed as a string `s` using the mentioned program.\n# \n# The number of ways could be very large so return it modulo `10^9 + 7`\n# \n# Example 1:\n# Input: s = \"1000\", k = 10000\n# Output: 1\n# Explanation: The only possible array is [1000]\n# \n# Example 2:\n# Input: s = \"1000\", k = 10\n# Output: 0\n# Explanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.\n# \n# \n# Example 3:\n# Input: s = \"1317\", k = 2000\n# Output: 8\n# Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]\n# \n# Example 4:\n# Input: s = \"2020\", k = 30\n# Output: 1\n# Explanation: The only possible array is [20,20]. [2020] is invalid because 2020 > 30. [2,020] is ivalid because 020 contains leading zeros.\n# \n# \n# Example 5:\n# Input: s = \"1234567890\", k = 90\n# Output: 34\n# \n# Constraints:\n# `1 <= s.length <= 10^5`.\n# \n# `s` consists of only digits and doesn't contain leading zeros.\n# \n# `1 <= k <= 10^9`.\ndef numberOfArrays(s: str, k: int) -> int:\n", "entry_point": "restore-the-array", "cannonical_solution": "", "test": ""}
{"task_id": "word-search-ii", "prompt": "# Given an `m x n` `board` of characters and a list of strings `words`, return all words on the board.\n# \n# Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n# \n# \n# Example 1:\n# Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n# Output: [\"eat\",\"oath\"]\n# \n# Example 2:\n# Input: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n# Output: []\n# \n# Constraints:\n# `m == board.length`\n# `n == board[i].length`\n# `1 <= m, n <= 12`\n# `board[i][j]` is a lowercase English letter.\n# \n# `1 <= words.length <= 3 * 104`\n# `1 <= words[i].length <= 10`\n# `words[i]` consists of lowercase English letters.\n# \n# All the strings of `words` are unique.\ndef findWords(board: List[List[str]], words: List[str]) -> List[str]:\n", "entry_point": "word-search-ii", "cannonical_solution": "", "test": ""}
{"task_id": "check-if-string-is-transformable-with-substring-sort-operations", "prompt": "# Given two strings `s` and `t`, you want to transform string `s` into string `t` using the following operation any number of times:\n# Choose a non-empty substring in `s` and sort it in-place so the characters are in ascending order.\n# \n# For example, applying the operation on the underlined substring in `\"14234\"` results in `\"12344\"`.\n# \n# Return `true` if it is possible to transform string `s` into string `t`. Otherwise, return `false`.\n# \n# A substring is a contiguous sequence of characters within a string.\n# \n# \n# Example 1:\n# Input: s = \"84532\", t = \"34852\"\n# Output: true\n# Explanation: You can transform s into t using the following sort operations:\n# \"84532\" (from index 2 to 3) -> \"84352\"\n# \"84352\" (from index 0 to 2) -> \"34852\"\n# \n# Example 2:\n# Input: s = \"34521\", t = \"23415\"\n# Output: true\n# Explanation: You can transform s into t using the following sort operations:\n# \"34521\" -> \"23451\"\n# \"23451\" -> \"23415\"\n# \n# Example 3:\n# Input: s = \"12345\", t = \"12435\"\n# Output: false\n# \n# Example 4:\n# Input: s = \"1\", t = \"2\"\n# Output: false\n# \n# Constraints:\n# `s.length == t.length`\n# `1 <= s.length <= 105`\n# `s` and `t` only contain digits from `'0'` to `'9'`.\ndef isTransformable(s: str, t: str) -> bool:\n", "entry_point": "check-if-string-is-transformable-with-substring-sort-operations", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "prompt": "# Given a string `num` representing the digits of a very large integer and an integer `k`.\n# \n# You are allowed to swap any two adjacent digits of the integer at most `k` times.\n# \n# Return the minimum integer you can obtain also as a string.\n# \n# \n# Example 1:\n# Input: num = \"4321\", k = 4\n# Output: \"1342\"\n# Explanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.\n# \n# \n# Example 2:\n# Input: num = \"100\", k = 1\n# Output: \"010\"\n# Explanation: It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.\n# \n# \n# Example 3:\n# Input: num = \"36789\", k = 1000\n# Output: \"36789\"\n# Explanation: We can keep the number without any swaps.\n# \n# \n# Example 4:\n# Input: num = \"22\", k = 22\n# Output: \"22\"\n# \n# Example 5:\n# Input: num = \"9438957234785635408\", k = 23\n# Output: \"0345989723478563548\"\n# \n# Constraints:\n# `1 <= num.length <= 30000`\n# `num` contains digits only and doesn't have leading zeros.\n# \n# `1 <= k <= 10^9`\ndef minInteger(num: str, k: int) -> str:\n", "entry_point": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "cannonical_solution": "", "test": ""}
{"task_id": "reaching-points", "prompt": "# A move consists of taking a point `(x, y)` and transforming it to either `(x, x+y)` or `(x+y, y)`.\n# \n# Given a starting point `(sx, sy)` and a target point `(tx, ty)`, return `True` if and only if a sequence of moves exists to transform the point `(sx, sy)` to `(tx, ty)`. Otherwise, return `False`.\n# \n# \n# Examples:\n# Input: sx = 1, sy = 1, tx = 3, ty = 5\n# Output: True\n# Explanation:\n# One series of moves that transforms the starting point to the target is:\n# (1, 1) -> (1, 2)\n# (1, 2) -> (3, 2)\n# (3, 2) -> (3, 5)\n# Input: sx = 1, sy = 1, tx = 2, ty = 2\n# Output: False\n# Input: sx = 1, sy = 1, tx = 1, ty = 1\n# Output: True\n# Note:\n# `sx, sy, tx, ty` will all be integers in the range `[1, 10^9]`.\ndef reachingPoints(sx: int, sy: int, tx: int, ty: int) -> bool:\n", "entry_point": "reaching-points", "cannonical_solution": "", "test": ""}
{"task_id": "sliding-window-maximum", "prompt": "# You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n# \n# Return the max sliding window.\n# \n# \n# Example 1:\n# Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\n# Output: [3,3,5,5,6,7]\n# Explanation: \n# Window position                Max\n# ---------------               -----\n# [1  3  -1] -3  5  3  6  7       3\n#  1 [3  -1  -3] 5  3  6  7       3\n#  1  3 [-1  -3  5] 3  6  7       5\n#  1  3  -1 [-3  5  3] 6  7       5\n#  1  3  -1  -3 [5  3  6] 7       6\n#  1  3  -1  -3  5 [3  6  7]      7\n# \n# Example 2:\n# Input: nums = [1], k = 1\n# Output: [1]\n# \n# Example 3:\n# Input: nums = [1,-1], k = 1\n# Output: [1,-1]\n# \n# Example 4:\n# Input: nums = [9,11], k = 2\n# Output: [11]\n# \n# Example 5:\n# Input: nums = [4,-2], k = 2\n# Output: [4]\n# \n# Constraints:\n# `1 <= nums.length <= 105`\n# `-104 <= nums[i] <= 104`\n# `1 <= k <= nums.length`\ndef maxSlidingWindow(nums: List[int], k: int) -> List[int]:\n", "entry_point": "sliding-window-maximum", "cannonical_solution": "", "test": ""}
{"task_id": "smallest-rotation-with-highest-score", "prompt": "# Given an array `A`, we may rotate it by a non-negative integer `K` so that the array becomes `A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]`.  Afterward, any entries that are less than or equal to their index are worth 1 point. \n# For example, if we have `[2, 4, 1, 3, 0]`, and we rotate by `K = 2`, it becomes `[1, 3, 0, 2, 4]`.  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].\n# \n# Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.\n# \n# \n# Example 1:\n# Input: [2, 3, 1, 4, 0]\n# Output: 3\n# Explanation:  \n# Scores for each K are listed below: \n# K = 0,  A = [2,3,1,4,0],    score 2\n# K = 1,  A = [3,1,4,0,2],    score 3\n# K = 2,  A = [1,4,0,2,3],    score 3\n# K = 3,  A = [4,0,2,3,1],    score 4\n# K = 4,  A = [0,2,3,1,4],    score 3\n# So we should choose K = 3, which has the highest score.\n# \n# \n# Example 2:\n# Input: [1, 3, 0, 2, 4]\n# Output: 0\n# Explanation:  A will always have 3 points no matter how it shifts.\n# \n# So we will choose the smallest K, which is 0.\n# \n# Note:\n# `A` will have length at most `20000`.\n# \n# `A[i]` will be in the range `[0, A.length]`.\ndef bestRotation(nums: List[int]) -> int:\n", "entry_point": "smallest-rotation-with-highest-score", "cannonical_solution": "", "test": ""}
{"task_id": "split-array-with-same-average", "prompt": "# You are given an integer array `nums`.\n# \n# You should move each element of `nums` into one of the two arrays `A` and `B` such that `A` and `B` are non-empty, and `average(A) == average(B)`.\n# \n# Return `true` if it is possible to achieve that and `false` otherwise.\n# \n# Note that for an array `arr`, `average(arr)` is the sum of all the elements of `arr` over the length of `arr`.\n# \n# \n# Example 1:\n# Input: nums = [1,2,3,4,5,6,7,8]\n# Output: true\n# Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have an average of 4.5.\n# \n# \n# Example 2:\n# Input: nums = [3,1]\n# Output: false\n# \n# Constraints:\n# `1 <= nums.length <= 30`\n# `0 <= nums[i] <= 104`\ndef splitArraySameAverage(nums: List[int]) -> bool:\n", "entry_point": "split-array-with-same-average", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-atoms", "prompt": "# Given a chemical `formula` (given as a string), return the count of each atom.\n# \n# The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n# \n# One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.\n# \n# Two formulas concatenated together to produce another formula. For example, H2O2He3Mg4 is also a formula.\n# \n# A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.\n# \n# Given a `formula`, return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\n# \n# \n# Example 1:\n# Input: formula = \"H2O\"\n# Output: \"H2O\"\n# Explanation: The count of elements are {'H': 2, 'O': 1}.\n# \n# \n# Example 2:\n# Input: formula = \"Mg(OH)2\"\n# Output: \"H2MgO2\"\n# Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\n# \n# \n# Example 3:\n# Input: formula = \"K4(ON(SO3)2)2\"\n# Output: \"K4N2O14S4\"\n# Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\n# \n# \n# Example 4:\n# Input: formula = \"Be32\"\n# Output: \"Be32\"\n# \n# Constraints:\n# `1 <= formula.length <= 1000`\n# `formula` consists of English letters, digits, `'('`, and `')'`.\n# \n# `formula` is always valid.\ndef countOfAtoms(formula: str) -> str:\n", "entry_point": "number-of-atoms", "cannonical_solution": "", "test": ""}
{"task_id": "last-substring-in-lexicographical-order", "prompt": "# Given a string `s`, return the last substring of `s` in lexicographical order.\n# \n# \n# Example 1:\n# Input: s = \"abab\"\n# Output: \"bab\"\n# Explanation: The substrings are [\"a\", \"ab\", \"aba\", \"abab\", \"b\", \"ba\", \"bab\"]. The lexicographically maximum substring is \"bab\".\n# \n# \n# Example 2:\n# Input: s = \"leetcode\"\n# Output: \"tcode\"\n# \n# Constraints:\n# `1 <= s.length <= 4 * 105`\n# `s` contains only lowercase English letters.\ndef lastSubstring(s: str) -> str:\n", "entry_point": "last-substring-in-lexicographical-order", "cannonical_solution": "", "test": ""}
{"task_id": "sort-items-by-groups-respecting-dependencies", "prompt": "# There are `n` items each belonging to zero or one of `m` groups where `group[i]` is the group that the `i`-th item belongs to and it's equal to `-1` if the `i`-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n# \n# Return a sorted list of the items such that:\n# The items that belong to the same group are next to each other in the sorted list.\n# \n# There are some relations between these items where `beforeItems[i]` is a list containing all the items that should come before the `i`-th item in the sorted array (to the left of the `i`-th item).\n# \n# Return any solution if there is more than one solution and return an empty list if there is no solution.\n# \n# \n# Example 1:\n# Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n# Output: [6,3,4,1,5,2,0,7]\n# \n# Example 2:\n# Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n# Output: []\n# Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n# \n# \n# Constraints:\n# `1 <= m <= n <= 3 * 104`\n# `group.length == beforeItems.length == n`\n# `-1 <= group[i] <= m - 1`\n# `0 <= beforeItems[i].length <= n - 1`\n# `0 <= beforeItems[i][j] <= n - 1`\n# `i != beforeItems[i][j]`\n# `beforeItems[i] `does not contain duplicates elements.\ndef sortItems(n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n", "entry_point": "sort-items-by-groups-respecting-dependencies", "cannonical_solution": "", "test": ""}
{"task_id": "trapping-rain-water-ii", "prompt": "# Given an `m x n` matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\n# \n# \n# Example:\n# Given the following 3x6 height map:\n# [\n#   [1,4,3,1,3,2],\n#   [3,2,1,3,2,4],\n#   [2,3,3,2,3,1]\n# ]\n# Return 4.\n# \n# The above image represents the elevation map `[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]` before the rain.\n# \n# After the rain, water is trapped between the blocks. The total volume of water trapped is 4.\n# \n# \n# Constraints:\n# `1 <= m, n <= 110`\n# `0 <= heightMap[i][j] <= 20000`\ndef trapRainWater(heightMap: List[List[int]]) -> int:\n", "entry_point": "trapping-rain-water-ii", "cannonical_solution": "", "test": ""}
{"task_id": "parse-lisp-expression", "prompt": "# You are given a string `expression` representing a Lisp-like expression to return the integer value of.\n# \n# The syntax for these expressions is given as follows.\n# \n# An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.\n# \n# (An integer could be positive or negative.)\n# A let-expression takes the form `(let v1 e1 v2 e2 ... vn en expr)`, where `let` is always the string `\"let\"`, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable `v1` is assigned the value of the expression `e1`, the second variable `v2` is assigned the value of the expression `e2`, and so on sequentially; and then the value of this let-expression is the value of the expression `expr`.\n# \n# An add-expression takes the form `(add e1 e2)` where `add` is always the string `\"add\"`, there are always two expressions `e1, e2`, and this expression evaluates to the addition of the evaluation of `e1` and the evaluation of `e2`.\n# \n# A mult-expression takes the form `(mult e1 e2)` where `mult` is always the string `\"mult\"`, there are always two expressions `e1, e2`, and this expression evaluates to the multiplication of the evaluation of `e1` and the evaluation of `e2`.\n# \n# For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names.\n# \n# Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.\n# \n# \n# Evaluation Examples:\n# Input: (add 1 2)\n# Output: 3\n# Input: (mult 3 (add 2 3))\n# Output: 15\n# Input: (let x 2 (mult x 5))\n# Output: 10\n# Input: (let x 2 (mult x (let x 3 y 4 (add x y))))\n# Output: 14\n# Explanation: In the expression (add x y), when checking for the value of the variable x,\n# we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\n# \n# Since x = 3 is found first, the value of x is 3.\n# \n# Input: (let x 3 x 2 x)\n# Output: 2\n# Explanation: Assignment in let statements is processed sequentially.\n# \n# Input: (let x 1 y 2 x (add x y) (add x y))\n# Output: 5\n# Explanation: The first (add x y) evaluates as 3, and is assigned to x.\n# \n# The second (add x y) evaluates as 3+2 = 5.\n# \n# Input: (let x 2 (add (let x 3 (let x 4 x)) x))\n# Output: 6\n# Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context\n# of the final x in the add-expression.  That final x will equal 2.\n# \n# Input: (let a1 3 b2 (add a1 1) b2) \n# Output 4\n# Explanation: Variable names can contain digits after the first character.\n# \n# Note:\n# The given string `expression` is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer.\n# \n# The length of `expression` is at most 2000.  (It is also non-empty, as that would not be a legal expression.)\n# The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.\ndef evaluate(expression: str) -> int:\n", "entry_point": "parse-lisp-expression", "cannonical_solution": "", "test": ""}
{"task_id": "bus-routes", "prompt": "# You are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `ith` bus repeats forever.\n# \n# For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.\n# \n# You will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.\n# \n# Return the least number of buses you must take to travel from `source` to `target`. Return `-1` if it is not possible.\n# \n# \n# Example 1:\n# Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n# Output: 2\n# Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n# \n# \n# Example 2:\n# Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n# Output: -1\n# \n# Constraints:\n# `1 <= routes.length <= 500`.\n# \n# `1 <= routes[i].length <= 105`\n# All the values of `routes[i]` are unique.\n# \n# `sum(routes[i].length) <= 105`\n# `0 <= routes[i][j] < 106`\n# `0 <= source, target < 106`\ndef numBusesToDestination(routes: List[List[int]], source: int, target: int) -> int:\n", "entry_point": "bus-routes", "cannonical_solution": "", "test": ""}
{"task_id": "poor-pigs", "prompt": "# There are `buckets` buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n# \n# You can feed the pigs according to these steps:\n# Choose some live pigs to feed.\n# \n# For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.\n# \n# Wait for `minutesToDie` minutes. You may not feed any other pigs during this time.\n# \n# After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n# \n# Repeat this process until you run out of time.\n# \n# Given `buckets`, `minutesToDie`, and `minutesToTest`, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n# \n# \n# Example 1:\n# Input: buckets = 1000, minutesToDie = 15, minutesToTest = 60\n# Output: 5\n# \n# Example 2:\n# Input: buckets = 4, minutesToDie = 15, minutesToTest = 15\n# Output: 2\n# \n# Example 3:\n# Input: buckets = 4, minutesToDie = 15, minutesToTest = 30\n# Output: 2\n# \n# Constraints:\n# `1 <= buckets <= 1000`\n# `1 <= minutesToDie <= minutesToTest <= 100`\ndef poorPigs(buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n", "entry_point": "poor-pigs", "cannonical_solution": "", "test": ""}
{"task_id": "sliding-puzzle", "prompt": "# On a 2x3 `board`, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.\n# \n# A move consists of choosing `0` and a 4-directionally adjacent number and swapping it.\n# \n# The state of the board is solved if and only if the `board` is `[[1,2,3],[4,5,0]].`\n# Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\n# \n# \n# Examples:\n# Input: board = [[1,2,3],[4,0,5]]\n# Output: 1\n# Explanation: Swap the 0 and the 5 in one move.\n# \n# Input: board = [[1,2,3],[5,4,0]]\n# Output: -1\n# Explanation: No number of moves will make the board solved.\n# \n# Input: board = [[4,1,2],[5,0,3]]\n# Output: 5\n# Explanation: 5 is the smallest number of moves that solves the board.\n# \n# An example path:\n# After move 0: [[4,1,2],[5,0,3]]\n# After move 1: [[4,1,2],[0,5,3]]\n# After move 2: [[0,1,2],[4,5,3]]\n# After move 3: [[1,0,2],[4,5,3]]\n# After move 4: [[1,2,0],[4,5,3]]\n# After move 5: [[1,2,3],[4,5,0]]\n# Input: board = [[3,2,4],[1,5,0]]\n# Output: 14\n# Note:\n# `board` will be a 2 x 3 array as described above.\n# \n# `board[i][j]` will be a permutation of `[0, 1, 2, 3, 4, 5]`.\ndef slidingPuzzle(board: List[List[int]]) -> int:\n", "entry_point": "sliding-puzzle", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-number-of-k-consecutive-bit-flips", "prompt": "# In an array `A` containing only 0s and 1s, a `K`-bit flip consists of choosing a (contiguous) subarray of length `K` and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\n# \n# Return the minimum number of `K`-bit flips required so that there is no 0 in the array.  If it is not possible, return `-1`.\n# \n# \n# Example 1:\n# Input: A = [0,1,0], K = 1\n# Output: 2\n# Explanation: Flip A[0], then flip A[2].\n# \n# \n# Example 2:\n# Input: A = [1,1,0], K = 2\n# Output: -1\n# Explanation: No matter how we flip subarrays of size 2, we can't make the array become [1,1,1].\n# \n# \n# Example 3:\n# Input: A = [0,0,0,1,0,1,1,0], K = 3\n# Output: 3\n# Explanation:\n# Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\n# Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\n# Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\n# Note:\n# `1 <= A.length <= 30000`\n# `1 <= K <= A.length`\ndef minKBitFlips(nums: List[int], k: int) -> int:\n", "entry_point": "minimum-number-of-k-consecutive-bit-flips", "cannonical_solution": "", "test": ""}
{"task_id": "form-largest-integer-with-digits-that-add-up-to-target", "prompt": "# Given an array of integers `cost` and an integer `target`. Return the maximum integer you can paint under the following rules:\n# The cost of painting a digit (i+1) is given by `cost[i]` (0 indexed).\n# \n# The total cost used must be equal to `target`.\n# \n# Integer does not have digits 0.\n# \n# Since the answer may be too large, return it as string.\n# \n# If there is no way to paint any integer given the condition, return \"0\".\n# \n# \n# Example 1:\n# Input: cost = [4,3,2,5,6,7,2,5,5], target = 9\n# Output: \"7772\"\n# Explanation:  The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost(\"7772\") = 2*3+ 3*1 = 9. You could also paint \"977\", but \"7772\" is the largest number.\n# \n# Digit    cost\n#   1  ->   4\n#   2  ->   3\n#   3  ->   2\n#   4  ->   5\n#   5  ->   6\n#   6  ->   7\n#   7  ->   2\n#   8  ->   5\n#   9  ->   5\n# \n# Example 2:\n# Input: cost = [7,6,5,5,5,6,8,7,8], target = 12\n# Output: \"85\"\n# Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost(\"85\") = 7 + 5 = 12.\n# \n# \n# Example 3:\n# Input: cost = [2,4,6,2,4,6,4,4,4], target = 5\n# Output: \"0\"\n# Explanation: It's not possible to paint any integer with total cost equal to target.\n# \n# \n# Example 4:\n# Input: cost = [6,10,15,40,40,40,40,40,40], target = 47\n# Output: \"32211\"\n# \n# Constraints:\n# `cost.length == 9`\n# `1 <= cost[i] <= 5000`\n# `1 <= target <= 5000`\ndef largestNumber(cost: List[int], target: int) -> str:\n", "entry_point": "form-largest-integer-with-digits-that-add-up-to-target", "cannonical_solution": "", "test": ""}
{"task_id": "sum-of-subsequence-widths", "prompt": "# Given an array of integers `A`, consider all non-empty subsequences of `A`.\n# \n# For any sequence S, let the width of S be the difference between the maximum and minimum element of S.\n# \n# Return the sum of the widths of all subsequences of A. \n# As the answer may be very large, return the answer modulo 10^9 + 7.\n# \n# \n# Example 1:\n# Input: [2,1,3]\n# Output: 6\n# Explanation:\n# Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].\n# \n# The corresponding widths are 0, 0, 0, 1, 1, 2, 2.\n# \n# The sum of these widths is 6.\n# \n# Note:\n# `1 <= A.length <= 20000`\n# `1 <= A[i] <= 20000`\ndef sumSubseqWidths(nums: List[int]) -> int:\n", "entry_point": "sum-of-subsequence-widths", "cannonical_solution": "", "test": ""}
{"task_id": "super-egg-drop", "prompt": "# You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n# \n# You know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor higher than `f` will break, and any egg dropped at or below floor `f` will not break.\n# \n# Each move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.\n# \n# Return the minimum number of moves that you need to determine with certainty what the value of `f` is.\n# \n# \n# Example 1:\n# Input: k = 1, n = 2\n# Output: 2\n# Explanation: \n# Drop the egg from floor 1. If it breaks, we know that f = 0.\n# \n# Otherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\n# \n# If it does not break, then we know f = 2.\n# \n# Hence, we need at minimum 2 moves to determine with certainty what the value of f is.\n# \n# \n# Example 2:\n# Input: k = 2, n = 6\n# Output: 3\n# \n# Example 3:\n# Input: k = 3, n = 14\n# Output: 4\n# \n# Constraints:\n# `1 <= k <= 100`\n# `1 <= n <= 104`\ndef superEggDrop(k: int, n: int) -> int:\n", "entry_point": "super-egg-drop", "cannonical_solution": "", "test": ""}
{"task_id": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons", "prompt": "# Given three integers `n`, `m` and `k`. Consider the following algorithm to find the maximum element of an array of positive integers:\n# You should build the array arr which has the following properties:\n# `arr` has exactly `n` integers.\n# \n# `1 <= arr[i] <= m` where `(0 <= i < n)`.\n# \n# After applying the mentioned algorithm to `arr`, the value `search_cost` is equal to `k`.\n# \n# Return the number of ways to build the array `arr` under the mentioned conditions. As the answer may grow large, the answer must be computed modulo `10^9 + 7`.\n# \n# \n# Example 1:\n# Input: n = 2, m = 3, k = 1\n# Output: 6\n# Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n# \n# Example 2:\n# Input: n = 5, m = 2, k = 3\n# Output: 0\n# Explanation: There are no possible arrays that satisify the mentioned conditions.\n# \n# \n# Example 3:\n# Input: n = 9, m = 1, k = 1\n# Output: 1\n# Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]\n# \n# Example 4:\n# Input: n = 50, m = 100, k = 25\n# Output: 34549172\n# Explanation: Don't forget to compute the answer modulo 1000000007\n# \n# Example 5:\n# Input: n = 37, m = 17, k = 7\n# Output: 418930126\n# \n# Constraints:\n# `1 <= n <= 50`\n# `1 <= m <= 100`\n# `0 <= k <= n`\ndef numOfArrays(n: int, m: int, k: int) -> int:\n", "entry_point": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-ways-of-cutting-a-pizza", "prompt": "# Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts. \n# For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n# \n# Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.\n# \n# \n# Example 1:\n# Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\n# Output: 3 \n# Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n# \n# \n# Example 2:\n# Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\n# Output: 1\n# \n# Example 3:\n# Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\n# Output: 1\n# \n# Constraints:\n# `1 <= rows, cols <= 50`\n# `rows == pizza.length`\n# `cols == pizza[i].length`\n# `1 <= k <= 10`\n# `pizza` consists of characters `'A'` and `'.'` only.\ndef ways(pizza: List[str], k: int) -> int:\n", "entry_point": "number-of-ways-of-cutting-a-pizza", "cannonical_solution": "", "test": ""}
{"task_id": "k-th-smallest-in-lexicographical-order", "prompt": "# Given integers `n` and `k`, find the lexicographically k-th smallest integer in the range from `1` to `n`.\n# \n# Note: 1 \u2264 k \u2264 n \u2264 109.\n# \n# \n# Example:\n# Input:\n# n: 13   k: 2\n# Output:\n# 10\n# Explanation:\n# The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\ndef findKthNumber(n: int, k: int) -> int:\n", "entry_point": "k-th-smallest-in-lexicographical-order", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-initial-energy-to-finish-tasks", "prompt": "# You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n# `actuali` is the actual amount of energy you spend to finish the `ith` task.\n# \n# `minimumi` is the minimum amount of energy you require to begin the `ith` task.\n# \n# For example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n# \n# You can finish the tasks in any order you like.\n# \n# Return the minimum initial amount of energy you will need to finish all the tasks.\n# \n# \n# Example 1:\n# Input: tasks = [[1,2],[2,4],[4,8]]\n# Output: 8\n# Explanation:\n# Starting with 8 energy, we finish the tasks in the following order:\n#     - 3rd task. Now energy = 8 - 4 = 4.\n# \n#     - 2nd task. Now energy = 4 - 2 = 2.\n# \n#     - 1st task. Now energy = 2 - 1 = 1.\n# \n# Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n# \n# \n# Example 2:\n# Input: tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]\n# Output: 32\n# Explanation:\n# Starting with 32 energy, we finish the tasks in the following order:\n#     - 1st task. Now energy = 32 - 1 = 31.\n# \n#     - 2nd task. Now energy = 31 - 2 = 29.\n# \n#     - 3rd task. Now energy = 29 - 10 = 19.\n# \n#     - 4th task. Now energy = 19 - 10 = 9.\n# \n#     - 5th task. Now energy = 9 - 8 = 1.\n# \n# \n# Example 3:\n# Input: tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]\n# Output: 27\n# Explanation:\n# Starting with 27 energy, we finish the tasks in the following order:\n#     - 5th task. Now energy = 27 - 5 = 22.\n# \n#     - 2nd task. Now energy = 22 - 2 = 20.\n# \n#     - 3rd task. Now energy = 20 - 3 = 17.\n# \n#     - 1st task. Now energy = 17 - 1 = 16.\n# \n#     - 4th task. Now energy = 16 - 4 = 12.\n# \n#     - 6th task. Now energy = 12 - 6 = 6.\n# \n# \n# Constraints:\n# `1 <= tasks.length <= 105`\n# `1 <= actual\u200bi <= minimumi <= 104`\ndef minimumEffort(tasks: List[List[int]]) -> int:\n", "entry_point": "minimum-initial-energy-to-finish-tasks", "cannonical_solution": "", "test": ""}
{"task_id": "text-justification", "prompt": "# Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n# \n# You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly maxWidth characters.\n# \n# Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n# \n# For the last line of text, it should be left justified and no extra space is inserted between words.\n# \n# Note:\n# A word is defined as a character sequence consisting of non-space characters only.\n# \n# Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n# \n# The input array `words` contains at least one word.\n# \n# \n# Example 1:\n# Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n# Output:\n# [\n#    \"This    is    an\",\n#    \"example  of text\",\n#    \"justification.  \"\n# ]\n# \n# Example 2:\n# Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n# Output:\n# [\n#   \"What   must   be\",\n#   \"acknowledgment  \",\n#   \"shall be        \"\n# ]\n# Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n# \n# Note that the second line is also left-justified becase it contains only one word.\n# \n# \n# Example 3:\n# Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n# Output:\n# [\n#   \"Science  is  what we\",\n#   \"understand      well\",\n#   \"enough to explain to\",\n#   \"a  computer.  Art is\",\n#   \"everything  else  we\",\n#   \"do                  \"\n# ]\n# \n# Constraints:\n# `1 <= words.length <= 300`\n# `1 <= words[i].length <= 20`\n# `words[i]` consists of only English letters and symbols.\n# \n# `1 <= maxWidth <= 100`\n# `words[i].length <= maxWidth`\ndef fullJustify(words: List[str], maxWidth: int) -> List[str]:\n", "entry_point": "text-justification", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-cost-to-hire-k-workers", "prompt": "# There are `N` workers.  The `i`-th worker has a `quality[i]` and a minimum wage expectation `wage[i]`.\n# \n# Now we want to hire exactly `K` workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:\n# Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n# \n# Every worker in the paid group must be paid at least their minimum wage expectation.\n# \n# Return the least amount of money needed to form a paid group satisfying the above conditions.\n# \n# \n# Example 1:\n# Input: quality = [10,20,5], wage = [70,50,30], K = 2\n# Output: 105.00000\n# Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.\n# \n# \n# Example 2:\n# Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3\n# Output: 30.66667\n# Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. \n# Note:\n# `1 <= K <= N <= 10000`, where `N = quality.length = wage.length`\n# `1 <= quality[i] <= 10000`\n# `1 <= wage[i] <= 10000`\n# Answers within `10^-5` of the correct answer will be considered correct.\ndef mincostToHireWorkers(quality: List[int], wage: List[int], k: int) -> float:\n", "entry_point": "minimum-cost-to-hire-k-workers", "cannonical_solution": "", "test": ""}
{"task_id": "decode-ways-ii", "prompt": "# A message containing letters from `A-Z` can be encoded into numbers using the following mapping:\n# 'A' -> \"1\"\n# 'B' -> \"2\"\n# ...\n# \n# 'Z' -> \"26\"\n# To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106\"` can be mapped into:\n# `\"AAJF\"` with the grouping `(1 1 10 6)`\n# `\"KJF\"` with the grouping `(11 10 6)`\n# Note that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n# \n# In addition to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `\"1*\"` may represent any of the encoded messages `\"11\"`, `\"12\"`, `\"13\"`, `\"14\"`, `\"15\"`, `\"16\"`, `\"17\"`, `\"18\"`, or `\"19\"`. Decoding `\"1*\"` is equivalent to decoding any of the encoded messages it can represent.\n# \n# Given a string `s` containing digits and the `'*'` character, return the number of ways to decode it.\n# \n# Since the answer may be very large, return it modulo `109 + 7`.\n# \n# \n# Example 1:\n# Input: s = \"*\"\n# Output: 9\n# Explanation: The encoded message can represent any of the encoded messages \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", or \"9\".\n# \n# Each of these can be decoded to the strings \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", and \"I\" respectively.\n# \n# Hence, there are a total of 9 ways to decode \"*\".\n# \n# \n# Example 2:\n# Input: s = \"1*\"\n# Output: 18\n# Explanation: The encoded message can represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\".\n# \n# Each of these encoded messages have 2 ways to be decoded (e.g. \"11\" can be decoded to \"AA\" or \"K\").\n# \n# Hence, there are a total of 9 * 2 = 18 ways to decode \"1*\".\n# \n# \n# Example 3:\n# Input: s = \"2*\"\n# Output: 15\n# Explanation: The encoded message can represent any of the encoded messages \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", or \"29\".\n# \n# \"21\", \"22\", \"23\", \"24\", \"25\", and \"26\" have 2 ways of being decoded, but \"27\", \"28\", and \"29\" only have 1 way.\n# \n# Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode \"2*\".\n# \n# \n# Constraints:\n# `1 <= s.length <= 105`\n# `s[i]` is a digit or `'*'`.\ndef numDecodings(s: str) -> int:\n", "entry_point": "decode-ways-ii", "cannonical_solution": "", "test": ""}
{"task_id": "create-maximum-number", "prompt": "# You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`.\n# \n# Create the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n# \n# Return an array of the `k` digits representing the answer.\n# \n# \n# Example 1:\n# Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\n# Output: [9,8,6,5,3]\n# \n# Example 2:\n# Input: nums1 = [6,7], nums2 = [6,0,4], k = 5\n# Output: [6,7,6,0,4]\n# \n# Example 3:\n# Input: nums1 = [3,9], nums2 = [8,9], k = 3\n# Output: [9,8,9]\n# \n# Constraints:\n# `m == nums1.length`\n# `n == nums2.length`\n# `1 <= m, n <= 500`\n# `0 <= nums1[i], nums2[i] <= 9`\n# `1 <= k <= m + n`\n# Follow up: Try to optimize your time and space complexity.\ndef maxNumber(nums1: List[int], nums2: List[int], k: int) -> List[int]:\n", "entry_point": "create-maximum-number", "cannonical_solution": "", "test": ""}
{"task_id": "consecutive-numbers-sum", "prompt": "# Given a positive integer `N`, how many ways can we write it as a sum of consecutive positive integers?\n# \n# Example 1:\n# Input: 5\n# Output: 2\n# Explanation: 5 = 5 = 2 + 3\n# \n# Example 2:\n# Input: 9\n# Output: 3\n# Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4\n# \n# Example 3:\n# Input: 15\n# Output: 4\n# Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n# Note: `1 <= N <= 10 ^ 9`.\ndef consecutiveNumbersSum(n: int) -> int:\n", "entry_point": "consecutive-numbers-sum", "cannonical_solution": "", "test": ""}
{"task_id": "count-the-repetitions", "prompt": "# Define `S = [s,n]` as the string S which consists of n connected strings s. For example, `[\"abc\", 3]` =\"abcabcabc\". \n# On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, \u201cabc\u201d  can be obtained from \u201cabdbec\u201d based on our definition, but it can not be obtained from \u201cacbbe\u201d.\n# \n# You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 \u2264 n1 \u2264 106 and 1 \u2264 n2 \u2264 106. Now consider the strings S1 and S2, where `S1=[s1,n1]` and `S2=[s2,n2]`. Find the maximum integer M such that `[S2,M]` can be obtained from `S1`.\n# \n# \n# Example:\n# Input:\n# s1=\"acb\", n1=4\n# s2=\"ab\", n2=2\n# Return:\n# 2\ndef getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n", "entry_point": "count-the-repetitions", "cannonical_solution": "", "test": ""}
{"task_id": "count-all-valid-pickup-and-delivery-options", "prompt": "# Given `n` orders, each order consist in pickup and delivery services. \n# Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i). \n# Since the answer may be too large, return it modulo 10^9 + 7.\n# \n# \n# Example 1:\n# Input: n = 1\n# Output: 1\n# Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.\n# \n# \n# Example 2:\n# Input: n = 2\n# Output: 6\n# Explanation: All possible orders: \n# (P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).\n# \n# This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.\n# \n# \n# Example 3:\n# Input: n = 3\n# Output: 90\n# \n# Constraints:\n# `1 <= n <= 500`\ndef countOrders(n: int) -> int:\n", "entry_point": "count-all-valid-pickup-and-delivery-options", "cannonical_solution": "", "test": ""}
{"task_id": "max-points-on-a-line", "prompt": "# Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n# \n# \n# Example 1:\n# Input: points = [[1,1],[2,2],[3,3]]\n# Output: 3\n# \n# Example 2:\n# Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n# Output: 4\n# \n# Constraints:\n# `1 <= points.length <= 300`\n# `points[i].length == 2`\n# `-104 <= xi, yi <= 104`\n# All the `points` are unique.\ndef maxPoints(points: List[List[int]]) -> int:\n", "entry_point": "max-points-on-a-line", "cannonical_solution": "", "test": ""}
{"task_id": "max-dot-product-of-two-subsequences", "prompt": "# Given two arrays `nums1` and `nums2`.\n# \n# Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.\n# \n# A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not).\n# \n# \n# Example 1:\n# Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\n# Output: 18\n# Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\n# \n# Their dot product is (2*3 + (-2)*(-6)) = 18.\n# \n# \n# Example 2:\n# Input: nums1 = [3,-2], nums2 = [2,-6,7]\n# Output: 21\n# Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\n# \n# Their dot product is (3*7) = 21.\n# \n# \n# Example 3:\n# Input: nums1 = [-1,-1], nums2 = [1,1]\n# Output: -1\n# Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\n# \n# Their dot product is -1.\n# \n# \n# Constraints:\n# `1 <= nums1.length, nums2.length <= 500`\n# `-1000 <= nums1[i], nums2[i] <= 1000`\ndef maxDotProduct(nums1: List[int], nums2: List[int]) -> int:\n", "entry_point": "max-dot-product-of-two-subsequences", "cannonical_solution": "", "test": ""}
{"task_id": "maximize-palindrome-length-from-subsequences", "prompt": "# You are given two strings, `word1` and `word2`. You want to construct a string in the following manner:\n# Choose some non-empty subsequence `subsequence1` from `word1`.\n# \n# Choose some non-empty subsequence `subsequence2` from `word2`.\n# \n# Concatenate the subsequences: `subsequence1 + subsequence2`, to make the string.\n# \n# Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return `0`.\n# \n# A subsequence of a string `s` is a string that can be made by deleting some (possibly none) characters from `s` without changing the order of the remaining characters.\n# \n# A palindrome is a string that reads the same forward as well as backward.\n# \n# \n# Example 1:\n# Input: word1 = \"cacb\", word2 = \"cbba\"\n# Output: 5\n# Explanation: Choose \"ab\" from word1 and \"cba\" from word2 to make \"abcba\", which is a palindrome.\n# \n# \n# Example 2:\n# Input: word1 = \"ab\", word2 = \"ab\"\n# Output: 3\n# Explanation: Choose \"ab\" from word1 and \"a\" from word2 to make \"aba\", which is a palindrome.\n# \n# \n# Example 3:\n# Input: word1 = \"aa\", word2 = \"bb\"\n# Output: 0\n# Explanation: You cannot construct a palindrome from the described method, so return 0.\n# \n# \n# Constraints:\n# `1 <= word1.length, word2.length <= 1000`\n# `word1` and `word2` consist of lowercase English letters.\ndef longestPalindrome(word1: str, word2: str) -> int:\n", "entry_point": "maximize-palindrome-length-from-subsequences", "cannonical_solution": "", "test": ""}
{"task_id": "similar-string-groups", "prompt": "# Two strings `X` and `Y` are similar if we can swap two letters (in different positions) of `X`, so that it equals `Y`. Also two strings `X` and `Y` are similar if they are equal.\n# \n# For example, `\"tars\"` and `\"rats\"` are similar (swapping at positions `0` and `2`), and `\"rats\"` and `\"arts\"` are similar, but `\"star\"` is not similar to `\"tars\"`, `\"rats\"`, or `\"arts\"`.\n# \n# Together, these form two connected groups by similarity: `{\"tars\", \"rats\", \"arts\"}` and `{\"star\"}`.  Notice that `\"tars\"` and `\"arts\"` are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\n# \n# We are given a list `strs` of strings where every string in `strs` is an anagram of every other string in `strs`. How many groups are there?\n# \n# Example 1:\n# Input: strs = [\"tars\",\"rats\",\"arts\",\"star\"]\n# Output: 2\n# \n# Example 2:\n# Input: strs = [\"omv\",\"ovm\"]\n# Output: 1\n# \n# Constraints:\n# `1 <= strs.length <= 300`\n# `1 <= strs[i].length <= 300`\n# `strs[i]` consists of lowercase letters only.\n# \n# All words in `strs` have the same length and are anagrams of each other.\ndef numSimilarGroups(strs: List[str]) -> int:\n", "entry_point": "similar-string-groups", "cannonical_solution": "", "test": ""}
{"task_id": "integer-to-english-words", "prompt": "# Convert a non-negative integer `num` to its English words representation.\n# \n# \n# Example 1:\n# Input: num = 123\n# Output: \"One Hundred Twenty Three\"\n# \n# Example 2:\n# Input: num = 12345\n# Output: \"Twelve Thousand Three Hundred Forty Five\"\n# \n# Example 3:\n# Input: num = 1234567\n# Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n# \n# Example 4:\n# Input: num = 1234567891\n# Output: \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\"\n# \n# Constraints:\n# `0 <= num <= 231 - 1`\ndef numberToWords(num: int) -> str:\n", "entry_point": "integer-to-english-words", "cannonical_solution": "", "test": ""}
{"task_id": "numbers-at-most-n-given-digit-set", "prompt": "# Given an array of `digits` which is sorted in non-decreasing order. You can write numbers using each `digits[i]` as many times as we want. For example, if `digits = ['1','3','5']`, we may write numbers such as `'13'`, `'551'`, and `'1351315'`.\n# \n# Return the number of positive integers that can be generated that are less than or equal to a given integer `n`.\n# \n# \n# Example 1:\n# Input: digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\n# Output: 20\n# Explanation: \n# The 20 numbers that can be written are:\n# 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n# \n# \n# Example 2:\n# Input: digits = [\"1\",\"4\",\"9\"], n = 1000000000\n# Output: 29523\n# Explanation: \n# We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n# 81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n# 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\n# \n# In total, this is 29523 integers that can be written using the digits array.\n# \n# \n# Example 3:\n# Input: digits = [\"7\"], n = 8\n# Output: 1\n# \n# Constraints:\n# `1 <= digits.length <= 9`\n# `digits[i].length == 1`\n# `digits[i]` is a digit from `'1'` to `'9'`.\n# \n# All the values in `digits` are unique.\n# \n# `digits` is sorted in non-decreasing order.\n# \n# `1 <= n <= 109`\ndef atMostNGivenDigitSet(digits: List[str], n: int) -> int:\n", "entry_point": "numbers-at-most-n-given-digit-set", "cannonical_solution": "", "test": ""}
{"task_id": "orderly-queue", "prompt": "# A string `S` of lowercase letters is given.  Then, we may make any number of moves.\n# \n# In each move, we choose one of the first `K` letters (starting from the left), remove it, and place it at the end of the string.\n# \n# Return the lexicographically smallest string we could have after any number of moves.\n# \n# \n# Example 1:\n# Input: S = \"cba\", K = 1\n# Output: \"acb\"\n# Explanation: \n# In the first move, we move the 1st character (\"c\") to the end, obtaining the string \"bac\".\n# \n# In the second move, we move the 1st character (\"b\") to the end, obtaining the final result \"acb\".\n# \n# \n# Example 2:\n# Input: S = \"baaca\", K = 3\n# Output: \"aaabc\"\n# Explanation: \n# In the first move, we move the 1st character (\"b\") to the end, obtaining the string \"aacab\".\n# \n# In the second move, we move the 3rd character (\"c\") to the end, obtaining the final result \"aaabc\".\n# \n# Note:\n# `1 <= K <= S.length <= 1000`\n# `S` consists of lowercase letters only.\ndef orderlyQueue(s: str, k: int) -> str:\n", "entry_point": "orderly-queue", "cannonical_solution": "", "test": ""}
{"task_id": "find-a-value-of-a-mysterious-function-closest-to-target", "prompt": "# Winston was given the above mysterious function `func`. He has an integer array `arr` and an integer `target` and he wants to find the values `l` and `r` that make the value `|func(arr, l, r) - target|` minimum possible.\n# \n# Return the minimum possible value of `|func(arr, l, r) - target|`.\n# \n# Notice that `func` should be called with the values `l` and `r` where `0 <= l, r < arr.length`.\n# \n# \n# Example 1:\n# Input: arr = [9,12,3,7,15], target = 5\n# Output: 2\n# Explanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2.\n# \n# \n# Example 2:\n# Input: arr = [1000000,1000000,1000000], target = 1\n# Output: 999999\n# Explanation: Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999.\n# \n# \n# Example 3:\n# Input: arr = [1,2,4,8,16], target = 0\n# Output: 0\n# \n# Constraints:\n# `1 <= arr.length <= 105`\n# `1 <= arr[i] <= 106`\n# `0 <= target <= 107`\ndef closestToTarget(arr: List[int], target: int) -> int:\n", "entry_point": "find-a-value-of-a-mysterious-function-closest-to-target", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-number-of-darts-inside-of-a-circular-dartboard", "prompt": "# You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of `points` on a 2D plane. \n# Return the maximum number of points that are within or lie on any circular dartboard of radius `r`.\n# \n# \n# Example 1:\n# Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2\n# Output: 4\n# Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.\n# \n# \n# Example 2:\n# Input: points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5\n# Output: 5\n# Explanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).\n# \n# \n# Example 3:\n# Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1\n# Output: 1\n# \n# Example 4:\n# Input: points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2\n# Output: 4\n# \n# Constraints:\n# `1 <= points.length <= 100`\n# `points[i].length == 2`\n# `-10^4 <= points[i][0], points[i][1] <= 10^4`\n# `1 <= r <= 5000`\ndef numPoints(darts: List[List[int]], r: int) -> int:\n", "entry_point": "maximum-number-of-darts-inside-of-a-circular-dartboard", "cannonical_solution": "", "test": ""}
{"task_id": "k-similar-strings", "prompt": "# Strings `s1` and `s2` are `k`-similar (for some non-negative integer `k`) if we can swap the positions of two letters in `s1` exactly `k` times so that the resulting string equals `s2`.\n# \n# Given two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and `s2` are `k`-similar.\n# \n# \n# Example 1:\n# Input: s1 = \"ab\", s2 = \"ba\"\n# Output: 1\n# \n# Example 2:\n# Input: s1 = \"abc\", s2 = \"bca\"\n# Output: 2\n# \n# Example 3:\n# Input: s1 = \"abac\", s2 = \"baca\"\n# Output: 2\n# \n# Example 4:\n# Input: s1 = \"aabc\", s2 = \"abca\"\n# Output: 2\n# \n# Constraints:\n# `1 <= s1.length <= 20`\n# `s2.length == s1.length`\n# `s1` and `s2` contain only lowercase letters from the set `{'a', 'b', 'c', 'd', 'e', 'f'}`.\n# \n# `s2` is an anagram of `s1`.\ndef kSimilarity(s1: str, s2: str) -> int:\n", "entry_point": "k-similar-strings", "cannonical_solution": "", "test": ""}
{"task_id": "max-sum-of-rectangle-no-larger-than-k", "prompt": "# Given an `m x n` matrix `matrix` and an integer `k`, return the max sum of a rectangle in the matrix such that its sum is no larger than `k`.\n# \n# It is guaranteed that there will be a rectangle with a sum no larger than `k`.\n# \n# \n# Example 1:\n# Input: matrix = [[1,0,1],[0,-2,3]], k = 2\n# Output: 2\n# Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n# \n# \n# Example 2:\n# Input: matrix = [[2,2,-1]], k = 3\n# Output: 3\n# \n# Constraints:\n# `m == matrix.length`\n# `n == matrix[i].length`\n# `1 <= m, n <= 100`\n# `-100 <= matrix[i][j] <= 100`\n# `-105 <= k <= 105`\n# Follow up: What if the number of rows is much larger than the number of columns?\ndef maxSumSubmatrix(matrix: List[List[int]], k: int) -> int:\n", "entry_point": "max-sum-of-rectangle-no-larger-than-k", "cannonical_solution": "", "test": ""}
{"task_id": "strong-password-checker", "prompt": "# A password is considered strong if the below conditions are all met:\n# It has at least `6` characters and at most `20` characters.\n# \n# It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\n# \n# It does not contain three repeating characters in a row (i.e., `\"...aaa...\"` is weak, but `\"...aa...a...\"` is strong, assuming other conditions are met).\n# \n# Given a string `password`, return the minimum number of steps required to make `password` strong. if `password` is already strong, return `0`.\n# \n# In one step, you can:\n# Insert one character to `password`,\n# Delete one character from `password`, or\n# Replace one character of `password` with another character.\n# \n# \n# Example 1:\n# Input: password = \"a\"\n# Output: 5\n# \n# Example 2:\n# Input: password = \"aA1\"\n# Output: 3\n# \n# Example 3:\n# Input: password = \"1337C0d3\"\n# Output: 0\n# \n# Constraints:\n# `1 <= password.length <= 50`\n# `password` consists of letters, digits, dot `'.'` or exclamation mark `'!'`.\ndef strongPasswordChecker(password: str) -> int:\n", "entry_point": "strong-password-checker", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-distance-to-type-a-word-using-two-fingers", "prompt": "# You have a keyboard layout as shown above in the XY plane, where each English uppercase letter is located at some coordinate, for example, the letter A is located at coordinate (0,0), the letter B is located at coordinate (0,1), the letter P is located at coordinate (2,3) and the letter Z is located at coordinate (4,1).\n# \n# Given the string `word`, return the minimum total distance to type such string using only two fingers. The distance between coordinates (x1,y1) and (x2,y2) is |x1 - x2| + |y1 - y2|. \n# Note that the initial positions of your two fingers are considered free so don't count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.\n# \n# \n# Example 1:\n# Input: word = \"CAKE\"\n# Output: 3\n# Explanation: \n# Using two fingers, one optimal way to type \"CAKE\" is: \n# Finger 1 on letter 'C' -> cost = 0 \n# Finger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 \n# Finger 2 on letter 'K' -> cost = 0 \n# Finger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 \n# Total distance = 3\n# \n# Example 2:\n# Input: word = \"HAPPY\"\n# Output: 6\n# Explanation: \n# Using two fingers, one optimal way to type \"HAPPY\" is:\n# Finger 1 on letter 'H' -> cost = 0\n# Finger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2\n# Finger 2 on letter 'P' -> cost = 0\n# Finger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0\n# Finger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4\n# Total distance = 6\n# \n# Example 3:\n# Input: word = \"NEW\"\n# Output: 3\n# \n# Example 4:\n# Input: word = \"YEAR\"\n# Output: 7\n# \n# Constraints:\n# `2 <= word.length <= 300`\n# Each word[i]` is an English uppercase letter.\ndef minimumDistance(word: str) -> int:\n", "entry_point": "minimum-distance-to-type-a-word-using-two-fingers", "cannonical_solution": "", "test": ""}
{"task_id": "dungeon-game", "prompt": "# The demons had captured the princess and imprisoned her in the bottom-right corner of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through `dungeon` to rescue the princess.\n# \n# The knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\n# \n# Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n# \n# To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n# \n# Return the knight's minimum initial health so that he can rescue the princess.\n# \n# Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n# \n# \n# Example 1:\n# Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n# Output: 7\n# Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n# \n# \n# Example 2:\n# Input: dungeon = [[0]]\n# Output: 1\n# \n# Constraints:\n# `m == dungeon.length`\n# `n == dungeon[i].length`\n# `1 <= m, n <= 200`\n# `-1000 <= dungeon[i][j] <= 1000`\ndef calculateMinimumHP(dungeon: List[List[int]]) -> int:\n", "entry_point": "dungeon-game", "cannonical_solution": "", "test": ""}
{"task_id": "word-break-ii", "prompt": "# Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.\n# \n# Note that the same word in the dictionary may be reused multiple times in the segmentation.\n# \n# \n# Example 1:\n# Input: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\n# Output: [\"cats and dog\",\"cat sand dog\"]\n# \n# Example 2:\n# Input: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\n# Output: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\n# Explanation: Note that you are allowed to reuse a dictionary word.\n# \n# \n# Example 3:\n# Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n# Output: []\n# \n# Constraints:\n# `1 <= s.length <= 20`\n# `1 <= wordDict.length <= 1000`\n# `1 <= wordDict[i].length <= 10`\n# `s` and `wordDict[i]` consist of only lowercase English letters.\n# \n# All the strings of `wordDict` are unique.\ndef wordBreak(s: str, wordDict: List[str]) -> List[str]:\n", "entry_point": "word-break-ii", "cannonical_solution": "", "test": ""}
{"task_id": "student-attendance-record-ii", "prompt": "# An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n# `'A'`: Absent.\n# \n# `'L'`: Late.\n# \n# `'P'`: Present.\n# \n# Any student is eligible for an attendance award if they meet both of the following criteria:\n# The student was absent (`'A'`) for strictly fewer than 2 days total.\n# \n# The student was never late (`'L'`) for 3 or more consecutive days.\n# \n# Given an integer `n`, return the number of possible attendance records of length `n` that make a student eligible for an attendance award. The answer may be very large, so return it modulo `109 + 7`.\n# \n# \n# Example 1:\n# Input: n = 2\n# Output: 8\n# Explanation: There are 8 records with length 2 that are eligible for an award:\n# \"PP\", \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\n# Only \"AA\" is not eligible because there are 2 absences (there need to be fewer than 2).\n# \n# \n# Example 2:\n# Input: n = 1\n# Output: 3\n# \n# Example 3:\n# Input: n = 10101\n# Output: 183236316\n# \n# Constraints:\n# `1 <= n <= 105`\ndef checkRecord(n: int) -> int:\n", "entry_point": "student-attendance-record-ii", "cannonical_solution": "", "test": ""}
{"task_id": "contain-virus", "prompt": "# A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n# \n# The world is modeled as a 2-D array of cells, where `0` represents uninfected cells, and `1` represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\n# \n# Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.\n# \n# Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.\n# \n# Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.\n# \n# \n# Example 1:\n# Input: grid = \n# [[0,1,0,0,0,0,0,1],\n#  [0,1,0,0,0,0,0,1],\n#  [0,0,0,0,0,0,0,1],\n#  [0,0,0,0,0,0,0,0]]\n# Output: 10\n# Explanation:\n# There are 2 contaminated regions.\n# \n# On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n# [[0,1,0,0,0,0,1,1],\n#  [0,1,0,0,0,0,1,1],\n#  [0,0,0,0,0,0,1,1],\n#  [0,0,0,0,0,0,0,1]]\n# On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n# \n# \n# Example 2:\n# Input: grid = \n# [[1,1,1],\n#  [1,0,1],\n#  [1,1,1]]\n# Output: 4\n# Explanation: Even though there is only one cell saved, there are 4 walls built.\n# \n# Notice that walls are only built on the shared boundary of two different cells.\n# \n# \n# Example 3:\n# Input: grid = \n# [[1,1,1,0,0,0,0,0,0],\n#  [1,0,1,0,1,1,1,1,1],\n#  [1,1,1,0,0,0,0,0,0]]\n# Output: 13\n# Explanation: The region on the left only builds two new walls.\n# \n# Note:\n# The number of rows and columns of `grid` will each be in the range `[1, 50]`.\n# \n# Each `grid[i][j]` will be either `0` or `1`.\n# \n# Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.\ndef containVirus(isInfected: List[List[int]]) -> int:\n", "entry_point": "contain-virus", "cannonical_solution": "", "test": ""}
{"task_id": "preimage-size-of-factorial-zeroes-function", "prompt": "# Let `f(x)` be the number of zeroes at the end of `x!`. (Recall that `x! = 1 * 2 * 3 * ... * x`, and by convention, `0! = 1`.)\n# For example, `f(3) = 0` because 3! = 6 has no zeroes at the end, while `f(11) = 2` because 11! = 39916800 has 2 zeroes at the end. Given `K`, find how many non-negative integers `x` have the property that `f(x) = K`.\n# \n# \n# Example 1:\n# Input: K = 0\n# Output: 5\n# Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.\n# \n# \n# Example 2:\n# Input: K = 5\n# Output: 0\n# Explanation: There is no x such that x! ends in K = 5 zeroes.\n# \n# Note:\n# `K` will be an integer in the range `[0, 10^9]`.\ndef preimageSizeFZF(k: int) -> int:\n", "entry_point": "preimage-size-of-factorial-zeroes-function", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-difficulty-of-a-job-schedule", "prompt": "# You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `i-th` job, you have to finish all the jobs `j` where `0 <= j < i`).\n# \n# You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done in that day.\n# \n# Given an array of integers `jobDifficulty` and an integer `d`. The difficulty of the `i-th` job is `jobDifficulty[i]`.\n# \n# Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.\n# \n# \n# Example 1:\n# Input: jobDifficulty = [6,5,4,3,2,1], d = 2\n# Output: 7\n# Explanation: First day you can finish the first 5 jobs, total difficulty = 6.\n# \n# Second day you can finish the last job, total difficulty = 1.\n# \n# The difficulty of the schedule = 6 + 1 = 7 \n# \n# Example 2:\n# Input: jobDifficulty = [9,9,9], d = 4\n# Output: -1\n# Explanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n# \n# \n# Example 3:\n# Input: jobDifficulty = [1,1,1], d = 3\n# Output: 3\n# Explanation: The schedule is one job per day. total difficulty will be 3.\n# \n# \n# Example 4:\n# Input: jobDifficulty = [7,1,7,1,7,1], d = 3\n# Output: 15\n# \n# Example 5:\n# Input: jobDifficulty = [11,111,22,222,33,333,44,444], d = 6\n# Output: 843\n# \n# Constraints:\n# `1 <= jobDifficulty.length <= 300`\n# `0 <= jobDifficulty[i] <= 1000`\n# `1 <= d <= 10`\ndef minDifficulty(jobDifficulty: List[int], d: int) -> int:\n", "entry_point": "minimum-difficulty-of-a-job-schedule", "cannonical_solution": "", "test": ""}
{"task_id": "sliding-window-median", "prompt": "# Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\n# \n# \n# Examples:\n# `[2,3,4]` , the median is `3`\n# `[2,3]`, the median is `(2 + 3) / 2 = 2.5`\n# Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.\n# \n# For example,\n# Given nums = `[1,3,-1,-3,5,3,6,7]`, and k = 3.\n# \n# Window position                Median\n# ---------------               -----\n# [1  3  -1] -3  5  3  6  7       1\n#  1 [3  -1  -3] 5  3  6  7       -1\n#  1  3 [-1  -3  5] 3  6  7       -1\n#  1  3  -1 [-3  5  3] 6  7       3\n#  1  3  -1  -3 [5  3  6] 7       5\n#  1  3  -1  -3  5 [3  6  7]      6\n# Therefore, return the median sliding window as `[1,-1,-1,3,5,6]`.\n# \n# Note: \n# You may assume `k` is always valid, ie: `k` is always smaller than input array's size for non-empty array.\n# \n# Answers within `10^-5` of the actual value will be accepted as correct.\ndef medianSlidingWindow(nums: List[int], k: int) -> List[float]:\n", "entry_point": "sliding-window-median", "cannonical_solution": "", "test": ""}
{"task_id": "longest-increasing-path-in-a-matrix", "prompt": "# Given an `m x n` integers `matrix`, return the length of the longest increasing path in `matrix`.\n# \n# From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n# \n# \n# Example 1:\n# Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]\n# Output: 4\n# Explanation: The longest increasing path is `[1, 2, 6, 9]`.\n# \n# \n# Example 2:\n# Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]\n# Output: 4\n# Explanation: The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.\n# \n# \n# Example 3:\n# Input: matrix = [[1]]\n# Output: 1\n# \n# Constraints:\n# `m == matrix.length`\n# `n == matrix[i].length`\n# `1 <= m, n <= 200`\n# `0 <= matrix[i][j] <= 231 - 1`\ndef longestIncreasingPath(matrix: List[List[int]]) -> int:\n", "entry_point": "longest-increasing-path-in-a-matrix", "cannonical_solution": "", "test": ""}
{"task_id": "count-of-range-sum", "prompt": "# Given an integer array `nums` and two integers `lower` and `upper`, return the number of range sums that lie in `[lower, upper]` inclusive.\n# \n# Range sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.\n# \n# \n# Example 1:\n# Input: nums = [-2,5,-1], lower = -2, upper = 2\n# Output: 3\n# Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\n# \n# \n# Example 2:\n# Input: nums = [0], lower = 0, upper = 0\n# Output: 1\n# \n# Constraints:\n# `1 <= nums.length <= 104`\n# `-231 <= nums[i] <= 231 - 1`\n# `-3 * 104 <= lower <= upper <= 3 * 104`\n# Follow up: A naive algorithm of `O(n2)` is trivial, Could you do better than that?\ndef countRangeSum(nums: List[int], lower: int, upper: int) -> int:\n", "entry_point": "count-of-range-sum", "cannonical_solution": "", "test": ""}
{"task_id": "maximize-grid-happiness", "prompt": "# You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.\n# \n# You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\n# \n# The happiness of each person is calculated as follows:\n# Introverts start with `120` happiness and lose `30` happiness for each neighbor (introvert or extrovert).\n# \n# Extroverts start with `40` happiness and gain `20` happiness for each neighbor (introvert or extrovert).\n# \n# Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\n# \n# The grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.\n# \n# \n# Example 1:\n# Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n# Output: 240\n# Explanation: Assume the grid is 1-indexed with coordinates (row, column).\n# \n# We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n# \n# - Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n# - Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n# - Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n# The grid happiness is 120 + 60 + 60 = 240.\n# \n# The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.\n# \n# \n# Example 2:\n# Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n# Output: 260\n# Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n# \n# - Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n# - Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n# - Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n# The grid happiness is 90 + 80 + 90 = 260.\n# \n# \n# Example 3:\n# Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n# Output: 240\n# \n# Constraints:\n# `1 <= m, n <= 5`\n# `0 <= introvertsCount, extrovertsCount <= min(m * n, 6)`\ndef getMaxGridHappiness(m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\n", "entry_point": "maximize-grid-happiness", "cannonical_solution": "", "test": ""}
{"task_id": "concatenated-words", "prompt": "# Given an array of strings `words` (without duplicates), return all the concatenated words in the given list of `words`.\n# \n# A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\n# \n# \n# Example 1:\n# Input: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n# Output: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n# Explanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n# \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n# \"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n# \n# \n# Example 2:\n# Input: words = [\"cat\",\"dog\",\"catdog\"]\n# Output: [\"catdog\"]\n# \n# Constraints:\n# `1 <= words.length <= 104`\n# `0 <= words[i].length <= 1000`\n# `words[i]` consists of only lowercase English letters.\n# \n# `0 <= sum(words[i].length) <= 6 * 105`\ndef findAllConcatenatedWordsInADict(words: List[str]) -> List[str]:\n", "entry_point": "concatenated-words", "cannonical_solution": "", "test": ""}
{"task_id": "numbers-with-repeated-digits", "prompt": "# Given a positive integer `N`, return the number of positive integers less than or equal to `N` that have at least 1 repeated digit.\n# \n# \n# Example 1:\n# Input: 20\n# Output: 1\n# Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\n# \n# \n# Example 2:\n# Input: 100\n# Output: 10\n# Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n# \n# \n# Example 3:\n# Input: 1000\n# Output: 262\n# Note:\n# `1 <= N <= 10^9`\ndef numDupDigitsAtMostN(n: int) -> int:\n", "entry_point": "numbers-with-repeated-digits", "cannonical_solution": "", "test": ""}
{"task_id": "valid-permutations-for-di-sequence", "prompt": "# We are given `S`, a length `n` string of characters from the set `{'D', 'I'}`. (These letters stand for \"decreasing\" and \"increasing\".)\n# A valid permutation is a permutation `P[0], P[1], ..., P[n]` of integers `{0, 1, ..., n}`, such that for all `i`:\n# If `S[i] == 'D'`, then `P[i] > P[i+1]`, and;\n# If `S[i] == 'I'`, then `P[i] < P[i+1]`.\n# \n# How many valid permutations are there?  Since the answer may be large, return your answer modulo `10^9 + 7`.\n# \n# \n# Example 1:\n# Input: \"DID\"\n# Output: 5\n# Explanation: \n# The 5 valid permutations of (0, 1, 2, 3) are:\n# (1, 0, 3, 2)\n# (2, 0, 3, 1)\n# (2, 1, 3, 0)\n# (3, 0, 2, 1)\n# (3, 1, 2, 0)\n# Note:\n# `1 <= S.length <= 200`\n# `S` consists only of characters from the set `{'D', 'I'}`.\ndef numPermsDISequence(s: str) -> int:\n", "entry_point": "valid-permutations-for-di-sequence", "cannonical_solution": "", "test": ""}
{"task_id": "smallest-range-covering-elements-from-k-lists", "prompt": "# You have `k` lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the `k` lists.\n# \n# We define the range `[a, b]` is smaller than range `[c, d]` if `b - a < d - c` or `a < c` if `b - a == d - c`.\n# \n# \n# Example 1:\n# Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\n# Output: [20,24]\n# Explanation: \n# List 1: [4, 10, 15, 24,26], 24 is in range [20,24].\n# \n# List 2: [0, 9, 12, 20], 20 is in range [20,24].\n# \n# List 3: [5, 18, 22, 30], 22 is in range [20,24].\n# \n# \n# Example 2:\n# Input: nums = [[1,2,3],[1,2,3],[1,2,3]]\n# Output: [1,1]\n# \n# Example 3:\n# Input: nums = [[10,10],[11,11]]\n# Output: [10,11]\n# \n# Example 4:\n# Input: nums = [[10],[11]]\n# Output: [10,11]\n# \n# Example 5:\n# Input: nums = [[1],[2],[3],[4],[5],[6],[7]]\n# Output: [1,7]\n# \n# Constraints:\n# `nums.length == k`\n# `1 <= k <= 3500`\n# `1 <= nums[i].length <= 50`\n# `-105 <= nums[i][j] <= 105`\n# `nums[i]` is sorted in non-decreasing order.\ndef smallestRange(nums: List[List[int]]) -> List[int]:\n", "entry_point": "smallest-range-covering-elements-from-k-lists", "cannonical_solution": "", "test": ""}
{"task_id": "find-the-closest-palindrome", "prompt": "# Given an integer n, find the closest integer (not including itself), which is a palindrome. \n# The 'closest' is defined as absolute difference minimized between two integers.\n# \n# \n# Example 1:\n# Input: \"123\"\n# Output: \"121\"\n# Note:\n# The input n is a positive integer represented by string, whose length will not exceed 18.\n# \n# If there is a tie, return the smaller one as answer.\ndef nearestPalindromic(n: str) -> str:\n", "entry_point": "find-the-closest-palindrome", "cannonical_solution": "", "test": ""}
{"task_id": "swim-in-rising-water", "prompt": "# On an N x N `grid`, each square `grid[i][j]` represents the elevation at that point `(i,j)`.\n# \n# Now rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n# \n# You start at the top left square `(0, 0)`. What is the least time until you can reach the bottom right square `(N-1, N-1)`?\n# \n# Example 1:\n# Input: [[0,2],[1,3]]\n# Output: 3\n# Explanation:\n# At time `0`, you are in grid location `(0, 0)`.\n# \n# You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\n# \n# You cannot reach point `(1, 1)` until time `3`.\n# \n# When the depth of water is `3`, we can swim anywhere inside the grid.\n# \n# \n# Example 2:\n# Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n# Output: 16\n# Explanation:\n#  0  1  2  3  4\n# 24 23 22 21  5\n# 12 13 14 15 16\n# 11 17 18 19 20\n# 10  9  8  7  6\n# The final route is marked in bold.\n# \n# We need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n# \n# Note:\n# `2 <= N <= 50`.\n# \n# grid[i][j] is a permutation of [0, ..., N*N - 1].\ndef swimInWater(grid: List[List[int]]) -> int:\n", "entry_point": "swim-in-rising-water", "cannonical_solution": "", "test": ""}
{"task_id": "maximal-rectangle", "prompt": "# Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.\n# \n# \n# Example 1:\n# Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n# Output: 6\n# Explanation: The maximal rectangle is shown in the above picture.\n# \n# \n# Example 2:\n# Input: matrix = []\n# Output: 0\n# \n# Example 3:\n# Input: matrix = [[\"0\"]]\n# Output: 0\n# \n# Example 4:\n# Input: matrix = [[\"1\"]]\n# Output: 1\n# \n# Example 5:\n# Input: matrix = [[\"0\",\"0\"]]\n# Output: 0\n# \n# Constraints:\n# `rows == matrix.length`\n# `cols == matrix[i].length`\n# `0 <= row, cols <= 200`\n# `matrix[i][j]` is `'0'` or `'1'`.\ndef maximalRectangle(matrix: List[List[str]]) -> int:\n", "entry_point": "maximal-rectangle", "cannonical_solution": "", "test": ""}
{"task_id": "dice-roll-simulation", "prompt": "# A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (1-indexed) consecutive times. \n# Given an array of integers `rollMax` and an integer `n`, return the number of distinct sequences that can be obtained with exact `n` rolls.\n# \n# Two sequences are considered different if at least one element differs from each other. Since the answer may be too large, return it modulo `10^9 + 7`.\n# \n# \n# Example 1:\n# Input: n = 2, rollMax = [1,1,2,2,2,3]\n# Output: 34\n# Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.\n# \n# \n# Example 2:\n# Input: n = 2, rollMax = [1,1,1,1,1,1]\n# Output: 30\n# \n# Example 3:\n# Input: n = 3, rollMax = [1,1,1,2,2,3]\n# Output: 181\n# \n# Constraints:\n# `1 <= n <= 5000`\n# `rollMax.length == 6`\n# `1 <= rollMax[i] <= 15`\ndef dieSimulator(n: int, rollMax: List[int]) -> int:\n", "entry_point": "dice-roll-simulation", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-number-of-non-overlapping-substrings", "prompt": "# Given a string `s` of lowercase letters, you need to find the maximum number of non-empty substrings of `s` that meet the following conditions:\n# The substrings do not overlap, that is for any two substrings `s[i..j]` and `s[k..l]`, either `j < k` or `i > l` is true.\n# \n# A substring that contains a certain character `c` must also contain all occurrences of `c`.\n# \n# Find the maximum number of substrings that meet the above conditions. If there are multiple solutions with the same number of substrings, return the one with minimum total length. It can be shown that there exists a unique solution of minimum total length.\n# \n# Notice that you can return the substrings in any order.\n# \n# \n# Example 1:\n# Input: s = \"adefaddaccc\"\n# Output: [\"e\",\"f\",\"ccc\"]\n# Explanation: The following are all the possible substrings that meet the conditions:\n# [\n#   \"adefaddaccc\"\n#   \"adefadda\",\n#   \"ef\",\n#   \"e\",\n#   \"f\",\n#   \"ccc\",\n# ]\n# If we choose the first string, we cannot choose anything else and we'd get only 1. If we choose \"adefadda\", we are left with \"ccc\" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose \"ef\" since it can be split into two. Therefore, the optimal way is to choose [\"e\",\"f\",\"ccc\"] which gives us 3 substrings. No other solution of the same number of substrings exist.\n# \n# \n# Example 2:\n# Input: s = \"abbaccd\"\n# Output: [\"d\",\"bb\",\"cc\"]\n# Explanation: Notice that while the set of substrings [\"d\",\"abba\",\"cc\"] also has length 3, it's considered incorrect since it has larger total length.\n# \n# \n# Constraints:\n# `1 <= s.length <= 10^5`\n# `s` contains only lowercase English letters.\ndef maxNumOfSubstrings(s: str) -> List[str]:\n", "entry_point": "maximum-number-of-non-overlapping-substrings", "cannonical_solution": "", "test": ""}
{"task_id": "erect-the-fence", "prompt": "# There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.\n# \n# \n# Example 1:\n# Input: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n# Output: [[1,1],[2,0],[4,2],[3,3],[2,4]]\n# Explanation:\n# \n# Example 2:\n# Input: [[1,2],[2,2],[4,2]]\n# Output: [[1,2],[2,2],[4,2]]\n# Explanation:\n# Even you only have trees in a line, you need to use rope to enclose them. \n# Note:\n# All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group.\n# \n# All input integers will range from 0 to 100.\n# \n# The garden has at least one tree.\n# \n# All coordinates are distinct.\n# \n# Input points have NO order. No order required for output.\n# input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\ndef outerTrees(trees: List[List[int]]) -> List[List[int]]:\n", "entry_point": "erect-the-fence", "cannonical_solution": "", "test": ""}
{"task_id": "best-position-for-a-service-centre", "prompt": "# A delivery company wants to build a new service centre in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new centre in a position such that the sum of the euclidean distances to all customers is minimum.\n# \n# Given an array `positions` where `positions[i] = [xi, yi]` is the position of the `ith` customer on the map, return the minimum sum of the euclidean distances to all customers.\n# \n# In other words, you need to choose the position of the service centre `[xcentre, ycentre]` such that the following formula is minimized:\n# Answers within `10^-5` of the actual value will be accepted.\n# \n# \n# Example 1:\n# Input: positions = [[0,1],[1,0],[1,2],[2,1]]\n# Output: 4.00000\n# Explanation: As shown, you can see that choosing [xcentre, ycentre] = [1, 1] will make the distance to each customer = 1, the sum of all distances is 4 which is the minimum possible we can achieve.\n# \n# \n# Example 2:\n# Input: positions = [[1,1],[3,3]]\n# Output: 2.82843\n# Explanation: The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843\n# \n# Example 3:\n# Input: positions = [[1,1]]\n# Output: 0.00000\n# \n# Example 4:\n# Input: positions = [[1,1],[0,0],[2,0]]\n# Output: 2.73205\n# Explanation: At the first glance, you may think that locating the centre at [1, 0] will achieve the minimum sum, but locating it at [1, 0] will make the sum of distances = 3.\n# \n# Try to locate the centre at [1.0, 0.5773502711] you will see that the sum of distances is 2.73205.\n# \n# Be careful with the precision!\n# \n# Example 5:\n# Input: positions = [[0,1],[3,2],[4,5],[7,6],[8,9],[11,1],[2,12]]\n# Output: 32.94036\n# Explanation: You can use [4.3460852395, 4.9813795505] as the position of the centre.\n# \n# \n# Constraints:\n# `1 <= positions.length <= 50`\n# `positions[i].length == 2`\n# `0 <= positions[i][0], positions[i][1] <= 100`\ndef getMinDistSum(positions: List[List[int]]) -> float:\n", "entry_point": "best-position-for-a-service-centre", "cannonical_solution": "", "test": ""}
{"task_id": "the-skyline-problem", "prompt": "# A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\n# \n# The geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:\n# `lefti` is the x coordinate of the left edge of the `ith` building.\n# \n# `righti` is the x coordinate of the right edge of the `ith` building.\n# \n# `heighti` is the height of the `ith` building.\n# \n# You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.\n# \n# The skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n# \n# Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`\n# \n# Example 1:\n# Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n# Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n# Explanation:\n# Figure A shows the buildings of the input.\n# \n# Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n# \n# \n# Example 2:\n# Input: buildings = [[0,2,3],[2,5,3]]\n# Output: [[0,3],[5,0]]\n# \n# Constraints:\n# `1 <= buildings.length <= 104`\n# `0 <= lefti < righti <= 231 - 1`\n# `1 <= heighti <= 231 - 1`\n# `buildings` is sorted by `lefti` in non-decreasing order.\ndef getSkyline(buildings: List[List[int]]) -> List[List[int]]:\n", "entry_point": "the-skyline-problem", "cannonical_solution": "", "test": ""}
{"task_id": "allocate-mailboxes", "prompt": "# Given the array `houses` and an integer `k`. where `houses[i]` is the location of the ith house along a street, your task is to allocate `k` mailboxes in the street.\n# \n# Return the minimum total distance between each house and its nearest mailbox.\n# \n# The answer is guaranteed to fit in a 32-bit signed integer.\n# \n# \n# Example 1:\n# Input: houses = [1,4,8,10,20], k = 3\n# Output: 5\n# Explanation: Allocate mailboxes in position 3, 9 and 20.\n# \n# Minimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 \n# \n# Example 2:\n# Input: houses = [2,3,5,12,18], k = 2\n# Output: 9\n# Explanation: Allocate mailboxes in position 3 and 14.\n# \n# Minimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.\n# \n# \n# Example 3:\n# Input: houses = [7,4,6,1], k = 1\n# Output: 8\n# \n# Example 4:\n# Input: houses = [3,6,14,10], k = 4\n# Output: 0\n# \n# Constraints:\n# `n == houses.length`\n# `1 <= n <= 100`\n# `1 <= houses[i] <= 10^4`\n# `1 <= k <= n`\n# Array `houses` contain unique integers.\ndef minDistance(houses: List[int], k: int) -> int:\n", "entry_point": "allocate-mailboxes", "cannonical_solution": "", "test": ""}
{"task_id": "count-vowels-permutation", "prompt": "# Given an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:\n# Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)\n# Each vowel `'a'` may only be followed by an `'e'`.\n# \n# Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n# \n# Each vowel `'i'` may not be followed by another `'i'`.\n# \n# Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n# \n# Each vowel `'u'` may only be followed by an `'a'.`\n# Since the answer may be too large, return it modulo `10^9 + 7.`\n# \n# Example 1:\n# Input: n = 1\n# Output: 5\n# Explanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\".\n# \n# \n# Example 2:\n# Input: n = 2\n# Output: 10\n# Explanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\".\n# \n# \n# Example 3: \n# Input: n = 5\n# Output: 68\n# \n# Constraints:\n# `1 <= n <= 2 * 10^4`\ndef countVowelPermutation(n: int) -> int:\n", "entry_point": "count-vowels-permutation", "cannonical_solution": "", "test": ""}
{"task_id": "largest-rectangle-in-histogram", "prompt": "# Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return the area of the largest rectangle in the histogram.\n# \n# \n# Example 1:\n# Input: heights = [2,1,5,6,2,3]\n# Output: 10\n# Explanation: The above is a histogram where width of each bar is 1.\n# \n# The largest rectangle is shown in the red area, which has an area = 10 units.\n# \n# \n# Example 2:\n# Input: heights = [2,4]\n# Output: 4\n# \n# Constraints:\n# `1 <= heights.length <= 105`\n# `0 <= heights[i] <= 104`\ndef largestRectangleArea(heights: List[int]) -> int:\n", "entry_point": "largest-rectangle-in-histogram", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix", "prompt": "# Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and flip it and all the four neighbours of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighboors if they share one edge.\n# \n# Return the minimum number of steps required to convert `mat` to a zero matrix or -1 if you cannot.\n# \n# Binary matrix is a matrix with all cells equal to 0 or 1 only.\n# \n# Zero matrix is a matrix with all cells equal to 0.\n# \n# \n# Example 1:\n# Input: mat = [[0,0],[0,1]]\n# Output: 3\n# Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\n# \n# \n# Example 2:\n# Input: mat = [[0]]\n# Output: 0\n# Explanation: Given matrix is a zero matrix. We don't need to change it.\n# \n# \n# Example 3:\n# Input: mat = [[1,1,1],[1,0,1],[0,0,0]]\n# Output: 6\n# \n# Example 4:\n# Input: mat = [[1,0,0],[1,0,0]]\n# Output: -1\n# Explanation: Given matrix can't be a zero matrix\n# \n# Constraints:\n# `m == mat.length`\n# `n == mat[0].length`\n# `1 <= m <= 3`\n# `1 <= n <= 3`\n# `mat[i][j]` is 0 or 1.\ndef minFlips(mat: List[List[int]]) -> int:\n", "entry_point": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix", "cannonical_solution": "", "test": ""}
{"task_id": "building-boxes", "prompt": "# You have a cubic storeroom where the width, length, and height of the room are all equal to `n` units. You are asked to place `n` boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:\n# You can place the boxes anywhere on the floor.\n# \n# If box `x` is placed on top of the box `y`, then each side of the four vertical sides of the box `y` must either be adjacent to another box or to a wall.\n# \n# Given an integer `n`, return the minimum possible number of boxes touching the floor.\n# \n# \n# Example 1:\n# Input: n = 3\n# Output: 3\n# Explanation: The figure above is for the placement of the three boxes.\n# \n# These boxes are placed in the corner of the room, where the corner is on the left side.\n# \n# \n# Example 2:\n# Input: n = 4\n# Output: 3\n# Explanation: The figure above is for the placement of the four boxes.\n# \n# These boxes are placed in the corner of the room, where the corner is on the left side.\n# \n# \n# Example 3:\n# Input: n = 10\n# Output: 6\n# Explanation: The figure above is for the placement of the ten boxes.\n# \n# These boxes are placed in the corner of the room, where the corner is on the back side.\n# \n# \n# Constraints:\n# `1 <= n <= 109`\ndef minimumBoxes(n: int) -> int:\n", "entry_point": "building-boxes", "cannonical_solution": "", "test": ""}
{"task_id": "split-array-largest-sum", "prompt": "# Given an array `nums` which consists of non-negative integers and an integer `m`, you can split the array into `m` non-empty continuous subarrays.\n# \n# Write an algorithm to minimize the largest sum among these `m` subarrays.\n# \n# \n# Example 1:\n# Input: nums = [7,2,5,10,8], m = 2\n# Output: 18\n# Explanation:\n# There are four ways to split nums into two subarrays.\n# \n# The best way is to split it into [7,2,5] and [10,8],\n# where the largest sum among the two subarrays is only 18.\n# \n# \n# Example 2:\n# Input: nums = [1,2,3,4,5], m = 2\n# Output: 9\n# \n# Example 3:\n# Input: nums = [1,4,4], m = 3\n# Output: 4\n# \n# Constraints:\n# `1 <= nums.length <= 1000`\n# `0 <= nums[i] <= 106`\n# `1 <= m <= min(50, nums.length)`\ndef splitArray(nums: List[int], k: int) -> int:\n", "entry_point": "split-array-largest-sum", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-gap", "prompt": "# Given an integer array `nums`, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return `0`.\n# \n# \n# Example 1:\n# Input: nums = [3,6,9,1]\n# Output: 3\n# Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n# \n# \n# Example 2:\n# Input: nums = [10]\n# Output: 0\n# Explanation: The array contains less than 2 elements, therefore return 0.\n# \n# \n# Constraints:\n# `1 <= nums.length <= 104`\n# `0 <= nums[i] <= 109`\n# Follow up: Could you solve it in linear time/space?\ndef maximumGap(nums: List[int]) -> int:\n", "entry_point": "maximum-gap", "cannonical_solution": "", "test": ""}
{"task_id": "shortest-path-visiting-all-nodes", "prompt": "# An undirected, connected graph of N nodes (labeled `0, 1, 2, ..., N-1`) is given as `graph`.\n# \n# `graph.length = N`, and `j != i` is in the list `graph[i]` exactly once, if and only if nodes `i` and `j` are connected.\n# \n# Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n# \n# \n# Example 1:\n# Input: [[1,2,3],[0],[0],[0]]\n# Output: 4\n# Explanation: One possible path is [1,0,2,0,3]\n# \n# Example 2:\n# Input: [[1],[0,2,4],[1,3,4],[2],[1,2]]\n# Output: 4\n# Explanation: One possible path is [0,1,4,2,3]\n# Note:\n# `1 <= graph.length <= 12`\n# `0 <= graph[i].length < graph.length`\ndef shortestPathLength(graph: List[List[int]]) -> int:\n", "entry_point": "shortest-path-visiting-all-nodes", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-score-words-formed-by-letters", "prompt": "# Given a list of `words`, list of  single `letters` (might be repeating) and `score` of every character.\n# \n# Return the maximum score of any valid set of words formed by using the given letters (`words[i]` cannot be used two or more times).\n# \n# It is not necessary to use all characters in `letters` and each letter can only be used once. Score of letters `'a'`, `'b'`, `'c'`, ... ,`'z'` is given by `score[0]`, `score[1]`, ... , `score[25]` respectively.\n# \n# \n# Example 1:\n# Input: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\n# Output: 23\n# Explanation:\n# Score  a=1, c=9, d=5, g=3, o=2\n# Given letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23.\n# \n# Words \"dad\" and \"dog\" only get a score of 21.\n# \n# \n# Example 2:\n# Input: words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\n# Output: 27\n# Explanation:\n# Score  a=4, b=4, c=4, x=5, z=10\n# Given letters, we can form the words \"ax\" (4+5), \"bx\" (4+5) and \"cx\" (4+5) with a score of 27.\n# \n# Word \"xxxz\" only get a score of 25.\n# \n# \n# Example 3:\n# Input: words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\n# Output: 0\n# Explanation:\n# Letter \"e\" can only be used once.\n# \n# \n# Constraints:\n# `1 <= words.length <= 14`\n# `1 <= words[i].length <= 15`\n# `1 <= letters.length <= 100`\n# `letters[i].length == 1`\n# `score.length == 26`\n# `0 <= score[i] <= 10`\n# `words[i]`, `letters[i]` contains only lower case English letters.\ndef maxScoreWords(words: List[str], letters: List[str], score: List[int]) -> int:\n", "entry_point": "maximum-score-words-formed-by-letters", "cannonical_solution": "", "test": ""}
{"task_id": "cat-and-mouse-ii", "prompt": "# A game is played by a cat and a mouse named Cat and Mouse.\n# \n# The environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.\n# \n# Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).\n# \n# Floors are represented by the character `'.'` and can be walked on.\n# \n# Walls are represented by the character `'#'` and cannot be walked on.\n# \n# Food is represented by the character `'F'` and can be walked on.\n# \n# There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n# \n# Mouse and Cat play according to the following rules:\n# Mouse moves first, then they take turns to move.\n# \n# During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.\n# \n# `catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n# \n# Staying in the same position is allowed.\n# \n# Mouse can jump over Cat.\n# \n# The game can end in 4 ways:\n# If Cat occupies the same position as Mouse, Cat wins.\n# \n# If Cat reaches the food first, Cat wins.\n# \n# If Mouse reaches the food first, Mouse wins.\n# \n# If Mouse cannot get to the food within 1000 turns, Cat wins.\n# \n# Given a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` if Mouse can win the game if both Cat and Mouse play optimally, otherwise return `false`.\n# \n# \n# Example 1:\n# Input: grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\n# Output: true\n# Explanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n# \n# \n# Example 2:\n# Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\n# Output: true\n# \n# Example 3:\n# Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\n# Output: false\n# \n# Example 4:\n# Input: grid = [\"C...#\",\"...#F\",\"....#\",\"M....\"], catJump = 2, mouseJump = 5\n# Output: false\n# \n# Example 5:\n# Input: grid = [\".M...\",\"..#..\",\"#..#.\",\"C#.#.\",\"...#F\"], catJump = 3, mouseJump = 1\n# Output: true\n# \n# Constraints:\n# `rows == grid.length`\n# `cols = grid[i].length`\n# `1 <= rows, cols <= 8`\n# `grid[i][j]` consist only of characters `'C'`, `'M'`, `'F'`, `'.'`, and `'#'`.\n# \n# There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n# \n# `1 <= catJump, mouseJump <= 8`\ndef canMouseWin(grid: List[str], catJump: int, mouseJump: int) -> bool:\n", "entry_point": "cat-and-mouse-ii", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-music-playlists", "prompt": "# Your music player contains `N` different songs and she wants to listen to `L` (not necessarily different) songs during your trip.  You create a playlist so that:\n# Every song is played at least once\n# A song can only be played again only if `K` other songs have been played\n# Return the number of possible playlists.  As the answer can be very large, return it modulo `10^9 + 7`.\n# \n# \n# Example 1:\n# Input: N = 3, L = 3, K = 1\n# Output: 6\n# Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].\n# \n# \n# Example 2:\n# Input: N = 2, L = 3, K = 0\n# Output: 6\n# Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]\n# \n# Example 3:\n# Input: N = 2, L = 3, K = 1\n# Output: 2\n# Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]\n# Note:\n# `0 <= K < N <= L <= 100`\ndef numMusicPlaylists(n: int, goal: int, k: int) -> int:\n", "entry_point": "number-of-music-playlists", "cannonical_solution": "", "test": ""}
{"task_id": "longest-consecutive-sequence", "prompt": "# Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n# \n# \n# Example 1:\n# Input: nums = [100,4,200,1,3,2]\n# Output: 4\n# Explanation: The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.\n# \n# \n# Example 2:\n# Input: nums = [0,3,7,2,5,8,4,6,0,1]\n# Output: 9\n# \n# Constraints:\n# `0 <= nums.length <= 104`\n# `-109 <= nums[i] <= 109`\n# Follow up: Could you implement the `O(n)` solution?\ndef longestConsecutive(nums: List[int]) -> int:\n", "entry_point": "longest-consecutive-sequence", "cannonical_solution": "", "test": ""}
{"task_id": "count-different-palindromic-subsequences", "prompt": "# Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo `10^9 + 7`.\n# \n# A subsequence of a string S is obtained by deleting 0 or more characters from S.\n# \n# A sequence is palindromic if it is equal to the sequence reversed.\n# \n# Two sequences `A_1, A_2, ...` and `B_1, B_2, ...` are different if there is some `i` for which `A_i != B_i`.\n# \n# \n# Example 1:\n# Input: \n# S = 'bccb'\n# Output: 6\n# Explanation: \n# The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\n# \n# Note that 'bcb' is counted only once, even though it occurs twice.\n# \n# \n# Example 2:\n# Input: \n# S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'\n# Output: 104860361\n# Explanation: \n# There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.\n# \n# Note:\n# The length of `S` will be in the range `[1, 1000]`.\n# \n# Each character `S[i]` will be in the set `{'a', 'b', 'c', 'd'}`.\ndef countPalindromicSubsequences(s: str) -> int:\n", "entry_point": "count-different-palindromic-subsequences", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-moves-to-reach-target-with-rotations", "prompt": "# In an `n*n` grid, there is a snake that spans 2 cells and starts moving from the top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.\n# \n# In one move the snake can:\n# Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n# \n# Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n# \n# Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.\n# \n# Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.\n# \n# Return the minimum number of moves to reach the target.\n# \n# If there is no way to reach the target, return `-1`.\n# \n# \n# Example 1:\n# Input: grid = [[0,0,0,0,0,1],\n#                [1,1,0,0,1,0],\n#                [0,0,0,0,1,1],\n#                [0,0,1,0,1,0],\n#                [0,1,1,0,0,0],\n#                [0,1,1,0,0,0]]\n# Output: 11\n# Explanation:\n# One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].\n# \n# \n# Example 2:\n# Input: grid = [[0,0,1,1,1,1],\n#                [0,0,0,0,1,1],\n#                [1,1,0,0,0,1],\n#                [1,1,1,0,0,1],\n#                [1,1,1,0,0,1],\n#                [1,1,1,0,0,0]]\n# Output: 9\n# \n# Constraints:\n# `2 <= n <= 100`\n# `0 <= grid[i][j] <= 1`\n# It is guaranteed that the snake starts at empty cells.\ndef minimumMoves(grid: List[List[int]]) -> int:\n", "entry_point": "minimum-moves-to-reach-target-with-rotations", "cannonical_solution": "", "test": ""}
{"task_id": "burst-balloons", "prompt": "# You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n# \n# If you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n# \n# Return the maximum coins you can collect by bursting the balloons wisely.\n# \n# \n# Example 1:\n# Input: nums = [3,1,5,8]\n# Output: 167\n# Explanation:\n# nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\n# coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n# \n# Example 2:\n# Input: nums = [1,5]\n# Output: 10\n# \n# Constraints:\n# `n == nums.length`\n# `1 <= n <= 500`\n# `0 <= nums[i] <= 100`\ndef maxCoins(nums: List[int]) -> int:\n", "entry_point": "burst-balloons", "cannonical_solution": "", "test": ""}
{"task_id": "odd-even-jump", "prompt": "# You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.\n# \n# You may jump forward from index `i` to index `j` (with `i < j`) in the following way:\n# During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.\n# \n# During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.\n# \n# It may be the case that for some index `i`, there are no legal jumps.\n# \n# A starting index is good if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).\n# \n# Return the number of good starting indices.\n# \n# \n# Example 1:\n# Input: arr = [10,13,12,14,15]\n# Output: 2\n# Explanation: \n# From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.\n# \n# From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\n# \n# From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\n# \n# From starting index i = 4, we have reached the end already.\n# \n# In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\n# jumps.\n# \n# \n# Example 2:\n# Input: arr = [2,3,1,1,4]\n# Output: 3\n# Explanation: \n# From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\n# During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].\n# \n# During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\n# During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].\n# \n# We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\n# \n# In a similar manner, we can deduce that:\n# From starting index i = 1, we jump to i = 4, so we reach the end.\n# \n# From starting index i = 2, we jump to i = 3, and then we can't jump anymore.\n# \n# From starting index i = 3, we jump to i = 4, so we reach the end.\n# \n# From starting index i = 4, we are already at the end.\n# \n# In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\n# number of jumps.\n# \n# \n# Example 3:\n# Input: arr = [5,1,3,4,2]\n# Output: 3\n# Explanation: We can reach the end from starting indices 1, 2, and 4.\n# \n# \n# Constraints:\n# `1 <= arr.length <= 2 * 104`\n# `0 <= arr[i] < 105`\ndef oddEvenJumps(arr: List[int]) -> int:\n", "entry_point": "odd-even-jump", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-candies-you-can-get-from-boxes", "prompt": "# Given `n` boxes, each box is given in the format `[status, candies, keys, containedBoxes]` where:\n# `status[i]`: an integer which is 1 if `box[i]` is open and 0 if `box[i]` is closed.\n# \n# `candies[i]`: an integer representing the number of candies in `box[i]`.\n# \n# `keys[i]`: an array contains the indices of the boxes you can open with the key in `box[i]`.\n# \n# `containedBoxes[i]`: an array contains the indices of the boxes found in `box[i]`.\n# \n# You will start with some boxes given in `initialBoxes` array. You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it.\n# \n# Return the maximum number of candies you can get following the rules above.\n# \n# \n# Example 1:\n# Input: status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]\n# Output: 16\n# Explanation: You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2. Box 1 is closed and you don't have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.\n# \n# In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.\n# \n# Total number of candies collected = 7 + 4 + 5 = 16 candy.\n# \n# \n# Example 2:\n# Input: status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]\n# Output: 6\n# Explanation: You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys. The total number of candies will be 6.\n# \n# \n# Example 3:\n# Input: status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1]\n# Output: 1\n# \n# Example 4:\n# Input: status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = []\n# Output: 0\n# \n# Example 5:\n# Input: status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0]\n# Output: 7\n# \n# Constraints:\n# `1 <= status.length <= 1000`\n# `status.length == candies.length == keys.length == containedBoxes.length == n`\n# `status[i]` is `0` or `1`.\n# \n# `1 <= candies[i] <= 1000`\n# `0 <= keys[i].length <= status.length`\n# `0 <= keys[i][j] < status.length`\n# All values in `keys[i]` are unique.\n# \n# `0 <= containedBoxes[i].length <= status.length`\n# `0 <= containedBoxes[i][j] < status.length`\n# All values in `containedBoxes[i]` are unique.\n# \n# Each box is contained in one box at most.\n# \n# `0 <= initialBoxes.length <= status.length`\n# `0 <= initialBoxes[i] < status.length`\ndef maxCandies(status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n", "entry_point": "maximum-candies-you-can-get-from-boxes", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-valid-words-for-each-puzzle", "prompt": "# With respect to a given `puzzle` string, a `word` is valid if both the following conditions are satisfied:\n# `word` contains the first letter of `puzzle`.\n# \n# For each letter in `word`, that letter is in `puzzle`.\n# \n# \tFor example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\"; while invalid words are \"beefed\" (doesn't include \"a\") and \"based\" (includes \"s\" which isn't in the puzzle).\n# \n# Return an array `answer`, where `answer[i]` is the number of words in the given word list `words` that are valid with respect to the puzzle `puzzles[i]`.\n# \n# \n# Example :\n# Input: \n# words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], \n# puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"]\n# Output: [1,1,3,2,4,0]\n# Explanation:\n# 1 valid word for \"aboveyz\" : \"aaaa\" \n# 1 valid word for \"abrodyz\" : \"aaaa\"\n# 3 valid words for \"abslute\" : \"aaaa\", \"asas\", \"able\"\n# 2 valid words for \"absoryz\" : \"aaaa\", \"asas\"\n# 4 valid words for \"actresz\" : \"aaaa\", \"asas\", \"actt\", \"access\"\n# There're no valid words for \"gaswxyz\" cause none of the words in the list contains letter 'g'.\n# \n# \n# Constraints:\n# `1 <= words.length <= 10^5`\n# `4 <= words[i].length <= 50`\n# `1 <= puzzles.length <= 10^4`\n# `puzzles[i].length == 7`\n# `words[i][j]`, `puzzles[i][j]` are English lowercase letters.\n# \n# Each `puzzles[i] `doesn't contain repeated characters.\ndef findNumOfValidWords(words: List[str], puzzles: List[str]) -> List[int]:\n", "entry_point": "number-of-valid-words-for-each-puzzle", "cannonical_solution": "", "test": ""}
