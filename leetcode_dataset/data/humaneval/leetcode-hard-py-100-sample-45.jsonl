{"task_id": "remove-max-number-of-edges-to-keep-graph-fully-traversable", "prompt": "def maxNumEdgesToRemove(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Alice and Bob have an undirected graph of `n` nodes and 3 types of edges:\n    Type 1: Can be traversed by Alice only.\n    Type 2: Can be traversed by Bob only.\n    Type 3: Can by traversed by both Alice and Bob.\n    Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.\n    Return the maximum number of edges you can remove, or return `-1` if it's impossible for the graph to be fully traversed by Alice and Bob.\n    \"\"\"\n", "entry_point": "remove-max-number-of-edges-to-keep-graph-fully-traversable", "cannonical_solution": "", "test": ""}
{"task_id": "smallest-sufficient-team", "prompt": "def smallestSufficientTeam(req_skills: List[str], people: List[List[str]]) -> List[int]:\n    \"\"\"\n    In a project, you have a list of required skills `req_skills`, and a list of people. The `ith` person `people[i]` contains a list of skills that the person has.\n    Consider a sufficient team: a set of people such that for every required skill in `req_skills`, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.\n    For example, `team = [0, 1, 3]` represents the people with skills `people[0]`, `people[1]`, and `people[3]`.\n    Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.\n    It is guaranteed an answer exists.\n    \"\"\"\n", "entry_point": "smallest-sufficient-team", "cannonical_solution": "", "test": ""}
{"task_id": "shortest-subarray-with-sum-at-least-k", "prompt": "def shortestSubarray(nums: List[int], k: int) -> int:\n    \"\"\"\n    Return the length of the shortest, non-empty, contiguous subarray of `A` with sum at least `K`.\n    If there is no non-empty subarray with sum at least `K`, return `-1`.\n    \"\"\"\n", "entry_point": "shortest-subarray-with-sum-at-least-k", "cannonical_solution": "", "test": ""}
{"task_id": "sum-of-distances-in-tree", "prompt": "def sumOfDistancesInTree(n: int, edges: List[List[int]]) -> List[int]:\n    \"\"\"\n    An undirected, connected tree with `N` nodes labelled `0...N-1` and `N-1` `edges` are given.\n    The `i`th edge connects nodes `edges[i][0] `and` edges[i][1]` together.\n    Return a list `ans`, where `ans[i]` is the sum of the distances between node `i` and all other nodes.\n    \"\"\"\n", "entry_point": "sum-of-distances-in-tree", "cannonical_solution": "", "test": ""}
{"task_id": "tiling-a-rectangle-with-the-fewest-squares", "prompt": "def tilingRectangle(n: int, m: int) -> int:\n    \"\"\"\n    Given a rectangle of size `n` x `m`, find the minimum number of integer-sided squares that tile the rectangle.\n    \"\"\"\n", "entry_point": "tiling-a-rectangle-with-the-fewest-squares", "cannonical_solution": "", "test": ""}
{"task_id": "ipo", "prompt": "def findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -> int:\n    \"\"\"\n    Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\n    You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n    To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.\n    \"\"\"\n", "entry_point": "ipo", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-number-of-days-to-eat-n-oranges", "prompt": "def minDays(n: int) -> int:\n    \"\"\"\n    There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows:\n    Eat one orange.\n    If the number of remaining oranges (`n`) is divisible by 2 then you can eat  n/2 oranges.\n    If the number of remaining oranges (`n`) is divisible by 3 then you can eat  2*(n/3) oranges.\n    You can only choose one of the actions per day.\n    Return the minimum number of days to eat `n` oranges.\n    \"\"\"\n", "entry_point": "minimum-number-of-days-to-eat-n-oranges", "cannonical_solution": "", "test": ""}
{"task_id": "palindrome-pairs", "prompt": "def palindromePairs(words: List[str]) -> List[List[int]]:\n    \"\"\"\n    Given a list of unique words, return all the pairs of the distinct indices `(i, j)` in the given list, so that the concatenation of the two words `words[i] + words[j]` is a palindrome.\n    \"\"\"\n", "entry_point": "palindrome-pairs", "cannonical_solution": "", "test": ""}
{"task_id": "strange-printer-ii", "prompt": "def isPrintable(targetGrid: List[List[int]]) -> bool:\n    \"\"\"\n    There is a strange printer with the following two special requirements:\n    On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n    Once the printer has used a color for the above operation, the same color cannot be used again.\n    You are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is the color in the position `(row, col)` of the grid.\n    Return `true` if it is possible to print the matrix `targetGrid`, otherwise, return `false`.\n    \"\"\"\n", "entry_point": "strange-printer-ii", "cannonical_solution": "", "test": ""}
{"task_id": "transform-to-chessboard", "prompt": "def movesToChessboard(board: List[List[int]]) -> int:\n    \"\"\"\n    An N x N `board` contains only `0`s and `1`s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.\n    What is the minimum number of moves to transform the board into a \"chessboard\" - a board where no `0`s and no `1`s are 4-directionally adjacent? If the task is impossible, return -1.\n    \"\"\"\n", "entry_point": "transform-to-chessboard", "cannonical_solution": "", "test": ""}
{"task_id": "count-pairs-with-xor-in-a-range", "prompt": "def countPairs(nums: List[int], low: int, high: int) -> int:\n    \"\"\"\n    Given a (0-indexed) integer array `nums` and two integers `low` and `high`, return the number of nice pairs.\n    A nice pair is a pair `(i, j)` where `0 <= i < j < nums.length` and `low <= (nums[i] XOR nums[j]) <= high`.\n    \"\"\"\n", "entry_point": "count-pairs-with-xor-in-a-range", "cannonical_solution": "", "test": ""}
{"task_id": "cracking-the-safe", "prompt": "def crackSafe(n: int, k: int) -> str:\n    \"\"\"\n    There is a box protected by a password. The password is a sequence of `n` digits where each digit can be one of the first `k` digits `0, 1, ..., k-1`.\n    While entering a password, the last `n` digits entered will automatically be matched against the correct password.\n    For example, assuming the correct password is `\"345\"`, if you type `\"012345\"`, the box will open because the correct password matches the suffix of the entered password.\n    Return any password of minimum length that is guaranteed to open the box at some point of entering it.\n    \"\"\"\n", "entry_point": "cracking-the-safe", "cannonical_solution": "", "test": ""}
{"task_id": "reverse-pairs", "prompt": "def reversePairs(nums: List[int]) -> int:\n    \"\"\"\n    Given an array `nums`, we call `(i, j)` an important reverse pair if `i < j` and `nums[i] > 2*nums[j]`.\n    You need to return the number of important reverse pairs in the given array.\n    \"\"\"\n", "entry_point": "reverse-pairs", "cannonical_solution": "", "test": ""}
{"task_id": "parsing-a-boolean-expression", "prompt": "def parseBoolExpr(expression: str) -> bool:\n    \"\"\"\n    Return the result of evaluating a given boolean `expression`, represented as a string.\n    An expression can either be:\n    `\"t\"`, evaluating to `True`;\n    `\"f\"`, evaluating to `False`;\n    `\"!(expr)\"`, evaluating to the logical NOT of the inner expression `expr`;\n    `\"&(expr1,expr2,...)\"`, evaluating to the logical AND of 2 or more inner expressions `expr1, expr2, ...`;\n    `\"|(expr1,expr2,...)\"`, evaluating to the logical OR of 2 or more inner expressions `expr1, expr2, ...`\n    \"\"\"\n", "entry_point": "parsing-a-boolean-expression", "cannonical_solution": "", "test": ""}
{"task_id": "bricks-falling-when-hit", "prompt": "def hitBricks(grid: List[List[int]], hits: List[List[int]]) -> List[int]:\n    \"\"\"\n    You are given an `m x n` binary `grid`, where each `1` represents a brick and `0` represents an empty space. A brick is stable if:\n    It is directly connected to the top of the grid, or\n    At least one other brick in its four adjacent cells is stable.\n    You are also given an array `hits`, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location `hits[i] = (rowi, coli)`. The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the `grid` (i.e., it does not land on other stable bricks).\n    Return an array `result`, where each `result[i]` is the number of bricks that will fall after the `ith` erasure is applied.\n    Note that an erasure may refer to a location with no brick, and if it does, no bricks drop.\n    \"\"\"\n", "entry_point": "bricks-falling-when-hit", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-ways-to-reorder-array-to-get-same-bst", "prompt": "def numOfWays(nums: List[int]) -> int:\n    \"\"\"\n    Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`.\n    For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST.\n    Return the number of ways to reorder `nums` such that the BST formed is identical to the original BST formed from `nums`.\n    Since the answer may be very large, return it modulo `10^9 + 7`.\n    \"\"\"\n", "entry_point": "number-of-ways-to-reorder-array-to-get-same-bst", "cannonical_solution": "", "test": ""}
{"task_id": "restore-the-array", "prompt": "def numberOfArrays(s: str, k: int) -> int:\n    \"\"\"\n    A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits and all we know is that all integers in the array were in the range `[1, k]` and there are no leading zeros in the array.\n    Given the string `s` and the integer `k`. There can be multiple ways to restore the array.\n    Return the number of possible array that can be printed as a string `s` using the mentioned program.\n    The number of ways could be very large so return it modulo `10^9 + 7`\n    \"\"\"\n", "entry_point": "restore-the-array", "cannonical_solution": "", "test": ""}
{"task_id": "word-search-ii", "prompt": "def findWords(board: List[List[str]], words: List[str]) -> List[str]:\n    \"\"\"\n    Given an `m x n` `board` of characters and a list of strings `words`, return all words on the board.\n    Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n    \"\"\"\n", "entry_point": "word-search-ii", "cannonical_solution": "", "test": ""}
{"task_id": "check-if-string-is-transformable-with-substring-sort-operations", "prompt": "def isTransformable(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings `s` and `t`, you want to transform string `s` into string `t` using the following operation any number of times:\n    Choose a non-empty substring in `s` and sort it in-place so the characters are in ascending order.\n    For example, applying the operation on the underlined substring in `\"14234\"` results in `\"12344\"`.\n    Return `true` if it is possible to transform string `s` into string `t`. Otherwise, return `false`.\n    A substring is a contiguous sequence of characters within a string.\n    \"\"\"\n", "entry_point": "check-if-string-is-transformable-with-substring-sort-operations", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "prompt": "def minInteger(num: str, k: int) -> str:\n    \"\"\"\n    Given a string `num` representing the digits of a very large integer and an integer `k`.\n    You are allowed to swap any two adjacent digits of the integer at most `k` times.\n    Return the minimum integer you can obtain also as a string.\n    \"\"\"\n", "entry_point": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "cannonical_solution": "", "test": ""}
{"task_id": "reaching-points", "prompt": "def reachingPoints(sx: int, sy: int, tx: int, ty: int) -> bool:\n    \"\"\"\n    A move consists of taking a point `(x, y)` and transforming it to either `(x, x+y)` or `(x+y, y)`.\n    Given a starting point `(sx, sy)` and a target point `(tx, ty)`, return `True` if and only if a sequence of moves exists to transform the point `(sx, sy)` to `(tx, ty)`. Otherwise, return `False`.\n    \"\"\"\n", "entry_point": "reaching-points", "cannonical_solution": "", "test": ""}
{"task_id": "sliding-window-maximum", "prompt": "def maxSlidingWindow(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n    Return the max sliding window.\n    \"\"\"\n", "entry_point": "sliding-window-maximum", "cannonical_solution": "", "test": ""}
{"task_id": "smallest-rotation-with-highest-score", "prompt": "def bestRotation(nums: List[int]) -> int:\n    \"\"\"\n    Given an array `A`, we may rotate it by a non-negative integer `K` so that the array becomes `A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]`.  Afterward, any entries that are less than or equal to their index are worth 1 point.\n    For example, if we have `[2, 4, 1, 3, 0]`, and we rotate by `K = 2`, it becomes `[1, 3, 0, 2, 4]`.  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].\n    Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.\n    \"\"\"\n", "entry_point": "smallest-rotation-with-highest-score", "cannonical_solution": "", "test": ""}
{"task_id": "split-array-with-same-average", "prompt": "def splitArraySameAverage(nums: List[int]) -> bool:\n    \"\"\"\n    You are given an integer array `nums`.\n    You should move each element of `nums` into one of the two arrays `A` and `B` such that `A` and `B` are non-empty, and `average(A) == average(B)`.\n    Return `true` if it is possible to achieve that and `false` otherwise.\n    Note that for an array `arr`, `average(arr)` is the sum of all the elements of `arr` over the length of `arr`.\n    \"\"\"\n", "entry_point": "split-array-with-same-average", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-atoms", "prompt": "def countOfAtoms(formula: str) -> str:\n    \"\"\"\n    Given a chemical `formula` (given as a string), return the count of each atom.\n    The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n    One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.\n    Two formulas concatenated together to produce another formula. For example, H2O2He3Mg4 is also a formula.\n    A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.\n    Given a `formula`, return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\n    \"\"\"\n", "entry_point": "number-of-atoms", "cannonical_solution": "", "test": ""}
{"task_id": "last-substring-in-lexicographical-order", "prompt": "def lastSubstring(s: str) -> str:\n    \"\"\"\n    Given a string `s`, return the last substring of `s` in lexicographical order.\n    \"\"\"\n", "entry_point": "last-substring-in-lexicographical-order", "cannonical_solution": "", "test": ""}
{"task_id": "sort-items-by-groups-respecting-dependencies", "prompt": "def sortItems(n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n    \"\"\"\n    There are `n` items each belonging to zero or one of `m` groups where `group[i]` is the group that the `i`-th item belongs to and it's equal to `-1` if the `i`-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n    Return a sorted list of the items such that:\n    The items that belong to the same group are next to each other in the sorted list.\n    There are some relations between these items where `beforeItems[i]` is a list containing all the items that should come before the `i`-th item in the sorted array (to the left of the `i`-th item).\n    Return any solution if there is more than one solution and return an empty list if there is no solution.\n    \"\"\"\n", "entry_point": "sort-items-by-groups-respecting-dependencies", "cannonical_solution": "", "test": ""}
{"task_id": "trapping-rain-water-ii", "prompt": "def trapRainWater(heightMap: List[List[int]]) -> int:\n    \"\"\"\n    Given an `m x n` matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\n    \"\"\"\n", "entry_point": "trapping-rain-water-ii", "cannonical_solution": "", "test": ""}
{"task_id": "parse-lisp-expression", "prompt": "def evaluate(expression: str) -> int:\n    \"\"\"\n    You are given a string `expression` representing a Lisp-like expression to return the integer value of.\n    The syntax for these expressions is given as follows.\n    An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.\n    (An integer could be positive or negative.)\n    A let-expression takes the form `(let v1 e1 v2 e2 ... vn en expr)`, where `let` is always the string `\"let\"`, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable `v1` is assigned the value of the expression `e1`, the second variable `v2` is assigned the value of the expression `e2`, and so on sequentially; and then the value of this let-expression is the value of the expression `expr`.\n    An add-expression takes the form `(add e1 e2)` where `add` is always the string `\"add\"`, there are always two expressions `e1, e2`, and this expression evaluates to the addition of the evaluation of `e1` and the evaluation of `e2`.\n    A mult-expression takes the form `(mult e1 e2)` where `mult` is always the string `\"mult\"`, there are always two expressions `e1, e2`, and this expression evaluates to the multiplication of the evaluation of `e1` and the evaluation of `e2`.\n    For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names.\n    Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.\n    \"\"\"\n", "entry_point": "parse-lisp-expression", "cannonical_solution": "", "test": ""}
{"task_id": "bus-routes", "prompt": "def numBusesToDestination(routes: List[List[int]], source: int, target: int) -> int:\n    \"\"\"\n    You are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `ith` bus repeats forever.\n    For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.\n    You will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.\n    Return the least number of buses you must take to travel from `source` to `target`. Return `-1` if it is not possible.\n    \"\"\"\n", "entry_point": "bus-routes", "cannonical_solution": "", "test": ""}
{"task_id": "poor-pigs", "prompt": "def poorPigs(buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n    \"\"\"\n    There are `buckets` buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n    You can feed the pigs according to these steps:\n    Choose some live pigs to feed.\n    For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.\n    Wait for `minutesToDie` minutes. You may not feed any other pigs during this time.\n    After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n    Repeat this process until you run out of time.\n    Given `buckets`, `minutesToDie`, and `minutesToTest`, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n    \"\"\"\n", "entry_point": "poor-pigs", "cannonical_solution": "", "test": ""}
{"task_id": "sliding-puzzle", "prompt": "def slidingPuzzle(board: List[List[int]]) -> int:\n    \"\"\"\n    On a 2x3 `board`, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.\n    A move consists of choosing `0` and a 4-directionally adjacent number and swapping it.\n    The state of the board is solved if and only if the `board` is `[[1,2,3],[4,5,0]].`\n    Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\n    \"\"\"\n", "entry_point": "sliding-puzzle", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-number-of-k-consecutive-bit-flips", "prompt": "def minKBitFlips(nums: List[int], k: int) -> int:\n    \"\"\"\n    In an array `A` containing only 0s and 1s, a `K`-bit flip consists of choosing a (contiguous) subarray of length `K` and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\n    Return the minimum number of `K`-bit flips required so that there is no 0 in the array.  If it is not possible, return `-1`.\n    \"\"\"\n", "entry_point": "minimum-number-of-k-consecutive-bit-flips", "cannonical_solution": "", "test": ""}
{"task_id": "form-largest-integer-with-digits-that-add-up-to-target", "prompt": "def largestNumber(cost: List[int], target: int) -> str:\n    \"\"\"\n    Given an array of integers `cost` and an integer `target`. Return the maximum integer you can paint under the following rules:\n    The cost of painting a digit (i+1) is given by `cost[i]` (0 indexed).\n    The total cost used must be equal to `target`.\n    Integer does not have digits 0.\n    Since the answer may be too large, return it as string.\n    If there is no way to paint any integer given the condition, return \"0\".\n    \"\"\"\n", "entry_point": "form-largest-integer-with-digits-that-add-up-to-target", "cannonical_solution": "", "test": ""}
{"task_id": "sum-of-subsequence-widths", "prompt": "def sumSubseqWidths(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers `A`, consider all non-empty subsequences of `A`.\n    For any sequence S, let the width of S be the difference between the maximum and minimum element of S.\n    Return the sum of the widths of all subsequences of A.\n    As the answer may be very large, return the answer modulo 10^9 + 7.\n    \"\"\"\n", "entry_point": "sum-of-subsequence-widths", "cannonical_solution": "", "test": ""}
{"task_id": "super-egg-drop", "prompt": "def superEggDrop(k: int, n: int) -> int:\n    \"\"\"\n    You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n    You know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor higher than `f` will break, and any egg dropped at or below floor `f` will not break.\n    Each move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.\n    Return the minimum number of moves that you need to determine with certainty what the value of `f` is.\n    \"\"\"\n", "entry_point": "super-egg-drop", "cannonical_solution": "", "test": ""}
{"task_id": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons", "prompt": "def numOfArrays(n: int, m: int, k: int) -> int:\n    \"\"\"\n    Given three integers `n`, `m` and `k`. Consider the following algorithm to find the maximum element of an array of positive integers:\n    You should build the array arr which has the following properties:\n    `arr` has exactly `n` integers.\n    `1 <= arr[i] <= m` where `(0 <= i < n)`.\n    After applying the mentioned algorithm to `arr`, the value `search_cost` is equal to `k`.\n    Return the number of ways to build the array `arr` under the mentioned conditions. As the answer may grow large, the answer must be computed modulo `10^9 + 7`.\n    \"\"\"\n", "entry_point": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-ways-of-cutting-a-pizza", "prompt": "def ways(pizza: List[str], k: int) -> int:\n    \"\"\"\n    Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n    For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n    Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.\n    \"\"\"\n", "entry_point": "number-of-ways-of-cutting-a-pizza", "cannonical_solution": "", "test": ""}
{"task_id": "k-th-smallest-in-lexicographical-order", "prompt": "def findKthNumber(n: int, k: int) -> int:\n    \"\"\"\n    Given integers `n` and `k`, find the lexicographically k-th smallest integer in the range from `1` to `n`.\n    Note: 1 \u2264 k \u2264 n \u2264 109.\n    \"\"\"\n", "entry_point": "k-th-smallest-in-lexicographical-order", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-initial-energy-to-finish-tasks", "prompt": "def minimumEffort(tasks: List[List[int]]) -> int:\n    \"\"\"\n    You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n    `actuali` is the actual amount of energy you spend to finish the `ith` task.\n    `minimumi` is the minimum amount of energy you require to begin the `ith` task.\n    For example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n    You can finish the tasks in any order you like.\n    Return the minimum initial amount of energy you will need to finish all the tasks.\n    \"\"\"\n", "entry_point": "minimum-initial-energy-to-finish-tasks", "cannonical_solution": "", "test": ""}
{"task_id": "text-justification", "prompt": "def fullJustify(words: List[str], maxWidth: int) -> List[str]:\n    \"\"\"\n    Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n    You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly maxWidth characters.\n    Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n    For the last line of text, it should be left justified and no extra space is inserted between words.\n    Note:\n    A word is defined as a character sequence consisting of non-space characters only.\n    Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n    The input array `words` contains at least one word.\n    \"\"\"\n", "entry_point": "text-justification", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-cost-to-hire-k-workers", "prompt": "def mincostToHireWorkers(quality: List[int], wage: List[int], k: int) -> float:\n    \"\"\"\n    There are `N` workers.  The `i`-th worker has a `quality[i]` and a minimum wage expectation `wage[i]`.\n    Now we want to hire exactly `K` workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:\n    Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n    Every worker in the paid group must be paid at least their minimum wage expectation.\n    Return the least amount of money needed to form a paid group satisfying the above conditions.\n    \"\"\"\n", "entry_point": "minimum-cost-to-hire-k-workers", "cannonical_solution": "", "test": ""}
{"task_id": "decode-ways-ii", "prompt": "def numDecodings(s: str) -> int:\n    \"\"\"\n    A message containing letters from `A-Z` can be encoded into numbers using the following mapping:\n    'A' -> \"1\"\n    'B' -> \"2\"\n    ...\n    'Z' -> \"26\"\n    To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106\"` can be mapped into:\n    `\"AAJF\"` with the grouping `(1 1 10 6)`\n    `\"KJF\"` with the grouping `(11 10 6)`\n    Note that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n    In addition to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `\"1*\"` may represent any of the encoded messages `\"11\"`, `\"12\"`, `\"13\"`, `\"14\"`, `\"15\"`, `\"16\"`, `\"17\"`, `\"18\"`, or `\"19\"`. Decoding `\"1*\"` is equivalent to decoding any of the encoded messages it can represent.\n    Given a string `s` containing digits and the `'*'` character, return the number of ways to decode it.\n    Since the answer may be very large, return it modulo `109 + 7`.\n    \"\"\"\n", "entry_point": "decode-ways-ii", "cannonical_solution": "", "test": ""}
{"task_id": "create-maximum-number", "prompt": "def maxNumber(nums1: List[int], nums2: List[int], k: int) -> List[int]:\n    \"\"\"\n    You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`.\n    Create the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n    Return an array of the `k` digits representing the answer.\n    \"\"\"\n", "entry_point": "create-maximum-number", "cannonical_solution": "", "test": ""}
{"task_id": "consecutive-numbers-sum", "prompt": "def consecutiveNumbersSum(n: int) -> int:\n    \"\"\"\n    Given a positive integer `N`, how many ways can we write it as a sum of consecutive positive integers?\n    \"\"\"\n", "entry_point": "consecutive-numbers-sum", "cannonical_solution": "", "test": ""}