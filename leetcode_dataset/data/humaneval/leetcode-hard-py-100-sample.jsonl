{"task_id": "remove-max-number-of-edges-to-keep-graph-fully-traversable", "prompt": "def maxNumEdgesToRemove(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Alice and Bob have an undirected graph of `n` nodes and 3 types of edges:\n    Type 1: Can be traversed by Alice only.\n    Type 2: Can be traversed by Bob only.\n    Type 3: Can by traversed by both Alice and Bob.\n    Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.\n    Return the maximum number of edges you can remove, or return `-1` if it's impossible for the graph to be fully traversed by Alice and Bob.\n    \"\"\"\n", "entry_point": "remove-max-number-of-edges-to-keep-graph-fully-traversable", "cannonical_solution": "", "test": ""}
{"task_id": "smallest-sufficient-team", "prompt": "def smallestSufficientTeam(req_skills: List[str], people: List[List[str]]) -> List[int]:\n    \"\"\"\n    In a project, you have a list of required skills `req_skills`, and a list of people. The `ith` person `people[i]` contains a list of skills that the person has.\n    Consider a sufficient team: a set of people such that for every required skill in `req_skills`, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.\n    For example, `team = [0, 1, 3]` represents the people with skills `people[0]`, `people[1]`, and `people[3]`.\n    Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.\n    It is guaranteed an answer exists.\n    \"\"\"\n", "entry_point": "smallest-sufficient-team", "cannonical_solution": "", "test": ""}
{"task_id": "shortest-subarray-with-sum-at-least-k", "prompt": "def shortestSubarray(nums: List[int], k: int) -> int:\n    \"\"\"\n    Return the length of the shortest, non-empty, contiguous subarray of `A` with sum at least `K`.\n    If there is no non-empty subarray with sum at least `K`, return `-1`.\n    \"\"\"\n", "entry_point": "shortest-subarray-with-sum-at-least-k", "cannonical_solution": "", "test": ""}
{"task_id": "sum-of-distances-in-tree", "prompt": "def sumOfDistancesInTree(n: int, edges: List[List[int]]) -> List[int]:\n    \"\"\"\n    An undirected, connected tree with `N` nodes labelled `0...N-1` and `N-1` `edges` are given.\n    The `i`th edge connects nodes `edges[i][0] `and` edges[i][1]` together.\n    Return a list `ans`, where `ans[i]` is the sum of the distances between node `i` and all other nodes.\n    \"\"\"\n", "entry_point": "sum-of-distances-in-tree", "cannonical_solution": "", "test": ""}
{"task_id": "tiling-a-rectangle-with-the-fewest-squares", "prompt": "def tilingRectangle(n: int, m: int) -> int:\n    \"\"\"\n    Given a rectangle of size `n` x `m`, find the minimum number of integer-sided squares that tile the rectangle.\n    \"\"\"\n", "entry_point": "tiling-a-rectangle-with-the-fewest-squares", "cannonical_solution": "", "test": ""}
{"task_id": "ipo", "prompt": "def findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -> int:\n    \"\"\"\n    Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\n    You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n    To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.\n    \"\"\"\n", "entry_point": "ipo", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-number-of-days-to-eat-n-oranges", "prompt": "def minDays(n: int) -> int:\n    \"\"\"\n    There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows:\n    Eat one orange.\n    If the number of remaining oranges (`n`) is divisible by 2 then you can eat  n/2 oranges.\n    If the number of remaining oranges (`n`) is divisible by 3 then you can eat  2*(n/3) oranges.\n    You can only choose one of the actions per day.\n    Return the minimum number of days to eat `n` oranges.\n    \"\"\"\n", "entry_point": "minimum-number-of-days-to-eat-n-oranges", "cannonical_solution": "", "test": ""}
{"task_id": "palindrome-pairs", "prompt": "def palindromePairs(words: List[str]) -> List[List[int]]:\n    \"\"\"\n    Given a list of unique words, return all the pairs of the distinct indices `(i, j)` in the given list, so that the concatenation of the two words `words[i] + words[j]` is a palindrome.\n    \"\"\"\n", "entry_point": "palindrome-pairs", "cannonical_solution": "", "test": ""}
{"task_id": "strange-printer-ii", "prompt": "def isPrintable(targetGrid: List[List[int]]) -> bool:\n    \"\"\"\n    There is a strange printer with the following two special requirements:\n    On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n    Once the printer has used a color for the above operation, the same color cannot be used again.\n    You are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is the color in the position `(row, col)` of the grid.\n    Return `true` if it is possible to print the matrix `targetGrid`, otherwise, return `false`.\n    \"\"\"\n", "entry_point": "strange-printer-ii", "cannonical_solution": "", "test": ""}
{"task_id": "transform-to-chessboard", "prompt": "def movesToChessboard(board: List[List[int]]) -> int:\n    \"\"\"\n    An N x N `board` contains only `0`s and `1`s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.\n    What is the minimum number of moves to transform the board into a \"chessboard\" - a board where no `0`s and no `1`s are 4-directionally adjacent? If the task is impossible, return -1.\n    \"\"\"\n", "entry_point": "transform-to-chessboard", "cannonical_solution": "", "test": ""}
{"task_id": "count-pairs-with-xor-in-a-range", "prompt": "def countPairs(nums: List[int], low: int, high: int) -> int:\n    \"\"\"\n    Given a (0-indexed) integer array `nums` and two integers `low` and `high`, return the number of nice pairs.\n    A nice pair is a pair `(i, j)` where `0 <= i < j < nums.length` and `low <= (nums[i] XOR nums[j]) <= high`.\n    \"\"\"\n", "entry_point": "count-pairs-with-xor-in-a-range", "cannonical_solution": "", "test": ""}
{"task_id": "cracking-the-safe", "prompt": "def crackSafe(n: int, k: int) -> str:\n    \"\"\"\n    There is a box protected by a password. The password is a sequence of `n` digits where each digit can be one of the first `k` digits `0, 1, ..., k-1`.\n    While entering a password, the last `n` digits entered will automatically be matched against the correct password.\n    For example, assuming the correct password is `\"345\"`, if you type `\"012345\"`, the box will open because the correct password matches the suffix of the entered password.\n    Return any password of minimum length that is guaranteed to open the box at some point of entering it.\n    \"\"\"\n", "entry_point": "cracking-the-safe", "cannonical_solution": "", "test": ""}
{"task_id": "reverse-pairs", "prompt": "def reversePairs(nums: List[int]) -> int:\n    \"\"\"\n    Given an array `nums`, we call `(i, j)` an important reverse pair if `i < j` and `nums[i] > 2*nums[j]`.\n    You need to return the number of important reverse pairs in the given array.\n    \"\"\"\n", "entry_point": "reverse-pairs", "cannonical_solution": "", "test": ""}
{"task_id": "parsing-a-boolean-expression", "prompt": "def parseBoolExpr(expression: str) -> bool:\n    \"\"\"\n    Return the result of evaluating a given boolean `expression`, represented as a string.\n    An expression can either be:\n    `\"t\"`, evaluating to `True`;\n    `\"f\"`, evaluating to `False`;\n    `\"!(expr)\"`, evaluating to the logical NOT of the inner expression `expr`;\n    `\"&(expr1,expr2,...)\"`, evaluating to the logical AND of 2 or more inner expressions `expr1, expr2, ...`;\n    `\"|(expr1,expr2,...)\"`, evaluating to the logical OR of 2 or more inner expressions `expr1, expr2, ...`\n    \"\"\"\n", "entry_point": "parsing-a-boolean-expression", "cannonical_solution": "", "test": ""}
{"task_id": "bricks-falling-when-hit", "prompt": "def hitBricks(grid: List[List[int]], hits: List[List[int]]) -> List[int]:\n    \"\"\"\n    You are given an `m x n` binary `grid`, where each `1` represents a brick and `0` represents an empty space. A brick is stable if:\n    It is directly connected to the top of the grid, or\n    At least one other brick in its four adjacent cells is stable.\n    You are also given an array `hits`, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location `hits[i] = (rowi, coli)`. The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the `grid` (i.e., it does not land on other stable bricks).\n    Return an array `result`, where each `result[i]` is the number of bricks that will fall after the `ith` erasure is applied.\n    Note that an erasure may refer to a location with no brick, and if it does, no bricks drop.\n    \"\"\"\n", "entry_point": "bricks-falling-when-hit", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-ways-to-reorder-array-to-get-same-bst", "prompt": "def numOfWays(nums: List[int]) -> int:\n    \"\"\"\n    Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`.\n    For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST.\n    Return the number of ways to reorder `nums` such that the BST formed is identical to the original BST formed from `nums`.\n    Since the answer may be very large, return it modulo `10^9 + 7`.\n    \"\"\"\n", "entry_point": "number-of-ways-to-reorder-array-to-get-same-bst", "cannonical_solution": "", "test": ""}
{"task_id": "restore-the-array", "prompt": "def numberOfArrays(s: str, k: int) -> int:\n    \"\"\"\n    A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits and all we know is that all integers in the array were in the range `[1, k]` and there are no leading zeros in the array.\n    Given the string `s` and the integer `k`. There can be multiple ways to restore the array.\n    Return the number of possible array that can be printed as a string `s` using the mentioned program.\n    The number of ways could be very large so return it modulo `10^9 + 7`\n    \"\"\"\n", "entry_point": "restore-the-array", "cannonical_solution": "", "test": ""}
{"task_id": "word-search-ii", "prompt": "def findWords(board: List[List[str]], words: List[str]) -> List[str]:\n    \"\"\"\n    Given an `m x n` `board` of characters and a list of strings `words`, return all words on the board.\n    Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n    \"\"\"\n", "entry_point": "word-search-ii", "cannonical_solution": "", "test": ""}
{"task_id": "check-if-string-is-transformable-with-substring-sort-operations", "prompt": "def isTransformable(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings `s` and `t`, you want to transform string `s` into string `t` using the following operation any number of times:\n    Choose a non-empty substring in `s` and sort it in-place so the characters are in ascending order.\n    For example, applying the operation on the underlined substring in `\"14234\"` results in `\"12344\"`.\n    Return `true` if it is possible to transform string `s` into string `t`. Otherwise, return `false`.\n    A substring is a contiguous sequence of characters within a string.\n    \"\"\"\n", "entry_point": "check-if-string-is-transformable-with-substring-sort-operations", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "prompt": "def minInteger(num: str, k: int) -> str:\n    \"\"\"\n    Given a string `num` representing the digits of a very large integer and an integer `k`.\n    You are allowed to swap any two adjacent digits of the integer at most `k` times.\n    Return the minimum integer you can obtain also as a string.\n    \"\"\"\n", "entry_point": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits", "cannonical_solution": "", "test": ""}
{"task_id": "reaching-points", "prompt": "def reachingPoints(sx: int, sy: int, tx: int, ty: int) -> bool:\n    \"\"\"\n    A move consists of taking a point `(x, y)` and transforming it to either `(x, x+y)` or `(x+y, y)`.\n    Given a starting point `(sx, sy)` and a target point `(tx, ty)`, return `True` if and only if a sequence of moves exists to transform the point `(sx, sy)` to `(tx, ty)`. Otherwise, return `False`.\n    \"\"\"\n", "entry_point": "reaching-points", "cannonical_solution": "", "test": ""}
{"task_id": "sliding-window-maximum", "prompt": "def maxSlidingWindow(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n    Return the max sliding window.\n    \"\"\"\n", "entry_point": "sliding-window-maximum", "cannonical_solution": "", "test": ""}
{"task_id": "smallest-rotation-with-highest-score", "prompt": "def bestRotation(nums: List[int]) -> int:\n    \"\"\"\n    Given an array `A`, we may rotate it by a non-negative integer `K` so that the array becomes `A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]`.  Afterward, any entries that are less than or equal to their index are worth 1 point.\n    For example, if we have `[2, 4, 1, 3, 0]`, and we rotate by `K = 2`, it becomes `[1, 3, 0, 2, 4]`.  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].\n    Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.\n    \"\"\"\n", "entry_point": "smallest-rotation-with-highest-score", "cannonical_solution": "", "test": ""}
{"task_id": "split-array-with-same-average", "prompt": "def splitArraySameAverage(nums: List[int]) -> bool:\n    \"\"\"\n    You are given an integer array `nums`.\n    You should move each element of `nums` into one of the two arrays `A` and `B` such that `A` and `B` are non-empty, and `average(A) == average(B)`.\n    Return `true` if it is possible to achieve that and `false` otherwise.\n    Note that for an array `arr`, `average(arr)` is the sum of all the elements of `arr` over the length of `arr`.\n    \"\"\"\n", "entry_point": "split-array-with-same-average", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-atoms", "prompt": "def countOfAtoms(formula: str) -> str:\n    \"\"\"\n    Given a chemical `formula` (given as a string), return the count of each atom.\n    The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n    One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.\n    Two formulas concatenated together to produce another formula. For example, H2O2He3Mg4 is also a formula.\n    A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.\n    Given a `formula`, return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\n    \"\"\"\n", "entry_point": "number-of-atoms", "cannonical_solution": "", "test": ""}
{"task_id": "last-substring-in-lexicographical-order", "prompt": "def lastSubstring(s: str) -> str:\n    \"\"\"\n    Given a string `s`, return the last substring of `s` in lexicographical order.\n    \"\"\"\n", "entry_point": "last-substring-in-lexicographical-order", "cannonical_solution": "", "test": ""}
{"task_id": "sort-items-by-groups-respecting-dependencies", "prompt": "def sortItems(n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n    \"\"\"\n    There are `n` items each belonging to zero or one of `m` groups where `group[i]` is the group that the `i`-th item belongs to and it's equal to `-1` if the `i`-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.\n    Return a sorted list of the items such that:\n    The items that belong to the same group are next to each other in the sorted list.\n    There are some relations between these items where `beforeItems[i]` is a list containing all the items that should come before the `i`-th item in the sorted array (to the left of the `i`-th item).\n    Return any solution if there is more than one solution and return an empty list if there is no solution.\n    \"\"\"\n", "entry_point": "sort-items-by-groups-respecting-dependencies", "cannonical_solution": "", "test": ""}
{"task_id": "trapping-rain-water-ii", "prompt": "def trapRainWater(heightMap: List[List[int]]) -> int:\n    \"\"\"\n    Given an `m x n` matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\n    \"\"\"\n", "entry_point": "trapping-rain-water-ii", "cannonical_solution": "", "test": ""}
{"task_id": "parse-lisp-expression", "prompt": "def evaluate(expression: str) -> int:\n    \"\"\"\n    You are given a string `expression` representing a Lisp-like expression to return the integer value of.\n    The syntax for these expressions is given as follows.\n    An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.\n    (An integer could be positive or negative.)\n    A let-expression takes the form `(let v1 e1 v2 e2 ... vn en expr)`, where `let` is always the string `\"let\"`, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable `v1` is assigned the value of the expression `e1`, the second variable `v2` is assigned the value of the expression `e2`, and so on sequentially; and then the value of this let-expression is the value of the expression `expr`.\n    An add-expression takes the form `(add e1 e2)` where `add` is always the string `\"add\"`, there are always two expressions `e1, e2`, and this expression evaluates to the addition of the evaluation of `e1` and the evaluation of `e2`.\n    A mult-expression takes the form `(mult e1 e2)` where `mult` is always the string `\"mult\"`, there are always two expressions `e1, e2`, and this expression evaluates to the multiplication of the evaluation of `e1` and the evaluation of `e2`.\n    For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names.\n    Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.\n    \"\"\"\n", "entry_point": "parse-lisp-expression", "cannonical_solution": "", "test": ""}
{"task_id": "bus-routes", "prompt": "def numBusesToDestination(routes: List[List[int]], source: int, target: int) -> int:\n    \"\"\"\n    You are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `ith` bus repeats forever.\n    For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.\n    You will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.\n    Return the least number of buses you must take to travel from `source` to `target`. Return `-1` if it is not possible.\n    \"\"\"\n", "entry_point": "bus-routes", "cannonical_solution": "", "test": ""}
{"task_id": "poor-pigs", "prompt": "def poorPigs(buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n    \"\"\"\n    There are `buckets` buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n    You can feed the pigs according to these steps:\n    Choose some live pigs to feed.\n    For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.\n    Wait for `minutesToDie` minutes. You may not feed any other pigs during this time.\n    After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n    Repeat this process until you run out of time.\n    Given `buckets`, `minutesToDie`, and `minutesToTest`, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n    \"\"\"\n", "entry_point": "poor-pigs", "cannonical_solution": "", "test": ""}
{"task_id": "sliding-puzzle", "prompt": "def slidingPuzzle(board: List[List[int]]) -> int:\n    \"\"\"\n    On a 2x3 `board`, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.\n    A move consists of choosing `0` and a 4-directionally adjacent number and swapping it.\n    The state of the board is solved if and only if the `board` is `[[1,2,3],[4,5,0]].`\n    Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\n    \"\"\"\n", "entry_point": "sliding-puzzle", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-number-of-k-consecutive-bit-flips", "prompt": "def minKBitFlips(nums: List[int], k: int) -> int:\n    \"\"\"\n    In an array `A` containing only 0s and 1s, a `K`-bit flip consists of choosing a (contiguous) subarray of length `K` and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\n    Return the minimum number of `K`-bit flips required so that there is no 0 in the array.  If it is not possible, return `-1`.\n    \"\"\"\n", "entry_point": "minimum-number-of-k-consecutive-bit-flips", "cannonical_solution": "", "test": ""}
{"task_id": "form-largest-integer-with-digits-that-add-up-to-target", "prompt": "def largestNumber(cost: List[int], target: int) -> str:\n    \"\"\"\n    Given an array of integers `cost` and an integer `target`. Return the maximum integer you can paint under the following rules:\n    The cost of painting a digit (i+1) is given by `cost[i]` (0 indexed).\n    The total cost used must be equal to `target`.\n    Integer does not have digits 0.\n    Since the answer may be too large, return it as string.\n    If there is no way to paint any integer given the condition, return \"0\".\n    \"\"\"\n", "entry_point": "form-largest-integer-with-digits-that-add-up-to-target", "cannonical_solution": "", "test": ""}
{"task_id": "sum-of-subsequence-widths", "prompt": "def sumSubseqWidths(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers `A`, consider all non-empty subsequences of `A`.\n    For any sequence S, let the width of S be the difference between the maximum and minimum element of S.\n    Return the sum of the widths of all subsequences of A.\n    As the answer may be very large, return the answer modulo 10^9 + 7.\n    \"\"\"\n", "entry_point": "sum-of-subsequence-widths", "cannonical_solution": "", "test": ""}
{"task_id": "super-egg-drop", "prompt": "def superEggDrop(k: int, n: int) -> int:\n    \"\"\"\n    You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n    You know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor higher than `f` will break, and any egg dropped at or below floor `f` will not break.\n    Each move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.\n    Return the minimum number of moves that you need to determine with certainty what the value of `f` is.\n    \"\"\"\n", "entry_point": "super-egg-drop", "cannonical_solution": "", "test": ""}
{"task_id": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons", "prompt": "def numOfArrays(n: int, m: int, k: int) -> int:\n    \"\"\"\n    Given three integers `n`, `m` and `k`. Consider the following algorithm to find the maximum element of an array of positive integers:\n    You should build the array arr which has the following properties:\n    `arr` has exactly `n` integers.\n    `1 <= arr[i] <= m` where `(0 <= i < n)`.\n    After applying the mentioned algorithm to `arr`, the value `search_cost` is equal to `k`.\n    Return the number of ways to build the array `arr` under the mentioned conditions. As the answer may grow large, the answer must be computed modulo `10^9 + 7`.\n    \"\"\"\n", "entry_point": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-ways-of-cutting-a-pizza", "prompt": "def ways(pizza: List[str], k: int) -> int:\n    \"\"\"\n    Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n    For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n    Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.\n    \"\"\"\n", "entry_point": "number-of-ways-of-cutting-a-pizza", "cannonical_solution": "", "test": ""}
{"task_id": "k-th-smallest-in-lexicographical-order", "prompt": "def findKthNumber(n: int, k: int) -> int:\n    \"\"\"\n    Given integers `n` and `k`, find the lexicographically k-th smallest integer in the range from `1` to `n`.\n    Note: 1 \u2264 k \u2264 n \u2264 109.\n    \"\"\"\n", "entry_point": "k-th-smallest-in-lexicographical-order", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-initial-energy-to-finish-tasks", "prompt": "def minimumEffort(tasks: List[List[int]]) -> int:\n    \"\"\"\n    You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n    `actuali` is the actual amount of energy you spend to finish the `ith` task.\n    `minimumi` is the minimum amount of energy you require to begin the `ith` task.\n    For example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n    You can finish the tasks in any order you like.\n    Return the minimum initial amount of energy you will need to finish all the tasks.\n    \"\"\"\n", "entry_point": "minimum-initial-energy-to-finish-tasks", "cannonical_solution": "", "test": ""}
{"task_id": "text-justification", "prompt": "def fullJustify(words: List[str], maxWidth: int) -> List[str]:\n    \"\"\"\n    Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n    You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly maxWidth characters.\n    Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n    For the last line of text, it should be left justified and no extra space is inserted between words.\n    Note:\n    A word is defined as a character sequence consisting of non-space characters only.\n    Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n    The input array `words` contains at least one word.\n    \"\"\"\n", "entry_point": "text-justification", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-cost-to-hire-k-workers", "prompt": "def mincostToHireWorkers(quality: List[int], wage: List[int], k: int) -> float:\n    \"\"\"\n    There are `N` workers.  The `i`-th worker has a `quality[i]` and a minimum wage expectation `wage[i]`.\n    Now we want to hire exactly `K` workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:\n    Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n    Every worker in the paid group must be paid at least their minimum wage expectation.\n    Return the least amount of money needed to form a paid group satisfying the above conditions.\n    \"\"\"\n", "entry_point": "minimum-cost-to-hire-k-workers", "cannonical_solution": "", "test": ""}
{"task_id": "decode-ways-ii", "prompt": "def numDecodings(s: str) -> int:\n    \"\"\"\n    A message containing letters from `A-Z` can be encoded into numbers using the following mapping:\n    'A' -> \"1\"\n    'B' -> \"2\"\n    ...\n    'Z' -> \"26\"\n    To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106\"` can be mapped into:\n    `\"AAJF\"` with the grouping `(1 1 10 6)`\n    `\"KJF\"` with the grouping `(11 10 6)`\n    Note that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n    In addition to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `\"1*\"` may represent any of the encoded messages `\"11\"`, `\"12\"`, `\"13\"`, `\"14\"`, `\"15\"`, `\"16\"`, `\"17\"`, `\"18\"`, or `\"19\"`. Decoding `\"1*\"` is equivalent to decoding any of the encoded messages it can represent.\n    Given a string `s` containing digits and the `'*'` character, return the number of ways to decode it.\n    Since the answer may be very large, return it modulo `109 + 7`.\n    \"\"\"\n", "entry_point": "decode-ways-ii", "cannonical_solution": "", "test": ""}
{"task_id": "create-maximum-number", "prompt": "def maxNumber(nums1: List[int], nums2: List[int], k: int) -> List[int]:\n    \"\"\"\n    You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`.\n    Create the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n    Return an array of the `k` digits representing the answer.\n    \"\"\"\n", "entry_point": "create-maximum-number", "cannonical_solution": "", "test": ""}
{"task_id": "consecutive-numbers-sum", "prompt": "def consecutiveNumbersSum(n: int) -> int:\n    \"\"\"\n    Given a positive integer `N`, how many ways can we write it as a sum of consecutive positive integers?\n    \"\"\"\n", "entry_point": "consecutive-numbers-sum", "cannonical_solution": "", "test": ""}
{"task_id": "count-the-repetitions", "prompt": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    \"\"\"\n    Define `S = [s,n]` as the string S which consists of n connected strings s. For example, `[\"abc\", 3]` =\"abcabcabc\".\n    On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, \u201cabc\u201d  can be obtained from \u201cabdbec\u201d based on our definition, but it can not be obtained from \u201cacbbe\u201d.\n    You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 \u2264 n1 \u2264 106 and 1 \u2264 n2 \u2264 106. Now consider the strings S1 and S2, where `S1=[s1,n1]` and `S2=[s2,n2]`. Find the maximum integer M such that `[S2,M]` can be obtained from `S1`.\n    \"\"\"\n", "entry_point": "count-the-repetitions", "cannonical_solution": "", "test": ""}
{"task_id": "count-all-valid-pickup-and-delivery-options", "prompt": "def countOrders(n: int) -> int:\n    \"\"\"\n    Given `n` orders, each order consist in pickup and delivery services.\n    Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i).\n    Since the answer may be too large, return it modulo 10^9 + 7.\n    \"\"\"\n", "entry_point": "count-all-valid-pickup-and-delivery-options", "cannonical_solution": "", "test": ""}
{"task_id": "max-points-on-a-line", "prompt": "def maxPoints(points: List[List[int]]) -> int:\n    \"\"\"\n    Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n    \"\"\"\n", "entry_point": "max-points-on-a-line", "cannonical_solution": "", "test": ""}
{"task_id": "max-dot-product-of-two-subsequences", "prompt": "def maxDotProduct(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    Given two arrays `nums1` and `nums2`.\n    Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.\n    A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not).\n    \"\"\"\n", "entry_point": "max-dot-product-of-two-subsequences", "cannonical_solution": "", "test": ""}
{"task_id": "maximize-palindrome-length-from-subsequences", "prompt": "def longestPalindrome(word1: str, word2: str) -> int:\n    \"\"\"\n    You are given two strings, `word1` and `word2`. You want to construct a string in the following manner:\n    Choose some non-empty subsequence `subsequence1` from `word1`.\n    Choose some non-empty subsequence `subsequence2` from `word2`.\n    Concatenate the subsequences: `subsequence1 + subsequence2`, to make the string.\n    Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return `0`.\n    A subsequence of a string `s` is a string that can be made by deleting some (possibly none) characters from `s` without changing the order of the remaining characters.\n    A palindrome is a string that reads the same forward as well as backward.\n    \"\"\"\n", "entry_point": "maximize-palindrome-length-from-subsequences", "cannonical_solution": "", "test": ""}
{"task_id": "similar-string-groups", "prompt": "def numSimilarGroups(strs: List[str]) -> int:\n    \"\"\"\n    Two strings `X` and `Y` are similar if we can swap two letters (in different positions) of `X`, so that it equals `Y`. Also two strings `X` and `Y` are similar if they are equal.\n    For example, `\"tars\"` and `\"rats\"` are similar (swapping at positions `0` and `2`), and `\"rats\"` and `\"arts\"` are similar, but `\"star\"` is not similar to `\"tars\"`, `\"rats\"`, or `\"arts\"`.\n    Together, these form two connected groups by similarity: `{\"tars\", \"rats\", \"arts\"}` and `{\"star\"}`.  Notice that `\"tars\"` and `\"arts\"` are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\n    We are given a list `strs` of strings where every string in `strs` is an anagram of every other string in `strs`. How many groups are there?\n    \"\"\"\n", "entry_point": "similar-string-groups", "cannonical_solution": "", "test": ""}
{"task_id": "integer-to-english-words", "prompt": "def numberToWords(num: int) -> str:\n    \"\"\"\n    Convert a non-negative integer `num` to its English words representation.\n    \"\"\"\n", "entry_point": "integer-to-english-words", "cannonical_solution": "", "test": ""}
{"task_id": "numbers-at-most-n-given-digit-set", "prompt": "def atMostNGivenDigitSet(digits: List[str], n: int) -> int:\n    \"\"\"\n    Given an array of `digits` which is sorted in non-decreasing order. You can write numbers using each `digits[i]` as many times as we want. For example, if `digits = ['1','3','5']`, we may write numbers such as `'13'`, `'551'`, and `'1351315'`.\n    Return the number of positive integers that can be generated that are less than or equal to a given integer `n`.\n    \"\"\"\n", "entry_point": "numbers-at-most-n-given-digit-set", "cannonical_solution": "", "test": ""}
{"task_id": "orderly-queue", "prompt": "def orderlyQueue(s: str, k: int) -> str:\n    \"\"\"\n    A string `S` of lowercase letters is given.  Then, we may make any number of moves.\n    In each move, we choose one of the first `K` letters (starting from the left), remove it, and place it at the end of the string.\n    Return the lexicographically smallest string we could have after any number of moves.\n    \"\"\"\n", "entry_point": "orderly-queue", "cannonical_solution": "", "test": ""}
{"task_id": "find-a-value-of-a-mysterious-function-closest-to-target", "prompt": "def closestToTarget(arr: List[int], target: int) -> int:\n    \"\"\"\n    Winston was given the above mysterious function `func`. He has an integer array `arr` and an integer `target` and he wants to find the values `l` and `r` that make the value `|func(arr, l, r) - target|` minimum possible.\n    Return the minimum possible value of `|func(arr, l, r) - target|`.\n    Notice that `func` should be called with the values `l` and `r` where `0 <= l, r < arr.length`.\n    \"\"\"\n", "entry_point": "find-a-value-of-a-mysterious-function-closest-to-target", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-number-of-darts-inside-of-a-circular-dartboard", "prompt": "def numPoints(darts: List[List[int]], r: int) -> int:\n    \"\"\"\n    You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of `points` on a 2D plane.\n    Return the maximum number of points that are within or lie on any circular dartboard of radius `r`.\n    \"\"\"\n", "entry_point": "maximum-number-of-darts-inside-of-a-circular-dartboard", "cannonical_solution": "", "test": ""}
{"task_id": "k-similar-strings", "prompt": "def kSimilarity(s1: str, s2: str) -> int:\n    \"\"\"\n    Strings `s1` and `s2` are `k`-similar (for some non-negative integer `k`) if we can swap the positions of two letters in `s1` exactly `k` times so that the resulting string equals `s2`.\n    Given two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and `s2` are `k`-similar.\n    \"\"\"\n", "entry_point": "k-similar-strings", "cannonical_solution": "", "test": ""}
{"task_id": "max-sum-of-rectangle-no-larger-than-k", "prompt": "def maxSumSubmatrix(matrix: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given an `m x n` matrix `matrix` and an integer `k`, return the max sum of a rectangle in the matrix such that its sum is no larger than `k`.\n    It is guaranteed that there will be a rectangle with a sum no larger than `k`.\n    \"\"\"\n", "entry_point": "max-sum-of-rectangle-no-larger-than-k", "cannonical_solution": "", "test": ""}
{"task_id": "strong-password-checker", "prompt": "def strongPasswordChecker(password: str) -> int:\n    \"\"\"\n    A password is considered strong if the below conditions are all met:\n    It has at least `6` characters and at most `20` characters.\n    It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\n    It does not contain three repeating characters in a row (i.e., `\"...aaa...\"` is weak, but `\"...aa...a...\"` is strong, assuming other conditions are met).\n    Given a string `password`, return the minimum number of steps required to make `password` strong. if `password` is already strong, return `0`.\n    In one step, you can:\n    Insert one character to `password`,\n    Delete one character from `password`, or\n    Replace one character of `password` with another character.\n    \"\"\"\n", "entry_point": "strong-password-checker", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-distance-to-type-a-word-using-two-fingers", "prompt": "def minimumDistance(word: str) -> int:\n    \"\"\"\n    You have a keyboard layout as shown above in the XY plane, where each English uppercase letter is located at some coordinate, for example, the letter A is located at coordinate (0,0), the letter B is located at coordinate (0,1), the letter P is located at coordinate (2,3) and the letter Z is located at coordinate (4,1).\n    Given the string `word`, return the minimum total distance to type such string using only two fingers. The distance between coordinates (x1,y1) and (x2,y2) is |x1 - x2| + |y1 - y2|.\n    Note that the initial positions of your two fingers are considered free so don't count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.\n    \"\"\"\n", "entry_point": "minimum-distance-to-type-a-word-using-two-fingers", "cannonical_solution": "", "test": ""}
{"task_id": "dungeon-game", "prompt": "def calculateMinimumHP(dungeon: List[List[int]]) -> int:\n    \"\"\"\n    The demons had captured the princess and imprisoned her in the bottom-right corner of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through `dungeon` to rescue the princess.\n    The knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\n    Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n    To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n    Return the knight's minimum initial health so that he can rescue the princess.\n    Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n    \"\"\"\n", "entry_point": "dungeon-game", "cannonical_solution": "", "test": ""}
{"task_id": "word-break-ii", "prompt": "def wordBreak(s: str, wordDict: List[str]) -> List[str]:\n    \"\"\"\n    Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.\n    Note that the same word in the dictionary may be reused multiple times in the segmentation.\n    \"\"\"\n", "entry_point": "word-break-ii", "cannonical_solution": "", "test": ""}
{"task_id": "student-attendance-record-ii", "prompt": "def checkRecord(n: int) -> int:\n    \"\"\"\n    An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n    `'A'`: Absent.\n    `'L'`: Late.\n    `'P'`: Present.\n    Any student is eligible for an attendance award if they meet both of the following criteria:\n    The student was absent (`'A'`) for strictly fewer than 2 days total.\n    The student was never late (`'L'`) for 3 or more consecutive days.\n    Given an integer `n`, return the number of possible attendance records of length `n` that make a student eligible for an attendance award. The answer may be very large, so return it modulo `109 + 7`.\n    \"\"\"\n", "entry_point": "student-attendance-record-ii", "cannonical_solution": "", "test": ""}
{"task_id": "contain-virus", "prompt": "def containVirus(isInfected: List[List[int]]) -> int:\n    \"\"\"\n    A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n    The world is modeled as a 2-D array of cells, where `0` represents uninfected cells, and `1` represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\n    Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.\n    Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.\n    Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.\n    \"\"\"\n", "entry_point": "contain-virus", "cannonical_solution": "", "test": ""}
{"task_id": "preimage-size-of-factorial-zeroes-function", "prompt": "def preimageSizeFZF(k: int) -> int:\n    \"\"\"\n    Let `f(x)` be the number of zeroes at the end of `x!`. (Recall that `x! = 1 * 2 * 3 * ... * x`, and by convention, `0! = 1`.)\n    For example, `f(3) = 0` because 3! = 6 has no zeroes at the end, while `f(11) = 2` because 11! = 39916800 has 2 zeroes at the end. Given `K`, find how many non-negative integers `x` have the property that `f(x) = K`.\n    \"\"\"\n", "entry_point": "preimage-size-of-factorial-zeroes-function", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-difficulty-of-a-job-schedule", "prompt": "def minDifficulty(jobDifficulty: List[int], d: int) -> int:\n    \"\"\"\n    You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `i-th` job, you have to finish all the jobs `j` where `0 <= j < i`).\n    You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done in that day.\n    Given an array of integers `jobDifficulty` and an integer `d`. The difficulty of the `i-th` job is `jobDifficulty[i]`.\n    Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.\n    \"\"\"\n", "entry_point": "minimum-difficulty-of-a-job-schedule", "cannonical_solution": "", "test": ""}
{"task_id": "sliding-window-median", "prompt": "def medianSlidingWindow(nums: List[int], k: int) -> List[float]:\n    \"\"\"\n    Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\n    \"\"\"\n", "entry_point": "sliding-window-median", "cannonical_solution": "", "test": ""}
{"task_id": "longest-increasing-path-in-a-matrix", "prompt": "def longestIncreasingPath(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an `m x n` integers `matrix`, return the length of the longest increasing path in `matrix`.\n    From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n    \"\"\"\n", "entry_point": "longest-increasing-path-in-a-matrix", "cannonical_solution": "", "test": ""}
{"task_id": "count-of-range-sum", "prompt": "def countRangeSum(nums: List[int], lower: int, upper: int) -> int:\n    \"\"\"\n    Given an integer array `nums` and two integers `lower` and `upper`, return the number of range sums that lie in `[lower, upper]` inclusive.\n    Range sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.\n    \"\"\"\n", "entry_point": "count-of-range-sum", "cannonical_solution": "", "test": ""}
{"task_id": "maximize-grid-happiness", "prompt": "def getMaxGridHappiness(m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\n    \"\"\"\n    You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.\n    You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\n    The happiness of each person is calculated as follows:\n    Introverts start with `120` happiness and lose `30` happiness for each neighbor (introvert or extrovert).\n    Extroverts start with `40` happiness and gain `20` happiness for each neighbor (introvert or extrovert).\n    Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\n    The grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.\n    \"\"\"\n", "entry_point": "maximize-grid-happiness", "cannonical_solution": "", "test": ""}
{"task_id": "concatenated-words", "prompt": "def findAllConcatenatedWordsInADict(words: List[str]) -> List[str]:\n    \"\"\"\n    Given an array of strings `words` (without duplicates), return all the concatenated words in the given list of `words`.\n    A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\n    \"\"\"\n", "entry_point": "concatenated-words", "cannonical_solution": "", "test": ""}
{"task_id": "numbers-with-repeated-digits", "prompt": "def numDupDigitsAtMostN(n: int) -> int:\n    \"\"\"\n    Given a positive integer `N`, return the number of positive integers less than or equal to `N` that have at least 1 repeated digit.\n    \"\"\"\n", "entry_point": "numbers-with-repeated-digits", "cannonical_solution": "", "test": ""}
{"task_id": "valid-permutations-for-di-sequence", "prompt": "def numPermsDISequence(s: str) -> int:\n    \"\"\"\n    We are given `S`, a length `n` string of characters from the set `{'D', 'I'}`. (These letters stand for \"decreasing\" and \"increasing\".)\n    A valid permutation is a permutation `P[0], P[1], ..., P[n]` of integers `{0, 1, ..., n}`, such that for all `i`:\n    If `S[i] == 'D'`, then `P[i] > P[i+1]`, and;\n    If `S[i] == 'I'`, then `P[i] < P[i+1]`.\n    How many valid permutations are there?  Since the answer may be large, return your answer modulo `10^9 + 7`.\n    \"\"\"\n", "entry_point": "valid-permutations-for-di-sequence", "cannonical_solution": "", "test": ""}
{"task_id": "smallest-range-covering-elements-from-k-lists", "prompt": "def smallestRange(nums: List[List[int]]) -> List[int]:\n    \"\"\"\n    You have `k` lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the `k` lists.\n    We define the range `[a, b]` is smaller than range `[c, d]` if `b - a < d - c` or `a < c` if `b - a == d - c`.\n    \"\"\"\n", "entry_point": "smallest-range-covering-elements-from-k-lists", "cannonical_solution": "", "test": ""}
{"task_id": "find-the-closest-palindrome", "prompt": "def nearestPalindromic(n: str) -> str:\n    \"\"\"\n    Given an integer n, find the closest integer (not including itself), which is a palindrome.\n    The 'closest' is defined as absolute difference minimized between two integers.\n    \"\"\"\n", "entry_point": "find-the-closest-palindrome", "cannonical_solution": "", "test": ""}
{"task_id": "swim-in-rising-water", "prompt": "def swimInWater(grid: List[List[int]]) -> int:\n    \"\"\"\n    On an N x N `grid`, each square `grid[i][j]` represents the elevation at that point `(i,j)`.\n    Now rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n    You start at the top left square `(0, 0)`. What is the least time until you can reach the bottom right square `(N-1, N-1)`?\n    \"\"\"\n", "entry_point": "swim-in-rising-water", "cannonical_solution": "", "test": ""}
{"task_id": "maximal-rectangle", "prompt": "def maximalRectangle(matrix: List[List[str]]) -> int:\n    \"\"\"\n    Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.\n    \"\"\"\n", "entry_point": "maximal-rectangle", "cannonical_solution": "", "test": ""}
{"task_id": "dice-roll-simulation", "prompt": "def dieSimulator(n: int, rollMax: List[int]) -> int:\n    \"\"\"\n    A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (1-indexed) consecutive times.\n    Given an array of integers `rollMax` and an integer `n`, return the number of distinct sequences that can be obtained with exact `n` rolls.\n    Two sequences are considered different if at least one element differs from each other. Since the answer may be too large, return it modulo `10^9 + 7`.\n    \"\"\"\n", "entry_point": "dice-roll-simulation", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-number-of-non-overlapping-substrings", "prompt": "def maxNumOfSubstrings(s: str) -> List[str]:\n    \"\"\"\n    Given a string `s` of lowercase letters, you need to find the maximum number of non-empty substrings of `s` that meet the following conditions:\n    The substrings do not overlap, that is for any two substrings `s[i..j]` and `s[k..l]`, either `j < k` or `i > l` is true.\n    A substring that contains a certain character `c` must also contain all occurrences of `c`.\n    Find the maximum number of substrings that meet the above conditions. If there are multiple solutions with the same number of substrings, return the one with minimum total length. It can be shown that there exists a unique solution of minimum total length.\n    Notice that you can return the substrings in any order.\n    \"\"\"\n", "entry_point": "maximum-number-of-non-overlapping-substrings", "cannonical_solution": "", "test": ""}
{"task_id": "erect-the-fence", "prompt": "def outerTrees(trees: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.\n    \"\"\"\n", "entry_point": "erect-the-fence", "cannonical_solution": "", "test": ""}
{"task_id": "best-position-for-a-service-centre", "prompt": "def getMinDistSum(positions: List[List[int]]) -> float:\n    \"\"\"\n    A delivery company wants to build a new service centre in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new centre in a position such that the sum of the euclidean distances to all customers is minimum.\n    Given an array `positions` where `positions[i] = [xi, yi]` is the position of the `ith` customer on the map, return the minimum sum of the euclidean distances to all customers.\n    In other words, you need to choose the position of the service centre `[xcentre, ycentre]` such that the following formula is minimized:\n    Answers within `10^-5` of the actual value will be accepted.\n    \"\"\"\n", "entry_point": "best-position-for-a-service-centre", "cannonical_solution": "", "test": ""}
{"task_id": "the-skyline-problem", "prompt": "def getSkyline(buildings: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\n    The geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:\n    `lefti` is the x coordinate of the left edge of the `ith` building.\n    `righti` is the x coordinate of the right edge of the `ith` building.\n    `heighti` is the height of the `ith` building.\n    You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.\n    The skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n    Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`\n    \"\"\"\n", "entry_point": "the-skyline-problem", "cannonical_solution": "", "test": ""}
{"task_id": "allocate-mailboxes", "prompt": "def minDistance(houses: List[int], k: int) -> int:\n    \"\"\"\n    Given the array `houses` and an integer `k`. where `houses[i]` is the location of the ith house along a street, your task is to allocate `k` mailboxes in the street.\n    Return the minimum total distance between each house and its nearest mailbox.\n    The answer is guaranteed to fit in a 32-bit signed integer.\n    \"\"\"\n", "entry_point": "allocate-mailboxes", "cannonical_solution": "", "test": ""}
{"task_id": "count-vowels-permutation", "prompt": "def countVowelPermutation(n: int) -> int:\n    \"\"\"\n    Given an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:\n    Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)\n    Each vowel `'a'` may only be followed by an `'e'`.\n    Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n    Each vowel `'i'` may not be followed by another `'i'`.\n    Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n    Each vowel `'u'` may only be followed by an `'a'.`\n    Since the answer may be too large, return it modulo `10^9 + 7.`\n    \"\"\"\n", "entry_point": "count-vowels-permutation", "cannonical_solution": "", "test": ""}
{"task_id": "largest-rectangle-in-histogram", "prompt": "def largestRectangleArea(heights: List[int]) -> int:\n    \"\"\"\n    Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return the area of the largest rectangle in the histogram.\n    \"\"\"\n", "entry_point": "largest-rectangle-in-histogram", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix", "prompt": "def minFlips(mat: List[List[int]]) -> int:\n    \"\"\"\n    Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and flip it and all the four neighbours of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighboors if they share one edge.\n    Return the minimum number of steps required to convert `mat` to a zero matrix or -1 if you cannot.\n    Binary matrix is a matrix with all cells equal to 0 or 1 only.\n    Zero matrix is a matrix with all cells equal to 0.\n    \"\"\"\n", "entry_point": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix", "cannonical_solution": "", "test": ""}
{"task_id": "building-boxes", "prompt": "def minimumBoxes(n: int) -> int:\n    \"\"\"\n    You have a cubic storeroom where the width, length, and height of the room are all equal to `n` units. You are asked to place `n` boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:\n    You can place the boxes anywhere on the floor.\n    If box `x` is placed on top of the box `y`, then each side of the four vertical sides of the box `y` must either be adjacent to another box or to a wall.\n    Given an integer `n`, return the minimum possible number of boxes touching the floor.\n    \"\"\"\n", "entry_point": "building-boxes", "cannonical_solution": "", "test": ""}
{"task_id": "split-array-largest-sum", "prompt": "def splitArray(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an array `nums` which consists of non-negative integers and an integer `m`, you can split the array into `m` non-empty continuous subarrays.\n    Write an algorithm to minimize the largest sum among these `m` subarrays.\n    \"\"\"\n", "entry_point": "split-array-largest-sum", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-gap", "prompt": "def maximumGap(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array `nums`, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return `0`.\n    \"\"\"\n", "entry_point": "maximum-gap", "cannonical_solution": "", "test": ""}
{"task_id": "shortest-path-visiting-all-nodes", "prompt": "def shortestPathLength(graph: List[List[int]]) -> int:\n    \"\"\"\n    An undirected, connected graph of N nodes (labeled `0, 1, 2, ..., N-1`) is given as `graph`.\n    `graph.length = N`, and `j != i` is in the list `graph[i]` exactly once, if and only if nodes `i` and `j` are connected.\n    Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n    \"\"\"\n", "entry_point": "shortest-path-visiting-all-nodes", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-score-words-formed-by-letters", "prompt": "def maxScoreWords(words: List[str], letters: List[str], score: List[int]) -> int:\n    \"\"\"\n    Given a list of `words`, list of  single `letters` (might be repeating) and `score` of every character.\n    Return the maximum score of any valid set of words formed by using the given letters (`words[i]` cannot be used two or more times).\n    It is not necessary to use all characters in `letters` and each letter can only be used once. Score of letters `'a'`, `'b'`, `'c'`, ... ,`'z'` is given by `score[0]`, `score[1]`, ... , `score[25]` respectively.\n    \"\"\"\n", "entry_point": "maximum-score-words-formed-by-letters", "cannonical_solution": "", "test": ""}
{"task_id": "cat-and-mouse-ii", "prompt": "def canMouseWin(grid: List[str], catJump: int, mouseJump: int) -> bool:\n    \"\"\"\n    A game is played by a cat and a mouse named Cat and Mouse.\n    The environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.\n    Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).\n    Floors are represented by the character `'.'` and can be walked on.\n    Walls are represented by the character `'#'` and cannot be walked on.\n    Food is represented by the character `'F'` and can be walked on.\n    There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n    Mouse and Cat play according to the following rules:\n    Mouse moves first, then they take turns to move.\n    During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.\n    `catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n    Staying in the same position is allowed.\n    Mouse can jump over Cat.\n    The game can end in 4 ways:\n    If Cat occupies the same position as Mouse, Cat wins.\n    If Cat reaches the food first, Cat wins.\n    If Mouse reaches the food first, Mouse wins.\n    If Mouse cannot get to the food within 1000 turns, Cat wins.\n    Given a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` if Mouse can win the game if both Cat and Mouse play optimally, otherwise return `false`.\n    \"\"\"\n", "entry_point": "cat-and-mouse-ii", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-music-playlists", "prompt": "def numMusicPlaylists(n: int, goal: int, k: int) -> int:\n    \"\"\"\n    Your music player contains `N` different songs and she wants to listen to `L` (not necessarily different) songs during your trip.  You create a playlist so that:\n    Every song is played at least once\n    A song can only be played again only if `K` other songs have been played\n    Return the number of possible playlists.  As the answer can be very large, return it modulo `10^9 + 7`.\n    \"\"\"\n", "entry_point": "number-of-music-playlists", "cannonical_solution": "", "test": ""}
{"task_id": "longest-consecutive-sequence", "prompt": "def longestConsecutive(nums: List[int]) -> int:\n    \"\"\"\n    Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n    \"\"\"\n", "entry_point": "longest-consecutive-sequence", "cannonical_solution": "", "test": ""}
{"task_id": "count-different-palindromic-subsequences", "prompt": "def countPalindromicSubsequences(s: str) -> int:\n    \"\"\"\n    Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo `10^9 + 7`.\n    A subsequence of a string S is obtained by deleting 0 or more characters from S.\n    A sequence is palindromic if it is equal to the sequence reversed.\n    Two sequences `A_1, A_2, ...` and `B_1, B_2, ...` are different if there is some `i` for which `A_i != B_i`.\n    \"\"\"\n", "entry_point": "count-different-palindromic-subsequences", "cannonical_solution": "", "test": ""}
{"task_id": "minimum-moves-to-reach-target-with-rotations", "prompt": "def minimumMoves(grid: List[List[int]]) -> int:\n    \"\"\"\n    In an `n*n` grid, there is a snake that spans 2 cells and starts moving from the top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.\n    In one move the snake can:\n    Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n    Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n    Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.\n    Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.\n    Return the minimum number of moves to reach the target.\n    If there is no way to reach the target, return `-1`.\n    \"\"\"\n", "entry_point": "minimum-moves-to-reach-target-with-rotations", "cannonical_solution": "", "test": ""}
{"task_id": "burst-balloons", "prompt": "def maxCoins(nums: List[int]) -> int:\n    \"\"\"\n    You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n    If you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n    Return the maximum coins you can collect by bursting the balloons wisely.\n    \"\"\"\n", "entry_point": "burst-balloons", "cannonical_solution": "", "test": ""}
{"task_id": "odd-even-jump", "prompt": "def oddEvenJumps(arr: List[int]) -> int:\n    \"\"\"\n    You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.\n    You may jump forward from index `i` to index `j` (with `i < j`) in the following way:\n    During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.\n    During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.\n    It may be the case that for some index `i`, there are no legal jumps.\n    A starting index is good if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).\n    Return the number of good starting indices.\n    \"\"\"\n", "entry_point": "odd-even-jump", "cannonical_solution": "", "test": ""}
{"task_id": "maximum-candies-you-can-get-from-boxes", "prompt": "def maxCandies(status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n    \"\"\"\n    Given `n` boxes, each box is given in the format `[status, candies, keys, containedBoxes]` where:\n    `status[i]`: an integer which is 1 if `box[i]` is open and 0 if `box[i]` is closed.\n    `candies[i]`: an integer representing the number of candies in `box[i]`.\n    `keys[i]`: an array contains the indices of the boxes you can open with the key in `box[i]`.\n    `containedBoxes[i]`: an array contains the indices of the boxes found in `box[i]`.\n    You will start with some boxes given in `initialBoxes` array. You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it.\n    Return the maximum number of candies you can get following the rules above.\n    \"\"\"\n", "entry_point": "maximum-candies-you-can-get-from-boxes", "cannonical_solution": "", "test": ""}
{"task_id": "number-of-valid-words-for-each-puzzle", "prompt": "def findNumOfValidWords(words: List[str], puzzles: List[str]) -> List[int]:\n    \"\"\"\n    With respect to a given `puzzle` string, a `word` is valid if both the following conditions are satisfied:\n    `word` contains the first letter of `puzzle`.\n    For each letter in `word`, that letter is in `puzzle`.\n    For example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\"; while invalid words are \"beefed\" (doesn't include \"a\") and \"based\" (includes \"s\" which isn't in the puzzle).\n    Return an array `answer`, where `answer[i]` is the number of words in the given word list `words` that are valid with respect to the puzzle `puzzles[i]`.\n    \"\"\"\n", "entry_point": "number-of-valid-words-for-each-puzzle", "cannonical_solution": "", "test": ""}
