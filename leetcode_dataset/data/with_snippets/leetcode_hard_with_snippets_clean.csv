,id,title,description,is_premium,difficulty,solution_link,acceptance_rate,frequency,url,discuss_count,accepted,submissions,companies,related_topics,likes,dislikes,rating,asked_by_faang,similar_questions,c++_code_snippet,java_code_snippet,python_code_snippet,python3_code_snippet,c_code_snippet,c#_code_snippet,javascript_code_snippet,ruby_code_snippet,swift_code_snippet,go_code_snippet,scala_code_snippet,kotlin_code_snippet,rust_code_snippet,php_code_snippet,typescript_code_snippet,racket_code_snippet,erlang_code_snippet,elixir_code_snippet,dart_code_snippet,mysql_code_snippet,ms sql server_code_snippet,oracle_code_snippet,title_slug
0,4,Median of Two Sorted Arrays,"Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.",0,Hard,/articles/median-of-two-sorted-arrays,31.4,86.2,https://leetcode.com/problems/median-of-two-sorted-arrays,999,904.7K,2.9M,"Amazon,Goldman Sachs,Facebook,Microsoft,Apple,Adobe,Google,Bloomberg,Zillow,Uber,Flipkart,Paypal","Array,Binary Search,Divide and Conquer",9665,1486,87,1,,"class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        
    }
};","class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        
    }
}","class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """"""
        ","class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        ","double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){

}","public class Solution {
    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Float}
def find_median_sorted_arrays(nums1, nums2)
    
end","class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
        
    }
}","func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    
}","object Solution {
    def findMedianSortedArrays(nums1: Array[Int], nums2: Array[Int]): Double = {
        
    }
}","class Solution {
    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {
        
    }
}","impl Solution {
    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Float
     */
    function findMedianSortedArrays($nums1, $nums2) {
        
    }
}","function findMedianSortedArrays(nums1: number[], nums2: number[]): number {

};","(define/contract (find-median-sorted-arrays nums1 nums2)
  (-> (listof exact-integer?) (listof exact-integer?) flonum?)

  )","-spec find_median_sorted_arrays(Nums1 :: [integer()], Nums2 :: [integer()]) -> float().
find_median_sorted_arrays(Nums1, Nums2) ->
  .","defmodule Solution do
  @spec find_median_sorted_arrays(nums1 :: [integer], nums2 :: [integer]) :: float
  def find_median_sorted_arrays(nums1, nums2) do

  end
end","class Solution {
  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {

  }
}",,,,median-of-two-sorted-arrays
1,10,Regular Expression Matching,"Given an input string (`s`) and a pattern (`p`), implement regular expression matching with support for `'.'` and `'*'` where:` `
`'.'` Matches any single character.​​​​
`'*'` Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).",0,Hard,/articles/regular-expression-matching,27.4,75.0,https://leetcode.com/problems/regular-expression-matching,999,526.6K,1.9M,"Facebook,Amazon,Microsoft,Google,Adobe,Coursera,Apple","String,Dynamic Programming,Backtracking",5583,841,87,1,"[Wildcard Matching, /problems/wildcard-matching/, Hard]","class Solution {
public:
    bool isMatch(string s, string p) {
        
    }
};","class Solution {
    public boolean isMatch(String s, String p) {
        
    }
}","class Solution(object):
    def isMatch(self, s, p):
        """"""
        :type s: str
        :type p: str
        :rtype: bool
        """"""
        ","class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        ","bool isMatch(char * s, char * p){

}","public class Solution {
    public bool IsMatch(string s, string p) {
        
    }
}","/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    
};","# @param {String} s
# @param {String} p
# @return {Boolean}
def is_match(s, p)
    
end","class Solution {
    func isMatch(_ s: String, _ p: String) -> Bool {
        
    }
}","func isMatch(s string, p string) bool {
    
}","object Solution {
    def isMatch(s: String, p: String): Boolean = {
        
    }
}","class Solution {
    fun isMatch(s: String, p: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_match(s: String, p: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $p
     * @return Boolean
     */
    function isMatch($s, $p) {
        
    }
}","function isMatch(s: string, p: string): boolean {

};","(define/contract (is-match s p)
  (-> string? string? boolean?)

  )","-spec is_match(S :: unicode:unicode_binary(), P :: unicode:unicode_binary()) -> boolean().
is_match(S, P) ->
  .","defmodule Solution do
  @spec is_match(s :: String.t, p :: String.t) :: boolean
  def is_match(s, p) do

  end
end","class Solution {
  bool isMatch(String s, String p) {

  }
}",,,,regular-expression-matching
4,30,Substring with Concatenation of All Words,"You are given a string `s` and an array of strings `words` of the same length. Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once, in any order, and without any intervening characters.
You can return the answer in any order.",0,Hard,,26.4,31.0,https://leetcode.com/problems/substring-with-concatenation-of-all-words,732,203K,770K,"Amazon,Adobe","Hash Table,Two Pointers,String",1209,1455,45,1,"[Minimum Window Substring, /problems/minimum-window-substring/, Hard]","class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        
    }
};","class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        
    }
}","class Solution(object):
    def findSubstring(self, s, words):
        """"""
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        """"""
        ","class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findSubstring(char * s, char ** words, int wordsSize, int* returnSize){

}","public class Solution {
    public IList<int> FindSubstring(string s, string[] words) {
        
    }
}","/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {
    
};","# @param {String} s
# @param {String[]} words
# @return {Integer[]}
def find_substring(s, words)
    
end","class Solution {
    func findSubstring(_ s: String, _ words: [String]) -> [Int] {
        
    }
}","func findSubstring(s string, words []string) []int {
    
}","object Solution {
    def findSubstring(s: String, words: Array[String]): List[Int] = {
        
    }
}","class Solution {
    fun findSubstring(s: String, words: Array<String>): List<Int> {
        
    }
}","impl Solution {
    pub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String[] $words
     * @return Integer[]
     */
    function findSubstring($s, $words) {
        
    }
}","function findSubstring(s: string, words: string[]): number[] {

};","(define/contract (find-substring s words)
  (-> string? (listof string?) (listof exact-integer?))

  )","-spec find_substring(S :: unicode:unicode_binary(), Words :: [unicode:unicode_binary()]) -> [integer()].
find_substring(S, Words) ->
  .","defmodule Solution do
  @spec find_substring(s :: String.t, words :: [String.t]) :: [integer]
  def find_substring(s, words) do

  end
end","class Solution {
  List<int> findSubstring(String s, List<String> words) {

  }
}",,,,substring-with-concatenation-of-all-words
5,32,Longest Valid Parentheses,"Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.",0,Hard,/articles/longest-valid-parentheses,29.9,24.5,https://leetcode.com/problems/longest-valid-parentheses,999,366.3K,1.2M,"Amazon,Facebook,Apple,ByteDance","String,Dynamic Programming",5015,182,96,1,"[Valid Parentheses, /problems/valid-parentheses/, Easy]","class Solution {
public:
    int longestValidParentheses(string s) {
        
    }
};","class Solution {
    public int longestValidParentheses(String s) {
        
    }
}","class Solution(object):
    def longestValidParentheses(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def longestValidParentheses(self, s: str) -> int:
        ","int longestValidParentheses(char * s){

}","public class Solution {
    public int LongestValidParentheses(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
    
};","# @param {String} s
# @return {Integer}
def longest_valid_parentheses(s)
    
end","class Solution {
    func longestValidParentheses(_ s: String) -> Int {
        
    }
}","func longestValidParentheses(s string) int {
    
}","object Solution {
    def longestValidParentheses(s: String): Int = {
        
    }
}","class Solution {
    fun longestValidParentheses(s: String): Int {
        
    }
}","impl Solution {
    pub fn longest_valid_parentheses(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function longestValidParentheses($s) {
        
    }
}","function longestValidParentheses(s: string): number {

};","(define/contract (longest-valid-parentheses s)
  (-> string? exact-integer?)

  )","-spec longest_valid_parentheses(S :: unicode:unicode_binary()) -> integer().
longest_valid_parentheses(S) ->
  .","defmodule Solution do
  @spec longest_valid_parentheses(s :: String.t) :: integer
  def longest_valid_parentheses(s) do

  end
end","class Solution {
  int longestValidParentheses(String s) {

  }
}",,,,longest-valid-parentheses
7,41,First Missing Positive,"Given an unsorted integer array `nums`, find the smallest missing positive integer.",0,Hard,/articles/first-missing-positive,33.9,77.3,https://leetcode.com/problems/first-missing-positive,999,466.2K,1.4M,"Microsoft,Amazon,Facebook,Google,Oracle,Adobe,Bloomberg,Wish,Uber,Apple,Walmart Labs,Tesla,JPMorgan",Array,5504,970,85,1,"[Missing Number, /problems/missing-number/, Easy], [Find the Duplicate Number, /problems/find-the-duplicate-number/, Medium], [Find All Numbers Disappeared in an Array, /problems/find-all-numbers-disappeared-in-an-array/, Easy], [Couples Holding Hands, /problems/couples-holding-hands/, Hard]","class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        
    }
};","class Solution {
    public int firstMissingPositive(int[] nums) {
        
    }
}","class Solution(object):
    def firstMissingPositive(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        ","int firstMissingPositive(int* nums, int numsSize){

}","public class Solution {
    public int FirstMissingPositive(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def first_missing_positive(nums)
    
end","class Solution {
    func firstMissingPositive(_ nums: [Int]) -> Int {
        
    }
}","func firstMissingPositive(nums []int) int {
    
}","object Solution {
    def firstMissingPositive(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun firstMissingPositive(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn first_missing_positive(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function firstMissingPositive($nums) {
        
    }
}","function firstMissingPositive(nums: number[]): number {

};","(define/contract (first-missing-positive nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec first_missing_positive(Nums :: [integer()]) -> integer().
first_missing_positive(Nums) ->
  .","defmodule Solution do
  @spec first_missing_positive(nums :: [integer]) :: integer
  def first_missing_positive(nums) do

  end
end","class Solution {
  int firstMissingPositive(List<int> nums) {

  }
}",,,,first-missing-positive
8,42,Trapping Rain Water,"Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.",0,Hard,/articles/trapping-rain-water,51.6,96.3,https://leetcode.com/problems/trapping-rain-water,999,715K,1.4M,"Goldman Sachs,Facebook,Amazon,Microsoft,Bloomberg,Apple,Databricks,Google,Qualtrics,Adobe,Oracle,Yahoo","Array,Two Pointers,Dynamic Programming,Stack",10683,159,99,1,"[Container With Most Water, /problems/container-with-most-water/, Medium], [Product of Array Except Self, /problems/product-of-array-except-self/, Medium], [Trapping Rain Water II, /problems/trapping-rain-water-ii/, Hard], [Pour Water, /problems/pour-water/, Medium]","class Solution {
public:
    int trap(vector<int>& height) {
        
    }
};","class Solution {
    public int trap(int[] height) {
        
    }
}","class Solution(object):
    def trap(self, height):
        """"""
        :type height: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def trap(self, height: List[int]) -> int:
        ","int trap(int* height, int heightSize){

}","public class Solution {
    public int Trap(int[] height) {
        
    }
}","/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    
};","# @param {Integer[]} height
# @return {Integer}
def trap(height)
    
end","class Solution {
    func trap(_ height: [Int]) -> Int {
        
    }
}","func trap(height []int) int {
    
}","object Solution {
    def trap(height: Array[Int]): Int = {
        
    }
}","class Solution {
    fun trap(height: IntArray): Int {
        
    }
}","impl Solution {
    pub fn trap(height: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $height
     * @return Integer
     */
    function trap($height) {
        
    }
}","function trap(height: number[]): number {

};","(define/contract (trap height)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec trap(Height :: [integer()]) -> integer().
trap(Height) ->
  .","defmodule Solution do
  @spec trap(height :: [integer]) :: integer
  def trap(height) do

  end
end","class Solution {
  int trap(List<int> height) {

  }
}",,,,trapping-rain-water
9,44,Wildcard Matching,"Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:
`'?'` Matches any single character.
`'*'` Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).",0,Hard,/articles/wildcard-matching,25.5,59.0,https://leetcode.com/problems/wildcard-matching,823,296.2K,1.2M,"Adobe,Amazon,Citadel,Facebook,Microsoft,Google,Bloomberg,Snapchat","String,Dynamic Programming,Backtracking,Greedy",2848,139,95,1,"[Regular Expression Matching, /problems/regular-expression-matching/, Hard]","class Solution {
public:
    bool isMatch(string s, string p) {
        
    }
};","class Solution {
    public boolean isMatch(String s, String p) {
        
    }
}","class Solution(object):
    def isMatch(self, s, p):
        """"""
        :type s: str
        :type p: str
        :rtype: bool
        """"""
        ","class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        ","bool isMatch(char * s, char * p){

}","public class Solution {
    public bool IsMatch(string s, string p) {
        
    }
}","/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    
};","# @param {String} s
# @param {String} p
# @return {Boolean}
def is_match(s, p)
    
end","class Solution {
    func isMatch(_ s: String, _ p: String) -> Bool {
        
    }
}","func isMatch(s string, p string) bool {
    
}","object Solution {
    def isMatch(s: String, p: String): Boolean = {
        
    }
}","class Solution {
    fun isMatch(s: String, p: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_match(s: String, p: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $p
     * @return Boolean
     */
    function isMatch($s, $p) {
        
    }
}","function isMatch(s: string, p: string): boolean {

};","(define/contract (is-match s p)
  (-> string? string? boolean?)

  )","-spec is_match(S :: unicode:unicode_binary(), P :: unicode:unicode_binary()) -> boolean().
is_match(S, P) ->
  .","defmodule Solution do
  @spec is_match(s :: String.t, p :: String.t) :: boolean
  def is_match(s, p) do

  end
end","class Solution {
  bool isMatch(String s, String p) {

  }
}",,,,wildcard-matching
10,51,N-Queens,"The n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.
Given an integer `n`, return all distinct solutions to the n-queens puzzle.
Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.",0,Hard,/articles/n-queens,50.2,60.1,https://leetcode.com/problems/n-queens,999,248.4K,495.2K,"Facebook,Microsoft,Amazon,ByteDance,Apple,Adobe",Backtracking,2803,102,96,1,"[N-Queens II, /problems/n-queens-ii/, Hard], [Grid Illumination, /problems/grid-illumination/, Hard]","class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        
    }
};","class Solution {
    public List<List<String>> solveNQueens(int n) {
        
    }
}","class Solution(object):
    def solveNQueens(self, n):
        """"""
        :type n: int
        :rtype: List[List[str]]
        """"""
        ","class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char *** solveNQueens(int n, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public IList<IList<string>> SolveNQueens(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
    
};","# @param {Integer} n
# @return {String[][]}
def solve_n_queens(n)
    
end","class Solution {
    func solveNQueens(_ n: Int) -> [[String]] {
        
    }
}","func solveNQueens(n int) [][]string {
    
}","object Solution {
    def solveNQueens(n: Int): List[List[String]] = {
        
    }
}","class Solution {
    fun solveNQueens(n: Int): List<List<String>> {
        
    }
}","impl Solution {
    pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return String[][]
     */
    function solveNQueens($n) {
        
    }
}","function solveNQueens(n: number): string[][] {

};","(define/contract (solve-n-queens n)
  (-> exact-integer? (listof (listof string?)))

  )","-spec solve_n_queens(N :: integer()) -> [[unicode:unicode_binary()]].
solve_n_queens(N) ->
  .","defmodule Solution do
  @spec solve_n_queens(n :: integer) :: [[String.t]]
  def solve_n_queens(n) do

  end
end","class Solution {
  List<List<String>> solveNQueens(int n) {

  }
}",,,,n-queens
11,52,N-Queens II,"The n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.
Given an integer `n`, return the number of distinct solutions to the n-queens puzzle.",0,Hard,/articles/n-queens-ii,60.5,13.7,https://leetcode.com/problems/n-queens-ii,643,158.9K,262.4K,"Amazon,Zenefits",Backtracking,790,181,81,1,"[N-Queens, /problems/n-queens/, Hard]","class Solution {
public:
    int totalNQueens(int n) {
        
    }
};","class Solution {
    public int totalNQueens(int n) {
        
    }
}","class Solution(object):
    def totalNQueens(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def totalNQueens(self, n: int) -> int:
        ","int totalNQueens(int n){

}","public class Solution {
    public int TotalNQueens(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var totalNQueens = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def total_n_queens(n)
    
end","class Solution {
    func totalNQueens(_ n: Int) -> Int {
        
    }
}","func totalNQueens(n int) int {
    
}","object Solution {
    def totalNQueens(n: Int): Int = {
        
    }
}","class Solution {
    fun totalNQueens(n: Int): Int {
        
    }
}","impl Solution {
    pub fn total_n_queens(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function totalNQueens($n) {
        
    }
}","function totalNQueens(n: number): number {

};","(define/contract (total-n-queens n)
  (-> exact-integer? exact-integer?)

  )","-spec total_n_queens(N :: integer()) -> integer().
total_n_queens(N) ->
  .","defmodule Solution do
  @spec total_n_queens(n :: integer) :: integer
  def total_n_queens(n) do

  end
end","class Solution {
  int totalNQueens(int n) {

  }
}",,,,n-queens-ii
12,60,Permutation Sequence,"The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.
By listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:
`""123""`
`""132""`
`""213""`
`""231""`
`""312""`
`""321""`
Given `n` and `k`, return the `kth` permutation sequence.",0,Hard,/articles/permutation-sequence,39.5,24.1,https://leetcode.com/problems/permutation-sequence,999,223K,563.9K,"Amazon,Adobe","Math,Backtracking",2152,361,86,1,"[Next Permutation, /problems/next-permutation/, Medium], [Permutations, /problems/permutations/, Medium]","class Solution {
public:
    string getPermutation(int n, int k) {
        
    }
};","class Solution {
    public String getPermutation(int n, int k) {
        
    }
}","class Solution(object):
    def getPermutation(self, n, k):
        """"""
        :type n: int
        :type k: int
        :rtype: str
        """"""
        ","class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        ","char * getPermutation(int n, int k){

}","public class Solution {
    public string GetPermutation(int n, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number} k
 * @return {string}
 */
var getPermutation = function(n, k) {
    
};","# @param {Integer} n
# @param {Integer} k
# @return {String}
def get_permutation(n, k)
    
end","class Solution {
    func getPermutation(_ n: Int, _ k: Int) -> String {
        
    }
}","func getPermutation(n int, k int) string {
    
}","object Solution {
    def getPermutation(n: Int, k: Int): String = {
        
    }
}","class Solution {
    fun getPermutation(n: Int, k: Int): String {
        
    }
}","impl Solution {
    pub fn get_permutation(n: i32, k: i32) -> String {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $k
     * @return String
     */
    function getPermutation($n, $k) {
        
    }
}","function getPermutation(n: number, k: number): string {

};","(define/contract (get-permutation n k)
  (-> exact-integer? exact-integer? string?)

  )","-spec get_permutation(N :: integer(), K :: integer()) -> unicode:unicode_binary().
get_permutation(N, K) ->
  .","defmodule Solution do
  @spec get_permutation(n :: integer, k :: integer) :: String.t
  def get_permutation(n, k) do

  end
end","class Solution {
  String getPermutation(int n, int k) {

  }
}",,,,permutation-sequence
13,65,Valid Number,"A valid number can be split up into these components (in order):
A decimal number or an integer.
(Optional) An `'e'` or `'E'`, followed by an integer.
A decimal number can be split up into these components (in order):
(Optional) A sign character (either `'+'` or `'-'`).
One of the following formats:
At least one digit, followed by a dot `'.'`.
At least one digit, followed by a dot `'.'`, followed by at least one digit.
A dot `'.'`, followed by at least one digit.
An integer can be split up into these components (in order):
(Optional) A sign character (either `'+'` or `'-'`).
At least one digit.
For example, all the following are valid numbers: `[""2"", ""0089"", ""-0.1"", ""+3.14"", ""4."", ""-.9"", ""2e10"", ""-90E3"", ""3e+7"", ""+6e-1"", ""53.5e93"", ""-123.456e789""]`, while the following are not valid numbers: `[""abc"", ""1a"", ""1e"", ""e3"", ""99e2.5"", ""--6"", ""-+3"", ""95a54e53""]`.
Given a string `s`, return `true` if `s` is a valid number.",0,Hard,,16.0,54.1,https://leetcode.com/problems/valid-number,999,199.5K,1.2M,"Facebook,LinkedIn,Oracle,Twitch","Math,String",902,5572,14,1,"[String to Integer (atoi), /problems/string-to-integer-atoi/, Medium]","class Solution {
public:
    bool isNumber(string s) {
        
    }
};","class Solution {
    public boolean isNumber(String s) {
        
    }
}","class Solution(object):
    def isNumber(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        ","class Solution:
    def isNumber(self, s: str) -> bool:
        ","bool isNumber(char * s){

}","public class Solution {
    public bool IsNumber(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {boolean}
 */
var isNumber = function(s) {
    
};","# @param {String} s
# @return {Boolean}
def is_number(s)
    
end","class Solution {
    func isNumber(_ s: String) -> Bool {
        
    }
}","func isNumber(s string) bool {
    
}","object Solution {
    def isNumber(s: String): Boolean = {
        
    }
}","class Solution {
    fun isNumber(s: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_number(s: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Boolean
     */
    function isNumber($s) {
        
    }
}","function isNumber(s: string): boolean {

};","(define/contract (is-number s)
  (-> string? boolean?)

  )","-spec is_number(S :: unicode:unicode_binary()) -> boolean().
is_number(S) ->
  .","defmodule Solution do
  @spec is_number(s :: String.t) :: boolean
  def is_number(s) do

  end
end","class Solution {
  bool isNumber(String s) {

  }
}",,,,valid-number
14,68,Text Justification,"Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.
You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly maxWidth characters.
Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.
For the last line of text, it should be left justified and no extra space is inserted between words.
Note:
A word is defined as a character sequence consisting of non-space characters only.
Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
The input array `words` contains at least one word.",0,Hard,,30.1,95.5,https://leetcode.com/problems/text-justification,936,167K,553.9K,"Intuit,Twilio,Uber,Karat,Indeed,Google,Amazon,Reddit,LinkedIn,Bloomberg,Microsoft,Twitter,Paypal,Apple,ByteDance,Databricks,Netflix,eBay",String,987,1954,34,1,"[Rearrange Spaces Between Words, /problems/rearrange-spaces-between-words/, Easy]","class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        
    }
};","class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        
    }
}","class Solution(object):
    def fullJustify(self, words, maxWidth):
        """"""
        :type words: List[str]
        :type maxWidth: int
        :rtype: List[str]
        """"""
        ","class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize){

}","public class Solution {
    public IList<string> FullJustify(string[] words, int maxWidth) {
        
    }
}","/**
 * @param {string[]} words
 * @param {number} maxWidth
 * @return {string[]}
 */
var fullJustify = function(words, maxWidth) {
    
};","# @param {String[]} words
# @param {Integer} max_width
# @return {String[]}
def full_justify(words, max_width)
    
end","class Solution {
    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {
        
    }
}","func fullJustify(words []string, maxWidth int) []string {
    
}","object Solution {
    def fullJustify(words: Array[String], maxWidth: Int): List[String] = {
        
    }
}","class Solution {
    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {
        
    }
}","impl Solution {
    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @param Integer $maxWidth
     * @return String[]
     */
    function fullJustify($words, $maxWidth) {
        
    }
}","function fullJustify(words: string[], maxWidth: number): string[] {

};","(define/contract (full-justify words maxWidth)
  (-> (listof string?) exact-integer? (listof string?))

  )","-spec full_justify(Words :: [unicode:unicode_binary()], MaxWidth :: integer()) -> [unicode:unicode_binary()].
full_justify(Words, MaxWidth) ->
  .","defmodule Solution do
  @spec full_justify(words :: [String.t], max_width :: integer) :: [String.t]
  def full_justify(words, max_width) do

  end
end","class Solution {
  List<String> fullJustify(List<String> words, int maxWidth) {

  }
}",,,,text-justification
15,72,Edit Distance,"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.
You have the following three operations permitted on a word:
Insert a character
Delete a character
Replace a character",0,Hard,/articles/edit-distance,47.1,59.8,https://leetcode.com/problems/edit-distance,999,346.5K,736K,"Amazon,Microsoft,Google,Square,Palantir Technologies","String,Dynamic Programming",5416,67,99,1,"[One Edit Distance, /problems/one-edit-distance/, Medium], [Delete Operation for Two Strings, /problems/delete-operation-for-two-strings/, Medium], [Minimum ASCII Delete Sum for Two Strings, /problems/minimum-ascii-delete-sum-for-two-strings/, Medium], [Uncrossed Lines, /problems/uncrossed-lines/, Medium]","class Solution {
public:
    int minDistance(string word1, string word2) {
        
    }
};","class Solution {
    public int minDistance(String word1, String word2) {
        
    }
}","class Solution(object):
    def minDistance(self, word1, word2):
        """"""
        :type word1: str
        :type word2: str
        :rtype: int
        """"""
        ","class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        ","int minDistance(char * word1, char * word2){

}","public class Solution {
    public int MinDistance(string word1, string word2) {
        
    }
}","/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    
};","# @param {String} word1
# @param {String} word2
# @return {Integer}
def min_distance(word1, word2)
    
end","class Solution {
    func minDistance(_ word1: String, _ word2: String) -> Int {
        
    }
}","func minDistance(word1 string, word2 string) int {
    
}","object Solution {
    def minDistance(word1: String, word2: String): Int = {
        
    }
}","class Solution {
    fun minDistance(word1: String, word2: String): Int {
        
    }
}","impl Solution {
    pub fn min_distance(word1: String, word2: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $word1
     * @param String $word2
     * @return Integer
     */
    function minDistance($word1, $word2) {
        
    }
}","function minDistance(word1: string, word2: string): number {

};","(define/contract (min-distance word1 word2)
  (-> string? string? exact-integer?)

  )","-spec min_distance(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> integer().
min_distance(Word1, Word2) ->
  .","defmodule Solution do
  @spec min_distance(word1 :: String.t, word2 :: String.t) :: integer
  def min_distance(word1, word2) do

  end
end","class Solution {
  int minDistance(String word1, String word2) {

  }
}",,,,edit-distance
16,76,Minimum Window Substring,"Given two strings `s` and `t`, return the minimum window in `s` which will contain all the characters in `t`. If there is no such window in `s` that covers all characters in `t`, return the empty string `""""`.
Note that If there is such a window, it is guaranteed that there will always be only one unique minimum window in `s`.",0,Hard,/articles/minimum-window-substring,36.2,69.1,https://leetcode.com/problems/minimum-window-substring,999,518.5K,1.4M,"Facebook,Amazon,Microsoft,Lyft,Apple,LinkedIn,Google,Uber,Bloomberg,Pinterest,Snapchat,Adobe,ByteDance","Hash Table,Two Pointers,String,Sliding Window",6350,428,94,1,"[Substring with Concatenation of All Words, /problems/substring-with-concatenation-of-all-words/, Hard], [Minimum Size Subarray Sum, /problems/minimum-size-subarray-sum/, Medium], [Sliding Window Maximum, /problems/sliding-window-maximum/, Hard], [Permutation in String, /problems/permutation-in-string/, Medium], [Smallest Range Covering Elements from K Lists, /problems/smallest-range-covering-elements-from-k-lists/, Hard], [Minimum Window Subsequence, /problems/minimum-window-subsequence/, Hard]","class Solution {
public:
    string minWindow(string s, string t) {
        
    }
};","class Solution {
    public String minWindow(String s, String t) {
        
    }
}","class Solution(object):
    def minWindow(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: str
        """"""
        ","class Solution:
    def minWindow(self, s: str, t: str) -> str:
        ","char * minWindow(char * s, char * t){

}","public class Solution {
    public string MinWindow(string s, string t) {
        
    }
}","/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {
    
};","# @param {String} s
# @param {String} t
# @return {String}
def min_window(s, t)
    
end","class Solution {
    func minWindow(_ s: String, _ t: String) -> String {
        
    }
}","func minWindow(s string, t string) string {
    
}","object Solution {
    def minWindow(s: String, t: String): String = {
        
    }
}","class Solution {
    fun minWindow(s: String, t: String): String {
        
    }
}","impl Solution {
    pub fn min_window(s: String, t: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $t
     * @return String
     */
    function minWindow($s, $t) {
        
    }
}","function minWindow(s: string, t: string): string {

};","(define/contract (min-window s t)
  (-> string? string? string?)

  )","-spec min_window(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> unicode:unicode_binary().
min_window(S, T) ->
  .","defmodule Solution do
  @spec min_window(s :: String.t, t :: String.t) :: String.t
  def min_window(s, t) do

  end
end","class Solution {
  String minWindow(String s, String t) {

  }
}",,,,minimum-window-substring
17,84,Largest Rectangle in Histogram,"Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return the area of the largest rectangle in the histogram.",0,Hard,/articles/largest-rectangle-in-histogram,37.4,57.5,https://leetcode.com/problems/largest-rectangle-in-histogram,999,350.8K,937.9K,"Amazon,Microsoft,Adobe,MAQ Software","Array,Stack",5576,111,98,1,"[Maximal Rectangle, /problems/maximal-rectangle/, Hard], [Maximum Score of a Good Subarray, /problems/maximum-score-of-a-good-subarray/, Hard]","class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        
    }
};","class Solution {
    public int largestRectangleArea(int[] heights) {
        
    }
}","class Solution(object):
    def largestRectangleArea(self, heights):
        """"""
        :type heights: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        ","int largestRectangleArea(int* heights, int heightsSize){

}","public class Solution {
    public int LargestRectangleArea(int[] heights) {
        
    }
}","/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
    
};","# @param {Integer[]} heights
# @return {Integer}
def largest_rectangle_area(heights)
    
end","class Solution {
    func largestRectangleArea(_ heights: [Int]) -> Int {
        
    }
}","func largestRectangleArea(heights []int) int {
    
}","object Solution {
    def largestRectangleArea(heights: Array[Int]): Int = {
        
    }
}","class Solution {
    fun largestRectangleArea(heights: IntArray): Int {
        
    }
}","impl Solution {
    pub fn largest_rectangle_area(heights: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $heights
     * @return Integer
     */
    function largestRectangleArea($heights) {
        
    }
}","function largestRectangleArea(heights: number[]): number {

};","(define/contract (largest-rectangle-area heights)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec largest_rectangle_area(Heights :: [integer()]) -> integer().
largest_rectangle_area(Heights) ->
  .","defmodule Solution do
  @spec largest_rectangle_area(heights :: [integer]) :: integer
  def largest_rectangle_area(heights) do

  end
end","class Solution {
  int largestRectangleArea(List<int> heights) {

  }
}",,,,largest-rectangle-in-histogram
18,85,Maximal Rectangle,"Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.",0,Hard,/articles/maximal-rectangle,39.7,62.6,https://leetcode.com/problems/maximal-rectangle,651,222.8K,561.2K,"Google,Amazon,Adobe,Bloomberg,Apple","Array,Hash Table,Dynamic Programming,Stack",4086,86,98,1,"[Largest Rectangle in Histogram, /problems/largest-rectangle-in-histogram/, Hard], [Maximal Square, /problems/maximal-square/, Medium]","class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        
    }
};","class Solution {
    public int maximalRectangle(char[][] matrix) {
        
    }
}","class Solution(object):
    def maximalRectangle(self, matrix):
        """"""
        :type matrix: List[List[str]]
        :rtype: int
        """"""
        ","class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        ","int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize){

}","public class Solution {
    public int MaximalRectangle(char[][] matrix) {
        
    }
}","/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
    
};","# @param {Character[][]} matrix
# @return {Integer}
def maximal_rectangle(matrix)
    
end","class Solution {
    func maximalRectangle(_ matrix: [[Character]]) -> Int {
        
    }
}","func maximalRectangle(matrix [][]byte) int {
    
}","object Solution {
    def maximalRectangle(matrix: Array[Array[Char]]): Int = {
        
    }
}","class Solution {
    fun maximalRectangle(matrix: Array<CharArray>): Int {
        
    }
}","impl Solution {
    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[][] $matrix
     * @return Integer
     */
    function maximalRectangle($matrix) {
        
    }
}","function maximalRectangle(matrix: string[][]): number {

};","(define/contract (maximal-rectangle matrix)
  (-> (listof (listof char?)) exact-integer?)

  )","-spec maximal_rectangle(Matrix :: [[char()]]) -> integer().
maximal_rectangle(Matrix) ->
  .","defmodule Solution do
  @spec maximal_rectangle(matrix :: [[char]]) :: integer
  def maximal_rectangle(matrix) do

  end
end","class Solution {
  int maximalRectangle(List<List<String>> matrix) {

  }
}",,,,maximal-rectangle
19,87,Scramble String,"We can scramble a string s to get a string t using the following algorithm:
If the length of the string is 1, stop.
If the length of the string is > 1, do the following:
Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.
Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.
Apply step 1 recursively on each of the two substrings `x` and `y`.
Given two strings `s1` and `s2` of the same length, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.",0,Hard,,34.8,9.0,https://leetcode.com/problems/scramble-string,335,122.9K,353.2K,Apple,"String,Dynamic Programming",760,805,49,1,,"class Solution {
public:
    bool isScramble(string s1, string s2) {
        
    }
};","class Solution {
    public boolean isScramble(String s1, String s2) {
        
    }
}","class Solution(object):
    def isScramble(self, s1, s2):
        """"""
        :type s1: str
        :type s2: str
        :rtype: bool
        """"""
        ","class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        ","bool isScramble(char * s1, char * s2){

}","public class Solution {
    public bool IsScramble(string s1, string s2) {
        
    }
}","/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var isScramble = function(s1, s2) {
    
};","# @param {String} s1
# @param {String} s2
# @return {Boolean}
def is_scramble(s1, s2)
    
end","class Solution {
    func isScramble(_ s1: String, _ s2: String) -> Bool {
        
    }
}","func isScramble(s1 string, s2 string) bool {
    
}","object Solution {
    def isScramble(s1: String, s2: String): Boolean = {
        
    }
}","class Solution {
    fun isScramble(s1: String, s2: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_scramble(s1: String, s2: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $s1
     * @param String $s2
     * @return Boolean
     */
    function isScramble($s1, $s2) {
        
    }
}","function isScramble(s1: string, s2: string): boolean {

};","(define/contract (is-scramble s1 s2)
  (-> string? string? boolean?)

  )","-spec is_scramble(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> boolean().
is_scramble(S1, S2) ->
  .","defmodule Solution do
  @spec is_scramble(s1 :: String.t, s2 :: String.t) :: boolean
  def is_scramble(s1, s2) do

  end
end","class Solution {
  bool isScramble(String s1, String s2) {

  }
}",,,,scramble-string
21,115,Distinct Subsequences,"Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equals `t`.
A string's subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters' relative positions. (i.e., `""ACE""` is a subsequence of `""ABCDE""` while `""AEC""` is not).
It is guaranteed the answer fits on a 32-bit signed integer.",0,Hard,/articles/distinct-subsequences,40.0,49.9,https://leetcode.com/problems/distinct-subsequences,654,160.9K,402.3K,"Mathworks,Google,Amazon,Bloomberg","String,Dynamic Programming",1859,63,97,1,,"class Solution {
public:
    int numDistinct(string s, string t) {
        
    }
};","class Solution {
    public int numDistinct(String s, String t) {
        
    }
}","class Solution(object):
    def numDistinct(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: int
        """"""
        ","class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        ","int numDistinct(char * s, char * t){

}","public class Solution {
    public int NumDistinct(string s, string t) {
        
    }
}","/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var numDistinct = function(s, t) {
    
};","# @param {String} s
# @param {String} t
# @return {Integer}
def num_distinct(s, t)
    
end","class Solution {
    func numDistinct(_ s: String, _ t: String) -> Int {
        
    }
}","func numDistinct(s string, t string) int {
    
}","object Solution {
    def numDistinct(s: String, t: String): Int = {
        
    }
}","class Solution {
    fun numDistinct(s: String, t: String): Int {
        
    }
}","impl Solution {
    pub fn num_distinct(s: String, t: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $t
     * @return Integer
     */
    function numDistinct($s, $t) {
        
    }
}","function numDistinct(s: string, t: string): number {

};","(define/contract (num-distinct s t)
  (-> string? string? exact-integer?)

  )","-spec num_distinct(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> integer().
num_distinct(S, T) ->
  .","defmodule Solution do
  @spec num_distinct(s :: String.t, t :: String.t) :: integer
  def num_distinct(s, t) do

  end
end","class Solution {
  int numDistinct(String s, String t) {

  }
}",,,,distinct-subsequences
22,123,Best Time to Buy and Sell Stock III,"You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.
Find the maximum profit you can achieve. You may complete at most two transactions.
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",0,Hard,/articles/best-time-to-buy-and-sell-stock-iii,40.2,42.2,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii,775,284.2K,707.6K,"Amazon,Google","Array,Dynamic Programming",3417,88,97,1,"[Best Time to Buy and Sell Stock, /problems/best-time-to-buy-and-sell-stock/, Easy], [Best Time to Buy and Sell Stock II, /problems/best-time-to-buy-and-sell-stock-ii/, Easy], [Best Time to Buy and Sell Stock IV, /problems/best-time-to-buy-and-sell-stock-iv/, Hard], [Maximum Sum of 3 Non-Overlapping Subarrays, /problems/maximum-sum-of-3-non-overlapping-subarrays/, Hard]","class Solution {
public:
    int maxProfit(vector<int>& prices) {
        
    }
};","class Solution {
    public int maxProfit(int[] prices) {
        
    }
}","class Solution(object):
    def maxProfit(self, prices):
        """"""
        :type prices: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ","int maxProfit(int* prices, int pricesSize){

}","public class Solution {
    public int MaxProfit(int[] prices) {
        
    }
}","/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    
};","# @param {Integer[]} prices
# @return {Integer}
def max_profit(prices)
    
end","class Solution {
    func maxProfit(_ prices: [Int]) -> Int {
        
    }
}","func maxProfit(prices []int) int {
    
}","object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxProfit(prices: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_profit(prices: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $prices
     * @return Integer
     */
    function maxProfit($prices) {
        
    }
}","function maxProfit(prices: number[]): number {

};","(define/contract (max-profit prices)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_profit(Prices :: [integer()]) -> integer().
max_profit(Prices) ->
  .","defmodule Solution do
  @spec max_profit(prices :: [integer]) :: integer
  def max_profit(prices) do

  end
end","class Solution {
  int maxProfit(List<int> prices) {

  }
}",,,,best-time-to-buy-and-sell-stock-iii
24,126,Word Ladder II,"A transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:
Every adjacent pair of words differs by a single letter.
Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
`sk == endWord`
Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return all the shortest transformation sequences from `beginWord` to `endWord`, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words `[beginWord, s1, s2, ..., sk]`.",0,Hard,,23.8,55.3,https://leetcode.com/problems/word-ladder-ii,866,223K,937K,"Uber,Amazon,Facebook,Box,Lyft,Microsoft,Google,Bloomberg","Array,String,Backtracking,Breadth-first Search",2391,293,89,1,"[Word Ladder, /problems/word-ladder/, Hard]","class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        
    }
};","class Solution {
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        
    }
}","class Solution(object):
    def findLadders(self, beginWord, endWord, wordList):
        """"""
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: List[List[str]]
        """"""
        ","class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char *** findLadders(char * beginWord, char * endWord, char ** wordList, int wordListSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList) {
        
    }
}","/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {string[][]}
 */
var findLadders = function(beginWord, endWord, wordList) {
    
};","# @param {String} begin_word
# @param {String} end_word
# @param {String[]} word_list
# @return {String[][]}
def find_ladders(begin_word, end_word, word_list)
    
end","class Solution {
    func findLadders(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> [[String]] {
        
    }
}","func findLadders(beginWord string, endWord string, wordList []string) [][]string {
    
}","object Solution {
    def findLadders(beginWord: String, endWord: String, wordList: List[String]): List[List[String]] = {
        
    }
}","class Solution {
    fun findLadders(beginWord: String, endWord: String, wordList: List<String>): List<List<String>> {
        
    }
}","impl Solution {
    pub fn find_ladders(begin_word: String, end_word: String, word_list: Vec<String>) -> Vec<Vec<String>> {
        
    }
}","class Solution {

    /**
     * @param String $beginWord
     * @param String $endWord
     * @param String[] $wordList
     * @return String[][]
     */
    function findLadders($beginWord, $endWord, $wordList) {
        
    }
}","function findLadders(beginWord: string, endWord: string, wordList: string[]): string[][] {

};","(define/contract (find-ladders beginWord endWord wordList)
  (-> string? string? (listof string?) (listof (listof string?)))

  )","-spec find_ladders(BeginWord :: unicode:unicode_binary(), EndWord :: unicode:unicode_binary(), WordList :: [unicode:unicode_binary()]) -> [[unicode:unicode_binary()]].
find_ladders(BeginWord, EndWord, WordList) ->
  .","defmodule Solution do
  @spec find_ladders(begin_word :: String.t, end_word :: String.t, word_list :: [String.t]) :: [[String.t]]
  def find_ladders(begin_word, end_word, word_list) do

  end
end","class Solution {
  List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {

  }
}",,,,word-ladder-ii
25,127,Word Ladder,"A transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:
Every adjacent pair of words differs by a single letter.
Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
`sk == endWord`
Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such sequence exists.",0,Hard,/articles/word-ladder,32.1,84.2,https://leetcode.com/problems/word-ladder,999,564.1K,1.8M,"Amazon,Facebook,Lyft,Microsoft,Google,Uber,Bloomberg,Qualtrics,Snapchat,Oracle,Yahoo,Apple,Zillow,Citadel",Breadth-first Search,4859,1404,78,1,"[Word Ladder II, /problems/word-ladder-ii/, Hard], [Minimum Genetic Mutation, /problems/minimum-genetic-mutation/, Medium]","class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        
    }
};","class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        
    }
}","class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        """"""
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        ","int ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize){

}","public class Solution {
    public int LadderLength(string beginWord, string endWord, IList<string> wordList) {
        
    }
}","/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
    
};","# @param {String} begin_word
# @param {String} end_word
# @param {String[]} word_list
# @return {Integer}
def ladder_length(begin_word, end_word, word_list)
    
end","class Solution {
    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {
        
    }
}","func ladderLength(beginWord string, endWord string, wordList []string) int {
    
}","object Solution {
    def ladderLength(beginWord: String, endWord: String, wordList: List[String]): Int = {
        
    }
}","class Solution {
    fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {
        
    }
}","impl Solution {
    pub fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $beginWord
     * @param String $endWord
     * @param String[] $wordList
     * @return Integer
     */
    function ladderLength($beginWord, $endWord, $wordList) {
        
    }
}","function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {

};","(define/contract (ladder-length beginWord endWord wordList)
  (-> string? string? (listof string?) exact-integer?)

  )","-spec ladder_length(BeginWord :: unicode:unicode_binary(), EndWord :: unicode:unicode_binary(), WordList :: [unicode:unicode_binary()]) -> integer().
ladder_length(BeginWord, EndWord, WordList) ->
  .","defmodule Solution do
  @spec ladder_length(begin_word :: String.t, end_word :: String.t, word_list :: [String.t]) :: integer
  def ladder_length(begin_word, end_word, word_list) do

  end
end","class Solution {
  int ladderLength(String beginWord, String endWord, List<String> wordList) {

  }
}",,,,word-ladder
26,128,Longest Consecutive Sequence,"Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.",0,Hard,/articles/longest-consecutive-sequence,46.5,60.0,https://leetcode.com/problems/longest-consecutive-sequence,999,389K,837.1K,"Google,Amazon,Microsoft,Facebook,Bloomberg,Twitter","Array,Union Find",4894,238,95,1,"[Binary Tree Longest Consecutive Sequence, /problems/binary-tree-longest-consecutive-sequence/, Medium]","class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        
    }
};","class Solution {
    public int longestConsecutive(int[] nums) {
        
    }
}","class Solution(object):
    def longestConsecutive(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        ","int longestConsecutive(int* nums, int numsSize){

}","public class Solution {
    public int LongestConsecutive(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def longest_consecutive(nums)
    
end","class Solution {
    func longestConsecutive(_ nums: [Int]) -> Int {
        
    }
}","func longestConsecutive(nums []int) int {
    
}","object Solution {
    def longestConsecutive(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun longestConsecutive(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function longestConsecutive($nums) {
        
    }
}","function longestConsecutive(nums: number[]): number {

};","(define/contract (longest-consecutive nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec longest_consecutive(Nums :: [integer()]) -> integer().
longest_consecutive(Nums) ->
  .","defmodule Solution do
  @spec longest_consecutive(nums :: [integer]) :: integer
  def longest_consecutive(nums) do

  end
end","class Solution {
  int longestConsecutive(List<int> nums) {

  }
}",,,,longest-consecutive-sequence
27,132,Palindrome Partitioning II,"Given a string `s`, partition `s` such that every substring of the partition is a palindrome.
Return the minimum cuts needed for a palindrome partitioning of `s`.",0,Hard,,31.4,7.7,https://leetcode.com/problems/palindrome-partitioning-ii,430,153.2K,487.9K,"Amazon,Google",Dynamic Programming,1760,52,97,1,"[Palindrome Partitioning, /problems/palindrome-partitioning/, Medium], [Palindrome Partitioning IV, /problems/palindrome-partitioning-iv/, Hard]","class Solution {
public:
    int minCut(string s) {
        
    }
};","class Solution {
    public int minCut(String s) {
        
    }
}","class Solution(object):
    def minCut(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def minCut(self, s: str) -> int:
        ","int minCut(char * s){

}","public class Solution {
    public int MinCut(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var minCut = function(s) {
    
};","# @param {String} s
# @return {Integer}
def min_cut(s)
    
end","class Solution {
    func minCut(_ s: String) -> Int {
        
    }
}","func minCut(s string) int {
    
}","object Solution {
    def minCut(s: String): Int = {
        
    }
}","class Solution {
    fun minCut(s: String): Int {
        
    }
}","impl Solution {
    pub fn min_cut(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function minCut($s) {
        
    }
}","function minCut(s: string): number {

};","(define/contract (min-cut s)
  (-> string? exact-integer?)

  )","-spec min_cut(S :: unicode:unicode_binary()) -> integer().
min_cut(S) ->
  .","defmodule Solution do
  @spec min_cut(s :: String.t) :: integer
  def min_cut(s) do

  end
end","class Solution {
  int minCut(String s) {

  }
}",,,,palindrome-partitioning-ii
28,135,Candy,"There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.
You are giving candies to these children subjected to the following requirements:
Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
Return the minimum number of candies you need to have to distribute the candies to the children.",0,Hard,/articles/candy,33.3,45.7,https://leetcode.com/problems/candy,584,153.8K,462.1K,Amazon,Greedy,1402,195,88,1,,"class Solution {
public:
    int candy(vector<int>& ratings) {
        
    }
};","class Solution {
    public int candy(int[] ratings) {
        
    }
}","class Solution(object):
    def candy(self, ratings):
        """"""
        :type ratings: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def candy(self, ratings: List[int]) -> int:
        ","int candy(int* ratings, int ratingsSize){

}","public class Solution {
    public int Candy(int[] ratings) {
        
    }
}","/**
 * @param {number[]} ratings
 * @return {number}
 */
var candy = function(ratings) {
    
};","# @param {Integer[]} ratings
# @return {Integer}
def candy(ratings)
    
end","class Solution {
    func candy(_ ratings: [Int]) -> Int {
        
    }
}","func candy(ratings []int) int {
    
}","object Solution {
    def candy(ratings: Array[Int]): Int = {
        
    }
}","class Solution {
    fun candy(ratings: IntArray): Int {
        
    }
}","impl Solution {
    pub fn candy(ratings: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $ratings
     * @return Integer
     */
    function candy($ratings) {
        
    }
}","function candy(ratings: number[]): number {

};","(define/contract (candy ratings)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec candy(Ratings :: [integer()]) -> integer().
candy(Ratings) ->
  .","defmodule Solution do
  @spec candy(ratings :: [integer]) :: integer
  def candy(ratings) do

  end
end","class Solution {
  int candy(List<int> ratings) {

  }
}",,,,candy
29,140,Word Break II,"Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.
Note that the same word in the dictionary may be reused multiple times in the segmentation.",0,Hard,/articles/word-break-ii,35.3,70.4,https://leetcode.com/problems/word-break-ii,999,315.5K,893.4K,"Facebook,Amazon,Bloomberg,ByteDance,Google,Microsoft","Dynamic Programming,Backtracking",3046,443,87,1,"[Word Break, /problems/word-break/, Medium], [Concatenated Words, /problems/concatenated-words/, Hard]","class Solution {
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        
    }
};","class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        
    }
}","class Solution(object):
    def wordBreak(self, s, wordDict):
        """"""
        :type s: str
        :type wordDict: List[str]
        :rtype: List[str]
        """"""
        ","class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** wordBreak(char * s, char ** wordDict, int wordDictSize, int* returnSize){

}","public class Solution {
    public IList<string> WordBreak(string s, IList<string> wordDict) {
        
    }
}","/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
    
};","# @param {String} s
# @param {String[]} word_dict
# @return {String[]}
def word_break(s, word_dict)
    
end","class Solution {
    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {
        
    }
}","func wordBreak(s string, wordDict []string) []string {
    
}","object Solution {
    def wordBreak(s: String, wordDict: List[String]): List[String] = {
        
    }
}","class Solution {
    fun wordBreak(s: String, wordDict: List<String>): List<String> {
        
    }
}","impl Solution {
    pub fn word_break(s: String, word_dict: Vec<String>) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String[] $wordDict
     * @return String[]
     */
    function wordBreak($s, $wordDict) {
        
    }
}","function wordBreak(s: string, wordDict: string[]): string[] {

};","(define/contract (word-break s wordDict)
  (-> string? (listof string?) (listof string?))

  )","-spec word_break(S :: unicode:unicode_binary(), WordDict :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].
word_break(S, WordDict) ->
  .","defmodule Solution do
  @spec word_break(s :: String.t, word_dict :: [String.t]) :: [String.t]
  def word_break(s, word_dict) do

  end
end","class Solution {
  List<String> wordBreak(String s, List<String> wordDict) {

  }
}",,,,word-break-ii
30,149,Max Points on a Line,"Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",0,Hard,/articles/max-points-on-a-line,17.6,61.7,https://leetcode.com/problems/max-points-on-a-line,776,177K,1M,"Apple,Google,LinkedIn,Amazon","Hash Table,Math",85,30,74,1,"[Line Reflection, /problems/line-reflection/, Medium]","class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        
    }
};","class Solution {
    public int maxPoints(int[][] points) {
        
    }
}","class Solution(object):
    def maxPoints(self, points):
        """"""
        :type points: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        ","int maxPoints(int** points, int pointsSize, int* pointsColSize){

}","public class Solution {
    public int MaxPoints(int[][] points) {
        
    }
}","/**
 * @param {number[][]} points
 * @return {number}
 */
var maxPoints = function(points) {
    
};","# @param {Integer[][]} points
# @return {Integer}
def max_points(points)
    
end","class Solution {
    func maxPoints(_ points: [[Int]]) -> Int {
        
    }
}","func maxPoints(points [][]int) int {
    
}","object Solution {
    def maxPoints(points: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun maxPoints(points: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn max_points(points: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $points
     * @return Integer
     */
    function maxPoints($points) {
        
    }
}","function maxPoints(points: number[][]): number {

};","(define/contract (max-points points)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec max_points(Points :: [[integer()]]) -> integer().
max_points(Points) ->
  .","defmodule Solution do
  @spec max_points(points :: [[integer]]) :: integer
  def max_points(points) do

  end
end","class Solution {
  int maxPoints(List<List<int>> points) {

  }
}",,,,max-points-on-a-line
31,154,Find Minimum in Rotated Sorted Array II,"Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:
`[4,5,6,7,0,1,4]` if it was rotated `4` times.
`[0,1,4,4,5,6,7]` if it was rotated `7` times.
Notice that rotating an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.
Given the sorted rotated array `nums` that may contain duplicates, return the minimum element of this array.",0,Hard,/articles/find-minimum-in-rotated-sorted-array-ii,42.1,24.4,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii,931,241.2K,572.8K,"Amazon,Google,Oracle","Array,Binary Search",1504,273,85,1,"[Find Minimum in Rotated Sorted Array, /problems/find-minimum-in-rotated-sorted-array/, Medium]","class Solution {
public:
    int findMin(vector<int>& nums) {
        
    }
};","class Solution {
    public int findMin(int[] nums) {
        
    }
}","class Solution(object):
    def findMin(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def findMin(self, nums: List[int]) -> int:
        ","int findMin(int* nums, int numsSize){

}","public class Solution {
    public int FindMin(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def find_min(nums)
    
end","class Solution {
    func findMin(_ nums: [Int]) -> Int {
        
    }
}","func findMin(nums []int) int {
    
}","object Solution {
    def findMin(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun findMin(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn find_min(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findMin($nums) {
        
    }
}","function findMin(nums: number[]): number {

};","(define/contract (find-min nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec find_min(Nums :: [integer()]) -> integer().
find_min(Nums) ->
  .","defmodule Solution do
  @spec find_min(nums :: [integer]) :: integer
  def find_min(nums) do

  end
end","class Solution {
  int findMin(List<int> nums) {

  }
}",,,,find-minimum-in-rotated-sorted-array-ii
32,164,Maximum Gap,"Given an integer array `nums`, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return `0`.",0,Hard,/articles/maximum-gap,37.1,34.2,https://leetcode.com/problems/maximum-gap,357,101K,272.3K,Amazon,Sort,1130,210,84,1,,"class Solution {
public:
    int maximumGap(vector<int>& nums) {
        
    }
};","class Solution {
    public int maximumGap(int[] nums) {
        
    }
}","class Solution(object):
    def maximumGap(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        ","int maximumGap(int* nums, int numsSize){

}","public class Solution {
    public int MaximumGap(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def maximum_gap(nums)
    
end","class Solution {
    func maximumGap(_ nums: [Int]) -> Int {
        
    }
}","func maximumGap(nums []int) int {
    
}","object Solution {
    def maximumGap(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maximumGap(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn maximum_gap(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maximumGap($nums) {
        
    }
}","function maximumGap(nums: number[]): number {

};","(define/contract (maximum-gap nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec maximum_gap(Nums :: [integer()]) -> integer().
maximum_gap(Nums) ->
  .","defmodule Solution do
  @spec maximum_gap(nums :: [integer]) :: integer
  def maximum_gap(nums) do

  end
end","class Solution {
  int maximumGap(List<int> nums) {

  }
}",,,,maximum-gap
33,174,Dungeon Game,"The demons had captured the princess and imprisoned her in the bottom-right corner of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through `dungeon` to rescue the princess.
The knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.
Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).
To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.
Return the knight's minimum initial health so that he can rescue the princess.
Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.",0,Hard,/articles/dungeon-game,33.4,19.7,https://leetcode.com/problems/dungeon-game,625,124.1K,371.5K,JPMorgan,"Binary Search,Dynamic Programming",2256,47,98,0,"[Unique Paths, /problems/unique-paths/, Medium], [Minimum Path Sum, /problems/minimum-path-sum/, Medium], [Cherry Pickup, /problems/cherry-pickup/, Hard]","class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        
    }
};","class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        
    }
}","class Solution(object):
    def calculateMinimumHP(self, dungeon):
        """"""
        :type dungeon: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        ","int calculateMinimumHP(int** dungeon, int dungeonSize, int* dungeonColSize){

}","public class Solution {
    public int CalculateMinimumHP(int[][] dungeon) {
        
    }
}","/**
 * @param {number[][]} dungeon
 * @return {number}
 */
var calculateMinimumHP = function(dungeon) {
    
};","# @param {Integer[][]} dungeon
# @return {Integer}
def calculate_minimum_hp(dungeon)
    
end","class Solution {
    func calculateMinimumHP(_ dungeon: [[Int]]) -> Int {
        
    }
}","func calculateMinimumHP(dungeon [][]int) int {
    
}","object Solution {
    def calculateMinimumHP(dungeon: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun calculateMinimumHP(dungeon: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn calculate_minimum_hp(dungeon: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $dungeon
     * @return Integer
     */
    function calculateMinimumHP($dungeon) {
        
    }
}","function calculateMinimumHP(dungeon: number[][]): number {

};","(define/contract (calculate-minimum-hp dungeon)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec calculate_minimum_hp(Dungeon :: [[integer()]]) -> integer().
calculate_minimum_hp(Dungeon) ->
  .","defmodule Solution do
  @spec calculate_minimum_hp(dungeon :: [[integer]]) :: integer
  def calculate_minimum_hp(dungeon) do

  end
end","class Solution {
  int calculateMinimumHP(List<List<int>> dungeon) {

  }
}",,,,dungeon-game
34,188,Best Time to Buy and Sell Stock IV,"You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.
Find the maximum profit you can achieve. You may complete at most `k` transactions.
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",0,Hard,/articles/best-time-to-buy-and-sell-stock-iv,30.0,46.3,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv,588,177.8K,592.5K,"Amazon,Google,Uber",Dynamic Programming,2362,133,95,1,"[Best Time to Buy and Sell Stock, /problems/best-time-to-buy-and-sell-stock/, Easy], [Best Time to Buy and Sell Stock II, /problems/best-time-to-buy-and-sell-stock-ii/, Easy], [Best Time to Buy and Sell Stock III, /problems/best-time-to-buy-and-sell-stock-iii/, Hard]","class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        
    }
};","class Solution {
    public int maxProfit(int k, int[] prices) {
        
    }
}","class Solution(object):
    def maxProfit(self, k, prices):
        """"""
        :type k: int
        :type prices: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        ","int maxProfit(int k, int* prices, int pricesSize){

}","public class Solution {
    public int MaxProfit(int k, int[] prices) {
        
    }
}","/**
 * @param {number} k
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(k, prices) {
    
};","# @param {Integer} k
# @param {Integer[]} prices
# @return {Integer}
def max_profit(k, prices)
    
end","class Solution {
    func maxProfit(_ k: Int, _ prices: [Int]) -> Int {
        
    }
}","func maxProfit(k int, prices []int) int {
    
}","object Solution {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxProfit(k: Int, prices: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_profit(k: i32, prices: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $k
     * @param Integer[] $prices
     * @return Integer
     */
    function maxProfit($k, $prices) {
        
    }
}","function maxProfit(k: number, prices: number[]): number {

};","(define/contract (max-profit k prices)
  (-> exact-integer? (listof exact-integer?) exact-integer?)

  )","-spec max_profit(K :: integer(), Prices :: [integer()]) -> integer().
max_profit(K, Prices) ->
  .","defmodule Solution do
  @spec max_profit(k :: integer, prices :: [integer]) :: integer
  def max_profit(k, prices) do

  end
end","class Solution {
  int maxProfit(int k, List<int> prices) {

  }
}",,,,best-time-to-buy-and-sell-stock-iv
35,212,Word Search II,"Given an `m x n` `board` of characters and a list of strings `words`, return all words on the board.
Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",0,Hard,/articles/word-search-ii,37.4,68.4,https://leetcode.com/problems/word-search-ii,999,291.9K,780K,"Amazon,Microsoft,Uber,Apple,Google,Facebook,Snapchat,Twitter","Backtracking,Trie",3594,142,96,1,"[Word Search, /problems/word-search/, Medium], [Unique Paths III, /problems/unique-paths-iii/, Hard]","class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        
    }
};","class Solution {
    public List<String> findWords(char[][] board, String[] words) {
        
    }
}","class Solution(object):
    def findWords(self, board, words):
        """"""
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """"""
        ","class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** findWords(char** board, int boardSize, int* boardColSize, char ** words, int wordsSize, int* returnSize){

}","public class Solution {
    public IList<string> FindWords(char[][] board, string[] words) {
        
    }
}","/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(board, words) {
    
};","# @param {Character[][]} board
# @param {String[]} words
# @return {String[]}
def find_words(board, words)
    
end","class Solution {
    func findWords(_ board: [[Character]], _ words: [String]) -> [String] {
        
    }
}","func findWords(board [][]byte, words []string) []string {
    
}","object Solution {
    def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
        
    }
}","class Solution {
    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {
        
    }
}","impl Solution {
    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String[][] $board
     * @param String[] $words
     * @return String[]
     */
    function findWords($board, $words) {
        
    }
}","function findWords(board: string[][], words: string[]): string[] {

};","(define/contract (find-words board words)
  (-> (listof (listof char?)) (listof string?) (listof string?))

  )","-spec find_words(Board :: [[char()]], Words :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].
find_words(Board, Words) ->
  .","defmodule Solution do
  @spec find_words(board :: [[char]], words :: [String.t]) :: [String.t]
  def find_words(board, words) do

  end
end","class Solution {
  List<String> findWords(List<List<String>> board, List<String> words) {

  }
}",,,,word-search-ii
36,214,Shortest Palindrome,"You are given a string `s`. You can convert `s` to a palindrome by adding characters in front of it.
Return the shortest palindrome you can find by performing this transformation.",0,Hard,/articles/shortest-palindrome,30.8,37.5,https://leetcode.com/problems/shortest-palindrome,508,114.1K,370.8K,Microsoft,String,1586,149,91,0,"[Longest Palindromic Substring, /problems/longest-palindromic-substring/, Medium], [Implement strStr(), /problems/implement-strstr/, Easy], [Palindrome Pairs, /problems/palindrome-pairs/, Hard]","class Solution {
public:
    string shortestPalindrome(string s) {
        
    }
};","class Solution {
    public String shortestPalindrome(String s) {
        
    }
}","class Solution(object):
    def shortestPalindrome(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        ","class Solution:
    def shortestPalindrome(self, s: str) -> str:
        ","char * shortestPalindrome(char * s){

}","public class Solution {
    public string ShortestPalindrome(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string}
 */
var shortestPalindrome = function(s) {
    
};","# @param {String} s
# @return {String}
def shortest_palindrome(s)
    
end","class Solution {
    func shortestPalindrome(_ s: String) -> String {
        
    }
}","func shortestPalindrome(s string) string {
    
}","object Solution {
    def shortestPalindrome(s: String): String = {
        
    }
}","class Solution {
    fun shortestPalindrome(s: String): String {
        
    }
}","impl Solution {
    pub fn shortest_palindrome(s: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String
     */
    function shortestPalindrome($s) {
        
    }
}","function shortestPalindrome(s: string): string {

};","(define/contract (shortest-palindrome s)
  (-> string? string?)

  )","-spec shortest_palindrome(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
shortest_palindrome(S) ->
  .","defmodule Solution do
  @spec shortest_palindrome(s :: String.t) :: String.t
  def shortest_palindrome(s) do

  end
end","class Solution {
  String shortestPalindrome(String s) {

  }
}",,,,shortest-palindrome
37,218,The Skyline Problem,"A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.
The geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:
`lefti` is the x coordinate of the left edge of the `ith` building.
`righti` is the x coordinate of the right edge of the `ith` building.
`heighti` is the height of the `ith` building.
You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.
The skyline should be represented as a list of ""key points"" sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.
Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`",0,Hard,/articles/skyline-problem,36.6,51.9,https://leetcode.com/problems/the-skyline-problem,659,167.7K,457.8K,"Microsoft,Amazon,Google,Twitter,Uber","Divide and Conquer,Heap,Binary Indexed Tree,Segment Tree,Line Sweep",2792,157,95,1,"[Falling Squares, /problems/falling-squares/, Hard]","class Solution {
public:
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        
    }
};","class Solution {
    public List<List<Integer>> getSkyline(int[][] buildings) {
        
    }
}","class Solution(object):
    def getSkyline(self, buildings):
        """"""
        :type buildings: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** getSkyline(int** buildings, int buildingsSize, int* buildingsColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public IList<IList<int>> GetSkyline(int[][] buildings) {
        
    }
}","/**
 * @param {number[][]} buildings
 * @return {number[][]}
 */
var getSkyline = function(buildings) {
    
};","# @param {Integer[][]} buildings
# @return {Integer[][]}
def get_skyline(buildings)
    
end","class Solution {
    func getSkyline(_ buildings: [[Int]]) -> [[Int]] {
        
    }
}","func getSkyline(buildings [][]int) [][]int {
    
}","object Solution {
    def getSkyline(buildings: Array[Array[Int]]): List[List[Int]] = {
        
    }
}","class Solution {
    fun getSkyline(buildings: Array<IntArray>): List<List<Int>> {
        
    }
}","impl Solution {
    pub fn get_skyline(buildings: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $buildings
     * @return Integer[][]
     */
    function getSkyline($buildings) {
        
    }
}","function getSkyline(buildings: number[][]): number[][] {

};",,"-spec get_skyline(Buildings :: [[integer()]]) -> [[integer()]].
get_skyline(Buildings) ->
  .","defmodule Solution do
  @spec get_skyline(buildings :: [[integer]]) :: [[integer]]
  def get_skyline(buildings) do

  end
end","class Solution {
  List<List<int>> getSkyline(List<List<int>> buildings) {

  }
}",,,,the-skyline-problem
38,224,Basic Calculator,"Given a string `s` representing an expression, implement a basic calculator to evaluate it.",0,Hard,/articles/basic-calculator,38.3,86.4,https://leetcode.com/problems/basic-calculator,659,204K,533.3K,"Amazon,Roblox,Facebook,Indeed,Karat,Microsoft,Google,ByteDance,Uber,Wish","Math,Stack",2131,177,92,1,"[Evaluate Reverse Polish Notation, /problems/evaluate-reverse-polish-notation/, Medium], [Basic Calculator II, /problems/basic-calculator-ii/, Medium], [Different Ways to Add Parentheses, /problems/different-ways-to-add-parentheses/, Medium], [Expression Add Operators, /problems/expression-add-operators/, Hard], [Basic Calculator III, /problems/basic-calculator-iii/, Hard]","class Solution {
public:
    int calculate(string s) {
        
    }
};","class Solution {
    public int calculate(String s) {
        
    }
}","class Solution(object):
    def calculate(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def calculate(self, s: str) -> int:
        ","int calculate(char * s){

}","public class Solution {
    public int Calculate(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
    
};","# @param {String} s
# @return {Integer}
def calculate(s)
    
end","class Solution {
    func calculate(_ s: String) -> Int {
        
    }
}","func calculate(s string) int {
    
}","object Solution {
    def calculate(s: String): Int = {
        
    }
}","class Solution {
    fun calculate(s: String): Int {
        
    }
}","impl Solution {
    pub fn calculate(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function calculate($s) {
        
    }
}","function calculate(s: string): number {

};","(define/contract (calculate s)
  (-> string? exact-integer?)

  )","-spec calculate(S :: unicode:unicode_binary()) -> integer().
calculate(S) ->
  .","defmodule Solution do
  @spec calculate(s :: String.t) :: integer
  def calculate(s) do

  end
end","class Solution {
  int calculate(String s) {

  }
}",,,,basic-calculator
39,233,Number of Digit One,"Given an integer `n`, count the total number of digit `1` appearing in all non-negative integers less than or equal to `n`.",0,Hard,/articles/number-of-digit-one,31.8,25.9,https://leetcode.com/problems/number-of-digit-one,295,52.8K,165.8K,Amazon,Math,388,730,35,1,"[Factorial Trailing Zeroes, /problems/factorial-trailing-zeroes/, Easy], [Digit Count in Range, /problems/digit-count-in-range/, Hard]","class Solution {
public:
    int countDigitOne(int n) {
        
    }
};","class Solution {
    public int countDigitOne(int n) {
        
    }
}","class Solution(object):
    def countDigitOne(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def countDigitOne(self, n: int) -> int:
        ","int countDigitOne(int n){

}","public class Solution {
    public int CountDigitOne(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var countDigitOne = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def count_digit_one(n)
    
end","class Solution {
    func countDigitOne(_ n: Int) -> Int {
        
    }
}","func countDigitOne(n int) int {
    
}","object Solution {
    def countDigitOne(n: Int): Int = {
        
    }
}","class Solution {
    fun countDigitOne(n: Int): Int {
        
    }
}","impl Solution {
    pub fn count_digit_one(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function countDigitOne($n) {
        
    }
}","function countDigitOne(n: number): number {

};","(define/contract (count-digit-one n)
  (-> exact-integer? exact-integer?)

  )","-spec count_digit_one(N :: integer()) -> integer().
count_digit_one(N) ->
  .","defmodule Solution do
  @spec count_digit_one(n :: integer) :: integer
  def count_digit_one(n) do

  end
end","class Solution {
  int countDigitOne(int n) {

  }
}",,,,number-of-digit-one
40,239,Sliding Window Maximum,"You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.
Return the max sliding window.",0,Hard,/articles/sliding-window-maximum,44.8,79.4,https://leetcode.com/problems/sliding-window-maximum,999,384.5K,858.9K,"Amazon,ByteDance,Dropbox,Facebook,Google,Citadel,Bloomberg,Microsoft,Akuna Capital,IBM,Twitter","Heap,Sliding Window,Dequeue",5504,228,96,1,"[Minimum Window Substring, /problems/minimum-window-substring/, Hard], [Min Stack, /problems/min-stack/, Easy], [Longest Substring with At Most Two Distinct Characters, /problems/longest-substring-with-at-most-two-distinct-characters/, Medium], [Paint House II, /problems/paint-house-ii/, Hard], [Jump Game VI, /problems/jump-game-vi/, Medium]","class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        
    }
}","class Solution(object):
    def maxSlidingWindow(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){

}","public class Solution {
    public int[] MaxSlidingWindow(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer[]}
def max_sliding_window(nums, k)
    
end","class Solution {
    func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {
        
    }
}","func maxSlidingWindow(nums []int, k int) []int {
    
}","object Solution {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        
    }
}","class Solution {
    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {
        
    }
}","impl Solution {
    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer[]
     */
    function maxSlidingWindow($nums, $k) {
        
    }
}","function maxSlidingWindow(nums: number[], k: number): number[] {

};","(define/contract (max-sliding-window nums k)
  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))

  )","-spec max_sliding_window(Nums :: [integer()], K :: integer()) -> [integer()].
max_sliding_window(Nums, K) ->
  .","defmodule Solution do
  @spec max_sliding_window(nums :: [integer], k :: integer) :: [integer]
  def max_sliding_window(nums, k) do

  end
end","class Solution {
  List<int> maxSlidingWindow(List<int> nums, int k) {

  }
}",,,,sliding-window-maximum
41,273,Integer to English Words,Convert a non-negative integer `num` to its English words representation.,0,Hard,/articles/integer-to-english-words,28.3,88.3,https://leetcode.com/problems/integer-to-english-words,826,229.9K,813K,"Facebook,Amazon,Microsoft,Palantir Technologies,Square,Adobe,Oracle","Math,String",1438,3588,29,1,"[Integer to Roman, /problems/integer-to-roman/, Medium]","class Solution {
public:
    string numberToWords(int num) {
        
    }
};","class Solution {
    public String numberToWords(int num) {
        
    }
}","class Solution(object):
    def numberToWords(self, num):
        """"""
        :type num: int
        :rtype: str
        """"""
        ","class Solution:
    def numberToWords(self, num: int) -> str:
        ","char * numberToWords(int num){

}","public class Solution {
    public string NumberToWords(int num) {
        
    }
}","/**
 * @param {number} num
 * @return {string}
 */
var numberToWords = function(num) {
    
};","# @param {Integer} num
# @return {String}
def number_to_words(num)
    
end","class Solution {
    func numberToWords(_ num: Int) -> String {
        
    }
}","func numberToWords(num int) string {
    
}","object Solution {
    def numberToWords(num: Int): String = {
        
    }
}","class Solution {
    fun numberToWords(num: Int): String {
        
    }
}","impl Solution {
    pub fn number_to_words(num: i32) -> String {
        
    }
}","class Solution {

    /**
     * @param Integer $num
     * @return String
     */
    function numberToWords($num) {
        
    }
}","function numberToWords(num: number): string {

};","(define/contract (number-to-words num)
  (-> exact-integer? string?)

  )","-spec number_to_words(Num :: integer()) -> unicode:unicode_binary().
number_to_words(Num) ->
  .","defmodule Solution do
  @spec number_to_words(num :: integer) :: String.t
  def number_to_words(num) do

  end
end","class Solution {
  String numberToWords(int num) {

  }
}",,,,integer-to-english-words
42,282,Expression Add Operators,"Given a string `num` that contains only digits and an integer `target`, return all possibilities to add the binary operators `'+'`, `'-'`, or `'*'` between the digits of `num` so that the resultant expression evaluates to the `target` value.",0,Hard,/articles/expression-add-operators,36.9,37.5,https://leetcode.com/problems/expression-add-operators,311,129.2K,350K,"Facebook,Citadel",Divide and Conquer,1622,272,86,1,"[Evaluate Reverse Polish Notation, /problems/evaluate-reverse-polish-notation/, Medium], [Basic Calculator, /problems/basic-calculator/, Hard], [Basic Calculator II, /problems/basic-calculator-ii/, Medium], [Different Ways to Add Parentheses, /problems/different-ways-to-add-parentheses/, Medium], [Target Sum, /problems/target-sum/, Medium]","class Solution {
public:
    vector<string> addOperators(string num, int target) {
        
    }
};","class Solution {
    public List<String> addOperators(String num, int target) {
        
    }
}","class Solution(object):
    def addOperators(self, num, target):
        """"""
        :type num: str
        :type target: int
        :rtype: List[str]
        """"""
        ","class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** addOperators(char * num, int target, int* returnSize){

}","public class Solution {
    public IList<string> AddOperators(string num, int target) {
        
    }
}","/**
 * @param {string} num
 * @param {number} target
 * @return {string[]}
 */
var addOperators = function(num, target) {
    
};","# @param {String} num
# @param {Integer} target
# @return {String[]}
def add_operators(num, target)
    
end","class Solution {
    func addOperators(_ num: String, _ target: Int) -> [String] {
        
    }
}","func addOperators(num string, target int) []string {
    
}","object Solution {
    def addOperators(num: String, target: Int): List[String] = {
        
    }
}","class Solution {
    fun addOperators(num: String, target: Int): List<String> {
        
    }
}","impl Solution {
    pub fn add_operators(num: String, target: i32) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String $num
     * @param Integer $target
     * @return String[]
     */
    function addOperators($num, $target) {
        
    }
}","function addOperators(num: string, target: number): string[] {

};","(define/contract (add-operators num target)
  (-> string? exact-integer? (listof string?))

  )","-spec add_operators(Num :: unicode:unicode_binary(), Target :: integer()) -> [unicode:unicode_binary()].
add_operators(Num, Target) ->
  .","defmodule Solution do
  @spec add_operators(num :: String.t, target :: integer) :: [String.t]
  def add_operators(num, target) do

  end
end","class Solution {
  List<String> addOperators(String num, int target) {

  }
}",,,,expression-add-operators
45,301,Remove Invalid Parentheses,"Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.
Return all the possible results. You may return the answer in any order.",0,Hard,/articles/remove-invalid-parentheses,44.8,63.4,https://leetcode.com/problems/remove-invalid-parentheses,541,260.4K,580.8K,"Facebook,Bloomberg,ByteDance,Amazon,Qualtrics","Depth-first Search,Breadth-first Search",3281,152,96,1,"[Valid Parentheses, /problems/valid-parentheses/, Easy]","class Solution {
public:
    vector<string> removeInvalidParentheses(string s) {
        
    }
};","class Solution {
    public List<String> removeInvalidParentheses(String s) {
        
    }
}","class Solution(object):
    def removeInvalidParentheses(self, s):
        """"""
        :type s: str
        :rtype: List[str]
        """"""
        ","class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** removeInvalidParentheses(char * s, int* returnSize){

}","public class Solution {
    public IList<string> RemoveInvalidParentheses(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string[]}
 */
var removeInvalidParentheses = function(s) {
    
};","# @param {String} s
# @return {String[]}
def remove_invalid_parentheses(s)
    
end","class Solution {
    func removeInvalidParentheses(_ s: String) -> [String] {
        
    }
}","func removeInvalidParentheses(s string) []string {
    
}","object Solution {
    def removeInvalidParentheses(s: String): List[String] = {
        
    }
}","class Solution {
    fun removeInvalidParentheses(s: String): List<String> {
        
    }
}","impl Solution {
    pub fn remove_invalid_parentheses(s: String) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String[]
     */
    function removeInvalidParentheses($s) {
        
    }
}","function removeInvalidParentheses(s: string): string[] {

};","(define/contract (remove-invalid-parentheses s)
  (-> string? (listof string?))

  )","-spec remove_invalid_parentheses(S :: unicode:unicode_binary()) -> [unicode:unicode_binary()].
remove_invalid_parentheses(S) ->
  .","defmodule Solution do
  @spec remove_invalid_parentheses(s :: String.t) :: [String.t]
  def remove_invalid_parentheses(s) do

  end
end","class Solution {
  List<String> removeInvalidParentheses(String s) {

  }
}",,,,remove-invalid-parentheses
46,312,Burst Balloons,"You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.
If you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.
Return the maximum coins you can collect by bursting the balloons wisely.",0,Hard,/articles/burst-balloons,53.9,58.7,https://leetcode.com/problems/burst-balloons,433,132.3K,245.4K,"Adobe,Bloomberg,Amazon,Google,Codenation","Divide and Conquer,Dynamic Programming",3483,106,97,1,"[Minimum Cost to Merge Stones, /problems/minimum-cost-to-merge-stones/, Hard]","class Solution {
public:
    int maxCoins(vector<int>& nums) {
        
    }
};","class Solution {
    public int maxCoins(int[] nums) {
        
    }
}","class Solution(object):
    def maxCoins(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        ","int maxCoins(int* nums, int numsSize){

}","public class Solution {
    public int MaxCoins(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maxCoins = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def max_coins(nums)
    
end","class Solution {
    func maxCoins(_ nums: [Int]) -> Int {
        
    }
}","func maxCoins(nums []int) int {
    
}","object Solution {
    def maxCoins(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxCoins(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_coins(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxCoins($nums) {
        
    }
}","function maxCoins(nums: number[]): number {

};","(define/contract (max-coins nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_coins(Nums :: [integer()]) -> integer().
max_coins(Nums) ->
  .","defmodule Solution do
  @spec max_coins(nums :: [integer]) :: integer
  def max_coins(nums) do

  end
end","class Solution {
  int maxCoins(List<int> nums) {

  }
}",,,,burst-balloons
47,315,Count of Smaller Numbers After Self,You are given an integer array `nums` and you have to return a new `counts` array. The `counts` array has the property where `counts[i]` is the number of smaller elements to the right of `nums[i]`.,0,Hard,,42.4,56.5,https://leetcode.com/problems/count-of-smaller-numbers-after-self,900,166.1K,391.9K,"Google,Amazon,Apple,Bloomberg","Binary Search,Divide and Conquer,Sort,Binary Indexed Tree,Segment Tree",3332,105,97,1,"[Count of Range Sum, /problems/count-of-range-sum/, Hard], [Queue Reconstruction by Height, /problems/queue-reconstruction-by-height/, Medium], [Reverse Pairs, /problems/reverse-pairs/, Hard], [How Many Numbers Are Smaller Than the Current Number, /problems/how-many-numbers-are-smaller-than-the-current-number/, Easy]","class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        
    }
};","class Solution {
    public List<Integer> countSmaller(int[] nums) {
        
    }
}","class Solution(object):
    def countSmaller(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* countSmaller(int* nums, int numsSize, int* returnSize){

}","public class Solution {
    public IList<int> CountSmaller(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer[]}
def count_smaller(nums)
    
end","class Solution {
    func countSmaller(_ nums: [Int]) -> [Int] {
        
    }
}","func countSmaller(nums []int) []int {
    
}","object Solution {
    def countSmaller(nums: Array[Int]): List[Int] = {
        
    }
}","class Solution {
    fun countSmaller(nums: IntArray): List<Int> {
        
    }
}","impl Solution {
    pub fn count_smaller(nums: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function countSmaller($nums) {
        
    }
}","function countSmaller(nums: number[]): number[] {

};","(define/contract (count-smaller nums)
  (-> (listof exact-integer?) (listof exact-integer?))

  )","-spec count_smaller(Nums :: [integer()]) -> [integer()].
count_smaller(Nums) ->
  .","defmodule Solution do
  @spec count_smaller(nums :: [integer]) :: [integer]
  def count_smaller(nums) do

  end
end","class Solution {
  List<int> countSmaller(List<int> nums) {

  }
}",,,,count-of-smaller-numbers-after-self
48,321,Create Maximum Number,"You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`.
Create the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved.
Return an array of the `k` digits representing the answer.",0,Hard,,27.6,28.6,https://leetcode.com/problems/create-maximum-number,146,43.5K,157.7K,Apple,"Dynamic Programming,Greedy",927,269,78,1,"[Remove K Digits, /problems/remove-k-digits/, Medium], [Maximum Swap, /problems/maximum-swap/, Medium]","class Solution {
public:
    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
        
    }
};","class Solution {
    public int[] maxNumber(int[] nums1, int[] nums2, int k) {
        
    }
}","class Solution(object):
    def maxNumber(self, nums1, nums2, k):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :type k: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* maxNumber(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize){

}","public class Solution {
    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[]}
 */
var maxNumber = function(nums1, nums2, k) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @param {Integer} k
# @return {Integer[]}
def max_number(nums1, nums2, k)
    
end","class Solution {
    func maxNumber(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> [Int] {
        
    }
}","func maxNumber(nums1 []int, nums2 []int, k int) []int {
    
}","object Solution {
    def maxNumber(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {
        
    }
}","class Solution {
    fun maxNumber(nums1: IntArray, nums2: IntArray, k: Int): IntArray {
        
    }
}","impl Solution {
    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @param Integer $k
     * @return Integer[]
     */
    function maxNumber($nums1, $nums2, $k) {
        
    }
}","function maxNumber(nums1: number[], nums2: number[], k: number): number[] {

};","(define/contract (max-number nums1 nums2 k)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? (listof exact-integer?))

  )","-spec max_number(Nums1 :: [integer()], Nums2 :: [integer()], K :: integer()) -> [integer()].
max_number(Nums1, Nums2, K) ->
  .","defmodule Solution do
  @spec max_number(nums1 :: [integer], nums2 :: [integer], k :: integer) :: [integer]
  def max_number(nums1, nums2, k) do

  end
end","class Solution {
  List<int> maxNumber(List<int> nums1, List<int> nums2, int k) {

  }
}",,,,create-maximum-number
49,327,Count of Range Sum,"Given an integer array `nums` and two integers `lower` and `upper`, return the number of range sums that lie in `[lower, upper]` inclusive.
Range sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.",0,Hard,,36.2,17.2,https://leetcode.com/problems/count-of-range-sum,219,49.6K,136.8K,"Amazon,Google","Binary Search,Divide and Conquer,Sort,Binary Indexed Tree,Segment Tree",1016,118,90,1,"[Count of Smaller Numbers After Self, /problems/count-of-smaller-numbers-after-self/, Hard], [Reverse Pairs, /problems/reverse-pairs/, Hard]","class Solution {
public:
    int countRangeSum(vector<int>& nums, int lower, int upper) {
        
    }
};","class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        
    }
}","class Solution(object):
    def countRangeSum(self, nums, lower, upper):
        """"""
        :type nums: List[int]
        :type lower: int
        :type upper: int
        :rtype: int
        """"""
        ","class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        ","int countRangeSum(int* nums, int numsSize, int lower, int upper){

}","public class Solution {
    public int CountRangeSum(int[] nums, int lower, int upper) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} lower
 * @param {number} upper
 * @return {number}
 */
var countRangeSum = function(nums, lower, upper) {
    
};","# @param {Integer[]} nums
# @param {Integer} lower
# @param {Integer} upper
# @return {Integer}
def count_range_sum(nums, lower, upper)
    
end","class Solution {
    func countRangeSum(_ nums: [Int], _ lower: Int, _ upper: Int) -> Int {
        
    }
}","func countRangeSum(nums []int, lower int, upper int) int {
    
}","object Solution {
    def countRangeSum(nums: Array[Int], lower: Int, upper: Int): Int = {
        
    }
}","class Solution {
    fun countRangeSum(nums: IntArray, lower: Int, upper: Int): Int {
        
    }
}","impl Solution {
    pub fn count_range_sum(nums: Vec<i32>, lower: i32, upper: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $lower
     * @param Integer $upper
     * @return Integer
     */
    function countRangeSum($nums, $lower, $upper) {
        
    }
}","function countRangeSum(nums: number[], lower: number, upper: number): number {

};","(define/contract (count-range-sum nums lower upper)
  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)

  )","-spec count_range_sum(Nums :: [integer()], Lower :: integer(), Upper :: integer()) -> integer().
count_range_sum(Nums, Lower, Upper) ->
  .","defmodule Solution do
  @spec count_range_sum(nums :: [integer], lower :: integer, upper :: integer) :: integer
  def count_range_sum(nums, lower, upper) do

  end
end","class Solution {
  int countRangeSum(List<int> nums, int lower, int upper) {

  }
}",,,,count-of-range-sum
50,329,Longest Increasing Path in a Matrix,"Given an `m x n` integers `matrix`, return the length of the longest increasing path in `matrix`.
From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",0,Hard,/articles/longest-increasing-path-in-a-matrix,45.4,59.6,https://leetcode.com/problems/longest-increasing-path-in-a-matrix,851,202.1K,445.6K,"Google,Facebook,Bloomberg,Amazon,ByteDance,DoorDash","Depth-first Search,Topological Sort,Memoization",2888,52,98,1,,"class Solution {
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        
    }
};","class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        
    }
}","class Solution(object):
    def longestIncreasingPath(self, matrix):
        """"""
        :type matrix: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        ","int longestIncreasingPath(int** matrix, int matrixSize, int* matrixColSize){

}","public class Solution {
    public int LongestIncreasingPath(int[][] matrix) {
        
    }
}","/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function(matrix) {
    
};","# @param {Integer[][]} matrix
# @return {Integer}
def longest_increasing_path(matrix)
    
end","class Solution {
    func longestIncreasingPath(_ matrix: [[Int]]) -> Int {
        
    }
}","func longestIncreasingPath(matrix [][]int) int {
    
}","object Solution {
    def longestIncreasingPath(matrix: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun longestIncreasingPath(matrix: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn longest_increasing_path(matrix: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $matrix
     * @return Integer
     */
    function longestIncreasingPath($matrix) {
        
    }
}","function longestIncreasingPath(matrix: number[][]): number {

};","(define/contract (longest-increasing-path matrix)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec longest_increasing_path(Matrix :: [[integer()]]) -> integer().
longest_increasing_path(Matrix) ->
  .","defmodule Solution do
  @spec longest_increasing_path(matrix :: [[integer]]) :: integer
  def longest_increasing_path(matrix) do

  end
end","class Solution {
  int longestIncreasingPath(List<List<int>> matrix) {

  }
}",,,,longest-increasing-path-in-a-matrix
51,330,Patching Array,"Given a sorted integer array `nums` and an integer `n`, add/patch elements to the array such that any number in the range `[1, n]` inclusive can be formed by the sum of some elements in the array.
Return the minimum number of patches required.",0,Hard,/articles/patching-array,35.1,12.1,https://leetcode.com/problems/patching-array,109,39.4K,112.2K,Google,Greedy,630,84,88,1,"[Maximum Number of Consecutive Values You Can Make, /problems/maximum-number-of-consecutive-values-you-can-make/, Medium]","class Solution {
public:
    int minPatches(vector<int>& nums, int n) {
        
    }
};","class Solution {
    public int minPatches(int[] nums, int n) {
        
    }
}","class Solution(object):
    def minPatches(self, nums, n):
        """"""
        :type nums: List[int]
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ","int minPatches(int* nums, int numsSize, int n){

}","public class Solution {
    public int MinPatches(int[] nums, int n) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number}
 */
var minPatches = function(nums, n) {
    
};","# @param {Integer[]} nums
# @param {Integer} n
# @return {Integer}
def min_patches(nums, n)
    
end","class Solution {
    func minPatches(_ nums: [Int], _ n: Int) -> Int {
        
    }
}","func minPatches(nums []int, n int) int {
    
}","object Solution {
    def minPatches(nums: Array[Int], n: Int): Int = {
        
    }
}","class Solution {
    fun minPatches(nums: IntArray, n: Int): Int {
        
    }
}","impl Solution {
    pub fn min_patches(nums: Vec<i32>, n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $n
     * @return Integer
     */
    function minPatches($nums, $n) {
        
    }
}","function minPatches(nums: number[], n: number): number {

};","(define/contract (min-patches nums n)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_patches(Nums :: [integer()], N :: integer()) -> integer().
min_patches(Nums, N) ->
  .","defmodule Solution do
  @spec min_patches(nums :: [integer], n :: integer) :: integer
  def min_patches(nums, n) do

  end
end","class Solution {
  int minPatches(List<int> nums, int n) {

  }
}",,,,patching-array
52,335,Self Crossing,"You are given an array of integers `distance`.
You start at point `(0,0)` on an X-Y plane and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.
Return `true` if your path crosses itself, and `false` if it does not.",0,Hard,,28.7,13.0,https://leetcode.com/problems/self-crossing,117,25.1K,87.2K,"Amazon,Google",Math,177,400,31,1,,"class Solution {
public:
    bool isSelfCrossing(vector<int>& distance) {
        
    }
};","class Solution {
    public boolean isSelfCrossing(int[] distance) {
        
    }
}","class Solution(object):
    def isSelfCrossing(self, distance):
        """"""
        :type distance: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def isSelfCrossing(self, distance: List[int]) -> bool:
        ","bool isSelfCrossing(int* distance, int distanceSize){

}","public class Solution {
    public bool IsSelfCrossing(int[] distance) {
        
    }
}","/**
 * @param {number[]} distance
 * @return {boolean}
 */
var isSelfCrossing = function(distance) {
    
};","# @param {Integer[]} distance
# @return {Boolean}
def is_self_crossing(distance)
    
end","class Solution {
    func isSelfCrossing(_ distance: [Int]) -> Bool {
        
    }
}","func isSelfCrossing(distance []int) bool {
    
}","object Solution {
    def isSelfCrossing(distance: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun isSelfCrossing(distance: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn is_self_crossing(distance: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $distance
     * @return Boolean
     */
    function isSelfCrossing($distance) {
        
    }
}","function isSelfCrossing(distance: number[]): boolean {

};","(define/contract (is-self-crossing distance)
  (-> (listof exact-integer?) boolean?)

  )","-spec is_self_crossing(Distance :: [integer()]) -> boolean().
is_self_crossing(Distance) ->
  .","defmodule Solution do
  @spec is_self_crossing(distance :: [integer]) :: boolean
  def is_self_crossing(distance) do

  end
end","class Solution {
  bool isSelfCrossing(List<int> distance) {

  }
}",,,,self-crossing
53,336,Palindrome Pairs,"Given a list of unique words, return all the pairs of the distinct indices `(i, j)` in the given list, so that the concatenation of the two words `words[i] + words[j]` is a palindrome.",0,Hard,/articles/palindrome-pairs,34.8,34.9,https://leetcode.com/problems/palindrome-pairs,372,114.6K,328.9K,"Airbnb,ByteDance,Facebook","Hash Table,String,Trie",1742,172,91,1,"[Longest Palindromic Substring, /problems/longest-palindromic-substring/, Medium], [Shortest Palindrome, /problems/shortest-palindrome/, Hard]","class Solution {
public:
    vector<vector<int>> palindromePairs(vector<string>& words) {
        
    }
};","class Solution {
    public List<List<Integer>> palindromePairs(String[] words) {
        
    }
}","class Solution(object):
    def palindromePairs(self, words):
        """"""
        :type words: List[str]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** palindromePairs(char ** words, int wordsSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public IList<IList<int>> PalindromePairs(string[] words) {
        
    }
}","/**
 * @param {string[]} words
 * @return {number[][]}
 */
var palindromePairs = function(words) {
    
};","# @param {String[]} words
# @return {Integer[][]}
def palindrome_pairs(words)
    
end","class Solution {
    func palindromePairs(_ words: [String]) -> [[Int]] {
        
    }
}","func palindromePairs(words []string) [][]int {
    
}","object Solution {
    def palindromePairs(words: Array[String]): List[List[Int]] = {
        
    }
}","class Solution {
    fun palindromePairs(words: Array<String>): List<List<Int>> {
        
    }
}","impl Solution {
    pub fn palindrome_pairs(words: Vec<String>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @return Integer[][]
     */
    function palindromePairs($words) {
        
    }
}","function palindromePairs(words: string[]): number[][] {

};","(define/contract (palindrome-pairs words)
  (-> (listof string?) (listof (listof exact-integer?)))

  )","-spec palindrome_pairs(Words :: [unicode:unicode_binary()]) -> [[integer()]].
palindrome_pairs(Words) ->
  .","defmodule Solution do
  @spec palindrome_pairs(words :: [String.t]) :: [[integer]]
  def palindrome_pairs(words) do

  end
end","class Solution {
  List<List<int>> palindromePairs(List<String> words) {

  }
}",,,,palindrome-pairs
55,354,Russian Doll Envelopes,"You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.
One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.
Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).
Note: You cannot rotate an envelope.",0,Hard,/articles/russian-doll-envelopes,37.7,20.9,https://leetcode.com/problems/russian-doll-envelopes,404,100.8K,267.4K,"Google,Amazon,ByteDance,Uber","Binary Search,Dynamic Programming",1968,58,97,1,"[Longest Increasing Subsequence, /problems/longest-increasing-subsequence/, Medium]","class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        
    }
};","class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        
    }
}","class Solution(object):
    def maxEnvelopes(self, envelopes):
        """"""
        :type envelopes: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        ","int maxEnvelopes(int** envelopes, int envelopesSize, int* envelopesColSize){

}","public class Solution {
    public int MaxEnvelopes(int[][] envelopes) {
        
    }
}","/**
 * @param {number[][]} envelopes
 * @return {number}
 */
var maxEnvelopes = function(envelopes) {
    
};","# @param {Integer[][]} envelopes
# @return {Integer}
def max_envelopes(envelopes)
    
end","class Solution {
    func maxEnvelopes(_ envelopes: [[Int]]) -> Int {
        
    }
}","func maxEnvelopes(envelopes [][]int) int {
    
}","object Solution {
    def maxEnvelopes(envelopes: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun maxEnvelopes(envelopes: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn max_envelopes(envelopes: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $envelopes
     * @return Integer
     */
    function maxEnvelopes($envelopes) {
        
    }
}","function maxEnvelopes(envelopes: number[][]): number {

};","(define/contract (max-envelopes envelopes)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec max_envelopes(Envelopes :: [[integer()]]) -> integer().
max_envelopes(Envelopes) ->
  .","defmodule Solution do
  @spec max_envelopes(envelopes :: [[integer]]) :: integer
  def max_envelopes(envelopes) do

  end
end","class Solution {
  int maxEnvelopes(List<List<int>> envelopes) {

  }
}",,,,russian-doll-envelopes
56,363,Max Sum of Rectangle No Larger Than K,"Given an `m x n` matrix `matrix` and an integer `k`, return the max sum of a rectangle in the matrix such that its sum is no larger than `k`.
It is guaranteed that there will be a rectangle with a sum no larger than `k`.",0,Hard,,38.5,63.2,https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k,169,53.8K,139.8K,Roblox,"Binary Search,Dynamic Programming,Queue",1093,80,93,0,,"class Solution {
public:
    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {
        
    }
};","class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        
    }
}","class Solution(object):
    def maxSumSubmatrix(self, matrix, k):
        """"""
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        ","int maxSumSubmatrix(int** matrix, int matrixSize, int* matrixColSize, int k){

}","public class Solution {
    public int MaxSumSubmatrix(int[][] matrix, int k) {
        
    }
}","/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
var maxSumSubmatrix = function(matrix, k) {
    
};","# @param {Integer[][]} matrix
# @param {Integer} k
# @return {Integer}
def max_sum_submatrix(matrix, k)
    
end","class Solution {
    func maxSumSubmatrix(_ matrix: [[Int]], _ k: Int) -> Int {
        
    }
}","func maxSumSubmatrix(matrix [][]int, k int) int {
    
}","object Solution {
    def maxSumSubmatrix(matrix: Array[Array[Int]], k: Int): Int = {
        
    }
}","class Solution {
    fun maxSumSubmatrix(matrix: Array<IntArray>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn max_sum_submatrix(matrix: Vec<Vec<i32>>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $matrix
     * @param Integer $k
     * @return Integer
     */
    function maxSumSubmatrix($matrix, $k) {
        
    }
}","function maxSumSubmatrix(matrix: number[][], k: number): number {

};","(define/contract (max-sum-submatrix matrix k)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec max_sum_submatrix(Matrix :: [[integer()]], K :: integer()) -> integer().
max_sum_submatrix(Matrix, K) ->
  .","defmodule Solution do
  @spec max_sum_submatrix(matrix :: [[integer]], k :: integer) :: integer
  def max_sum_submatrix(matrix, k) do

  end
end","class Solution {
  int maxSumSubmatrix(List<List<int>> matrix, int k) {

  }
}",,,,max-sum-of-rectangle-no-larger-than-k
57,391,Perfect Rectangle,"Given an array `rectangles` where `rectangles[i] = [xi, yi, ai, bi]` represents an axis-aligned rectangle. The bottom-left point of the rectangle is `(xi, yi)` and the top-right point of it is `(ai, bi)`.
Return `true` if all the rectangles together form an exact cover of a rectangular region.",0,Hard,,31.3,8.1,https://leetcode.com/problems/perfect-rectangle,140,29.5K,94.3K,Apple,Line Sweep,461,86,84,1,,"class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        
    }
};","class Solution {
    public boolean isRectangleCover(int[][] rectangles) {
        
    }
}","class Solution(object):
    def isRectangleCover(self, rectangles):
        """"""
        :type rectangles: List[List[int]]
        :rtype: bool
        """"""
        ","class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        ","bool isRectangleCover(int** rectangles, int rectanglesSize, int* rectanglesColSize){

}","public class Solution {
    public bool IsRectangleCover(int[][] rectangles) {
        
    }
}","/**
 * @param {number[][]} rectangles
 * @return {boolean}
 */
var isRectangleCover = function(rectangles) {
    
};","# @param {Integer[][]} rectangles
# @return {Boolean}
def is_rectangle_cover(rectangles)
    
end","class Solution {
    func isRectangleCover(_ rectangles: [[Int]]) -> Bool {
        
    }
}","func isRectangleCover(rectangles [][]int) bool {
    
}","object Solution {
    def isRectangleCover(rectangles: Array[Array[Int]]): Boolean = {
        
    }
}","class Solution {
    fun isRectangleCover(rectangles: Array<IntArray>): Boolean {
        
    }
}","impl Solution {
    pub fn is_rectangle_cover(rectangles: Vec<Vec<i32>>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $rectangles
     * @return Boolean
     */
    function isRectangleCover($rectangles) {
        
    }
}","function isRectangleCover(rectangles: number[][]): boolean {

};","(define/contract (is-rectangle-cover rectangles)
  (-> (listof (listof exact-integer?)) boolean?)

  )","-spec is_rectangle_cover(Rectangles :: [[integer()]]) -> boolean().
is_rectangle_cover(Rectangles) ->
  .","defmodule Solution do
  @spec is_rectangle_cover(rectangles :: [[integer]]) :: boolean
  def is_rectangle_cover(rectangles) do

  end
end","class Solution {
  bool isRectangleCover(List<List<int>> rectangles) {

  }
}",,,,perfect-rectangle
58,403,Frog Jump,"A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.
Given a list of `stones`' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.
If the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.",0,Hard,/articles/frog-jump,41.7,55.5,https://leetcode.com/problems/frog-jump,675,118.6K,284.4K,"Amazon,Microsoft,ByteDance,Google",Dynamic Programming,1497,130,92,1,,"class Solution {
public:
    bool canCross(vector<int>& stones) {
        
    }
};","class Solution {
    public boolean canCross(int[] stones) {
        
    }
}","class Solution(object):
    def canCross(self, stones):
        """"""
        :type stones: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def canCross(self, stones: List[int]) -> bool:
        ","bool canCross(int* stones, int stonesSize){

}","public class Solution {
    public bool CanCross(int[] stones) {
        
    }
}","/**
 * @param {number[]} stones
 * @return {boolean}
 */
var canCross = function(stones) {
    
};","# @param {Integer[]} stones
# @return {Boolean}
def can_cross(stones)
    
end","class Solution {
    func canCross(_ stones: [Int]) -> Bool {
        
    }
}","func canCross(stones []int) bool {
    
}","object Solution {
    def canCross(stones: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun canCross(stones: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn can_cross(stones: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $stones
     * @return Boolean
     */
    function canCross($stones) {
        
    }
}","function canCross(stones: number[]): boolean {

};","(define/contract (can-cross stones)
  (-> (listof exact-integer?) boolean?)

  )","-spec can_cross(Stones :: [integer()]) -> boolean().
can_cross(Stones) ->
  .","defmodule Solution do
  @spec can_cross(stones :: [integer]) :: boolean
  def can_cross(stones) do

  end
end","class Solution {
  bool canCross(List<int> stones) {

  }
}",,,,frog-jump
59,407,Trapping Rain Water II,"Given an `m x n` matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.",0,Hard,,44.5,36.3,https://leetcode.com/problems/trapping-rain-water-ii,196,52K,116.8K,"Google,Amazon","Heap,Breadth-first Search",1776,39,98,1,"[Trapping Rain Water, /problems/trapping-rain-water/, Hard]","class Solution {
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        
    }
};","class Solution {
    public int trapRainWater(int[][] heightMap) {
        
    }
}","class Solution(object):
    def trapRainWater(self, heightMap):
        """"""
        :type heightMap: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        ","int trapRainWater(int** heightMap, int heightMapSize, int* heightMapColSize){

}","public class Solution {
    public int TrapRainWater(int[][] heightMap) {
        
    }
}","/**
 * @param {number[][]} heightMap
 * @return {number}
 */
var trapRainWater = function(heightMap) {
    
};","# @param {Integer[][]} height_map
# @return {Integer}
def trap_rain_water(height_map)
    
end","class Solution {
    func trapRainWater(_ heightMap: [[Int]]) -> Int {
        
    }
}","func trapRainWater(heightMap [][]int) int {
    
}","object Solution {
    def trapRainWater(heightMap: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun trapRainWater(heightMap: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn trap_rain_water(height_map: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $heightMap
     * @return Integer
     */
    function trapRainWater($heightMap) {
        
    }
}","function trapRainWater(heightMap: number[][]): number {

};","(define/contract (trap-rain-water heightMap)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec trap_rain_water(HeightMap :: [[integer()]]) -> integer().
trap_rain_water(HeightMap) ->
  .","defmodule Solution do
  @spec trap_rain_water(height_map :: [[integer]]) :: integer
  def trap_rain_water(height_map) do

  end
end","class Solution {
  int trapRainWater(List<List<int>> heightMap) {

  }
}",,,,trapping-rain-water-ii
60,410,Split Array Largest Sum,"Given an array `nums` which consists of non-negative integers and an integer `m`, you can split the array into `m` non-empty continuous subarrays.
Write an algorithm to minimize the largest sum among these `m` subarrays.",0,Hard,/articles/split-array-largest-sum,46.6,38.9,https://leetcode.com/problems/split-array-largest-sum,437,118.5K,254K,"Amazon,Google","Binary Search,Dynamic Programming",2522,92,96,1,,"class Solution {
public:
    int splitArray(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int splitArray(int[] nums, int k) {
        
    }
}","class Solution(object):
    def splitArray(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def splitArray(self, nums: List[int], k: int) -> int:
        ","int splitArray(int* nums, int numsSize, int k){

}","public class Solution {
    public int SplitArray(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var splitArray = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def split_array(nums, k)
    
end","class Solution {
    func splitArray(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func splitArray(nums []int, k int) int {
    
}","object Solution {
    def splitArray(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun splitArray(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn split_array(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function splitArray($nums, $k) {
        
    }
}","function splitArray(nums: number[], k: number): number {

};","(define/contract (split-array nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec split_array(Nums :: [integer()], K :: integer()) -> integer().
split_array(Nums, K) ->
  .","defmodule Solution do
  @spec split_array(nums :: [integer], k :: integer) :: integer
  def split_array(nums, k) do

  end
end","class Solution {
  int splitArray(List<int> nums, int k) {

  }
}",,,,split-array-largest-sum
61,420,Strong Password Checker,"A password is considered strong if the below conditions are all met:
It has at least `6` characters and at most `20` characters.
It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.
It does not contain three repeating characters in a row (i.e., `""...aaa...""` is weak, but `""...aa...a...""` is strong, assuming other conditions are met).
Given a string `password`, return the minimum number of steps required to make `password` strong. if `password` is already strong, return `0`.
In one step, you can:
Insert one character to `password`,
Delete one character from `password`, or
Replace one character of `password` with another character.",0,Hard,,13.9,80.0,https://leetcode.com/problems/strong-password-checker,166,17.5K,126.1K,"Google,Oracle,Microsoft",,317,939,25,1,,"class Solution {
public:
    int strongPasswordChecker(string password) {
        
    }
};","class Solution {
    public int strongPasswordChecker(String password) {
        
    }
}","class Solution(object):
    def strongPasswordChecker(self, password):
        """"""
        :type password: str
        :rtype: int
        """"""
        ","class Solution:
    def strongPasswordChecker(self, password: str) -> int:
        ","int strongPasswordChecker(char * password){

}","public class Solution {
    public int StrongPasswordChecker(string password) {
        
    }
}","/**
 * @param {string} password
 * @return {number}
 */
var strongPasswordChecker = function(password) {
    
};","# @param {String} password
# @return {Integer}
def strong_password_checker(password)
    
end","class Solution {
    func strongPasswordChecker(_ password: String) -> Int {
        
    }
}","func strongPasswordChecker(password string) int {
    
}","object Solution {
    def strongPasswordChecker(password: String): Int = {
        
    }
}","class Solution {
    fun strongPasswordChecker(password: String): Int {
        
    }
}","impl Solution {
    pub fn strong_password_checker(password: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $password
     * @return Integer
     */
    function strongPasswordChecker($password) {
        
    }
}","function strongPasswordChecker(password: string): number {

};","(define/contract (strong-password-checker password)
  (-> string? exact-integer?)

  )","-spec strong_password_checker(Password :: unicode:unicode_binary()) -> integer().
strong_password_checker(Password) ->
  .","defmodule Solution do
  @spec strong_password_checker(password :: String.t) :: integer
  def strong_password_checker(password) do

  end
end","class Solution {
  int strongPasswordChecker(String password) {

  }
}",,,,strong-password-checker
62,440,K-th Smallest in Lexicographical Order,"Given integers `n` and `k`, find the lexicographically k-th smallest integer in the range from `1` to `n`.
Note: 1 ≤ k ≤ n ≤ 109.",0,Hard,,29.9,10.6,https://leetcode.com/problems/k-th-smallest-in-lexicographical-order,72,15K,50.2K,"ByteDance,Hulu",,415,60,87,0,,"class Solution {
public:
    int findKthNumber(int n, int k) {
        
    }
};","class Solution {
    public int findKthNumber(int n, int k) {
        
    }
}","class Solution(object):
    def findKthNumber(self, n, k):
        """"""
        :type n: int
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        ","int findKthNumber(int n, int k){

}","public class Solution {
    public int FindKthNumber(int n, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findKthNumber = function(n, k) {
    
};","# @param {Integer} n
# @param {Integer} k
# @return {Integer}
def find_kth_number(n, k)
    
end","class Solution {
    func findKthNumber(_ n: Int, _ k: Int) -> Int {
        
    }
}","func findKthNumber(n int, k int) int {
    
}","object Solution {
    def findKthNumber(n: Int, k: Int): Int = {
        
    }
}","class Solution {
    fun findKthNumber(n: Int, k: Int): Int {
        
    }
}","impl Solution {
    pub fn find_kth_number(n: i32, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $k
     * @return Integer
     */
    function findKthNumber($n, $k) {
        
    }
}","function findKthNumber(n: number, k: number): number {

};","(define/contract (find-kth-number n k)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec find_kth_number(N :: integer(), K :: integer()) -> integer().
find_kth_number(N, K) ->
  .","defmodule Solution do
  @spec find_kth_number(n :: integer, k :: integer) :: integer
  def find_kth_number(n, k) do

  end
end","class Solution {
  int findKthNumber(int n, int k) {

  }
}",,,,k-th-smallest-in-lexicographical-order
63,458,Poor Pigs,"There are `buckets` buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.
You can feed the pigs according to these steps:
Choose some live pigs to feed.
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.
Wait for `minutesToDie` minutes. You may not feed any other pigs during this time.
After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.
Repeat this process until you run out of time.
Given `buckets`, `minutesToDie`, and `minutesToTest`, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.",0,Hard,/articles/poor-pigs,54.6,14.0,https://leetcode.com/problems/poor-pigs,137,30.9K,56.5K,,,548,1035,35,0,,"class Solution {
public:
    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        
    }
};","class Solution {
    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        
    }
}","class Solution(object):
    def poorPigs(self, buckets, minutesToDie, minutesToTest):
        """"""
        :type buckets: int
        :type minutesToDie: int
        :type minutesToTest: int
        :rtype: int
        """"""
        ","class Solution:
    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
        ","int poorPigs(int buckets, int minutesToDie, int minutesToTest){

}","public class Solution {
    public int PoorPigs(int buckets, int minutesToDie, int minutesToTest) {
        
    }
}","/**
 * @param {number} buckets
 * @param {number} minutesToDie
 * @param {number} minutesToTest
 * @return {number}
 */
var poorPigs = function(buckets, minutesToDie, minutesToTest) {
    
};","# @param {Integer} buckets
# @param {Integer} minutes_to_die
# @param {Integer} minutes_to_test
# @return {Integer}
def poor_pigs(buckets, minutes_to_die, minutes_to_test)
    
end","class Solution {
    func poorPigs(_ buckets: Int, _ minutesToDie: Int, _ minutesToTest: Int) -> Int {
        
    }
}","func poorPigs(buckets int, minutesToDie int, minutesToTest int) int {
    
}","object Solution {
    def poorPigs(buckets: Int, minutesToDie: Int, minutesToTest: Int): Int = {
        
    }
}","class Solution {
    fun poorPigs(buckets: Int, minutesToDie: Int, minutesToTest: Int): Int {
        
    }
}","impl Solution {
    pub fn poor_pigs(buckets: i32, minutes_to_die: i32, minutes_to_test: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $buckets
     * @param Integer $minutesToDie
     * @param Integer $minutesToTest
     * @return Integer
     */
    function poorPigs($buckets, $minutesToDie, $minutesToTest) {
        
    }
}","function poorPigs(buckets: number, minutesToDie: number, minutesToTest: number): number {

};","(define/contract (poor-pigs buckets minutesToDie minutesToTest)
  (-> exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec poor_pigs(Buckets :: integer(), MinutesToDie :: integer(), MinutesToTest :: integer()) -> integer().
poor_pigs(Buckets, MinutesToDie, MinutesToTest) ->
  .","defmodule Solution do
  @spec poor_pigs(buckets :: integer, minutes_to_die :: integer, minutes_to_test :: integer) :: integer
  def poor_pigs(buckets, minutes_to_die, minutes_to_test) do

  end
end","class Solution {
  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {

  }
}",,,,poor-pigs
65,466,Count The Repetitions,"Define `S = [s,n]` as the string S which consists of n connected strings s. For example, `[""abc"", 3]` =""abcabcabc"".
On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.
You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where `S1=[s1,n1]` and `S2=[s2,n2]`. Find the maximum integer M such that `[S2,M]` can be obtained from `S1`.",0,Hard,/articles/count-the-repetitions,28.6,17.2,https://leetcode.com/problems/count-the-repetitions,73,12.3K,42.8K,Amazon,Dynamic Programming,218,200,52,1,,"class Solution {
public:
    int getMaxRepetitions(string s1, int n1, string s2, int n2) {
        
    }
};","class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        
    }
}","class Solution(object):
    def getMaxRepetitions(self, s1, n1, s2, n2):
        """"""
        :type s1: str
        :type n1: int
        :type s2: str
        :type n2: int
        :rtype: int
        """"""
        ","class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        ","int getMaxRepetitions(char * s1, int n1, char * s2, int n2){

}","public class Solution {
    public int GetMaxRepetitions(string s1, int n1, string s2, int n2) {
        
    }
}","/**
 * @param {string} s1
 * @param {number} n1
 * @param {string} s2
 * @param {number} n2
 * @return {number}
 */
var getMaxRepetitions = function(s1, n1, s2, n2) {
    
};","# @param {String} s1
# @param {Integer} n1
# @param {String} s2
# @param {Integer} n2
# @return {Integer}
def get_max_repetitions(s1, n1, s2, n2)
    
end","class Solution {
    func getMaxRepetitions(_ s1: String, _ n1: Int, _ s2: String, _ n2: Int) -> Int {
        
    }
}","func getMaxRepetitions(s1 string, n1 int, s2 string, n2 int) int {
    
}","object Solution {
    def getMaxRepetitions(s1: String, n1: Int, s2: String, n2: Int): Int = {
        
    }
}","class Solution {
    fun getMaxRepetitions(s1: String, n1: Int, s2: String, n2: Int): Int {
        
    }
}","impl Solution {
    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s1
     * @param Integer $n1
     * @param String $s2
     * @param Integer $n2
     * @return Integer
     */
    function getMaxRepetitions($s1, $n1, $s2, $n2) {
        
    }
}","function getMaxRepetitions(s1: string, n1: number, s2: string, n2: number): number {

};","(define/contract (get-max-repetitions s1 n1 s2 n2)
  (-> string? exact-integer? string? exact-integer? exact-integer?)

  )","-spec get_max_repetitions(S1 :: unicode:unicode_binary(), N1 :: integer(), S2 :: unicode:unicode_binary(), N2 :: integer()) -> integer().
get_max_repetitions(S1, N1, S2, N2) ->
  .","defmodule Solution do
  @spec get_max_repetitions(s1 :: String.t, n1 :: integer, s2 :: String.t, n2 :: integer) :: integer
  def get_max_repetitions(s1, n1, s2, n2) do

  end
end","class Solution {
  int getMaxRepetitions(String s1, int n1, String s2, int n2) {

  }
}",,,,count-the-repetitions
66,472,Concatenated Words,"Given an array of strings `words` (without duplicates), return all the concatenated words in the given list of `words`.
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.",0,Hard,,43.7,50.3,https://leetcode.com/problems/concatenated-words,471,90.3K,206.5K,Amazon,"Dynamic Programming,Depth-first Search,Trie",1133,146,89,1,"[Word Break II, /problems/word-break-ii/, Hard]","class Solution {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        
    }
};","class Solution {
    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        
    }
}","class Solution(object):
    def findAllConcatenatedWordsInADict(self, words):
        """"""
        :type words: List[str]
        :rtype: List[str]
        """"""
        ","class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** findAllConcatenatedWordsInADict(char ** words, int wordsSize, int* returnSize){

}","public class Solution {
    public IList<string> FindAllConcatenatedWordsInADict(string[] words) {
        
    }
}","/**
 * @param {string[]} words
 * @return {string[]}
 */
var findAllConcatenatedWordsInADict = function(words) {
    
};","# @param {String[]} words
# @return {String[]}
def find_all_concatenated_words_in_a_dict(words)
    
end","class Solution {
    func findAllConcatenatedWordsInADict(_ words: [String]) -> [String] {
        
    }
}","func findAllConcatenatedWordsInADict(words []string) []string {
    
}","object Solution {
    def findAllConcatenatedWordsInADict(words: Array[String]): List[String] = {
        
    }
}","class Solution {
    fun findAllConcatenatedWordsInADict(words: Array<String>): List<String> {
        
    }
}","impl Solution {
    pub fn find_all_concatenated_words_in_a_dict(words: Vec<String>) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @return String[]
     */
    function findAllConcatenatedWordsInADict($words) {
        
    }
}","function findAllConcatenatedWordsInADict(words: string[]): string[] {

};","(define/contract (find-all-concatenated-words-in-a-dict words)
  (-> (listof string?) (listof string?))

  )","-spec find_all_concatenated_words_in_a_dict(Words :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].
find_all_concatenated_words_in_a_dict(Words) ->
  .","defmodule Solution do
  @spec find_all_concatenated_words_in_a_dict(words :: [String.t]) :: [String.t]
  def find_all_concatenated_words_in_a_dict(words) do

  end
end","class Solution {
  List<String> findAllConcatenatedWordsInADict(List<String> words) {

  }
}",,,,concatenated-words
67,479,Largest Palindrome Product,"Find the largest palindrome made from the product of two n-digit numbers.
Since the result could be very large, you should return the largest palindrome mod 1337.",0,Hard,,29.7,43.0,https://leetcode.com/problems/largest-palindrome-product,83,18K,60.6K,Yahoo,,100,1372,7,0,,"class Solution {
public:
    int largestPalindrome(int n) {
        
    }
};","class Solution {
    public int largestPalindrome(int n) {
        
    }
}","class Solution(object):
    def largestPalindrome(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def largestPalindrome(self, n: int) -> int:
        ","int largestPalindrome(int n){

}","public class Solution {
    public int LargestPalindrome(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var largestPalindrome = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def largest_palindrome(n)
    
end","class Solution {
    func largestPalindrome(_ n: Int) -> Int {
        
    }
}","func largestPalindrome(n int) int {
    
}","object Solution {
    def largestPalindrome(n: Int): Int = {
        
    }
}","class Solution {
    fun largestPalindrome(n: Int): Int {
        
    }
}","impl Solution {
    pub fn largest_palindrome(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function largestPalindrome($n) {
        
    }
}","function largestPalindrome(n: number): number {

};","(define/contract (largest-palindrome n)
  (-> exact-integer? exact-integer?)

  )","-spec largest_palindrome(N :: integer()) -> integer().
largest_palindrome(N) ->
  .","defmodule Solution do
  @spec largest_palindrome(n :: integer) :: integer
  def largest_palindrome(n) do

  end
end","class Solution {
  int largestPalindrome(int n) {

  }
}",,,,largest-palindrome-product
68,480,Sliding Window Median,"Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.",0,Hard,/articles/sliding-window-median,38.9,53.2,https://leetcode.com/problems/sliding-window-median,435,73.5K,188.8K,"Facebook,Spotify,JPMorgan,Google,Amazon,Flipkart,Adobe",Sliding Window,1357,97,93,1,"[Find Median from Data Stream, /problems/find-median-from-data-stream/, Hard]","class Solution {
public:
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        
    }
}","class Solution(object):
    def medianSlidingWindow(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: List[float]
        """"""
        ","class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
double* medianSlidingWindow(int* nums, int numsSize, int k, int* returnSize){

}","public class Solution {
    public double[] MedianSlidingWindow(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var medianSlidingWindow = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Float[]}
def median_sliding_window(nums, k)
    
end","class Solution {
    func medianSlidingWindow(_ nums: [Int], _ k: Int) -> [Double] {
        
    }
}","func medianSlidingWindow(nums []int, k int) []float64 {
    
}","object Solution {
    def medianSlidingWindow(nums: Array[Int], k: Int): Array[Double] = {
        
    }
}","class Solution {
    fun medianSlidingWindow(nums: IntArray, k: Int): DoubleArray {
        
    }
}","impl Solution {
    pub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Float[]
     */
    function medianSlidingWindow($nums, $k) {
        
    }
}","function medianSlidingWindow(nums: number[], k: number): number[] {

};","(define/contract (median-sliding-window nums k)
  (-> (listof exact-integer?) exact-integer? (listof flonum?))

  )","-spec median_sliding_window(Nums :: [integer()], K :: integer()) -> [float()].
median_sliding_window(Nums, K) ->
  .","defmodule Solution do
  @spec median_sliding_window(nums :: [integer], k :: integer) :: [float]
  def median_sliding_window(nums, k) do

  end
end","class Solution {
  List<double> medianSlidingWindow(List<int> nums, int k) {

  }
}",,,,sliding-window-median
69,483,Smallest Good Base,"For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1.
Now given a string representing n, you should return the smallest good base of n in string format.",0,Hard,,36.3,0.0,https://leetcode.com/problems/smallest-good-base,55,14.3K,39.3K,Google,"Math,Binary Search",193,367,34,1,,"class Solution {
public:
    string smallestGoodBase(string n) {
        
    }
};","class Solution {
    public String smallestGoodBase(String n) {
        
    }
}","class Solution(object):
    def smallestGoodBase(self, n):
        """"""
        :type n: str
        :rtype: str
        """"""
        ","class Solution:
    def smallestGoodBase(self, n: str) -> str:
        ","char * smallestGoodBase(char * n){

}","public class Solution {
    public string SmallestGoodBase(string n) {
        
    }
}","/**
 * @param {string} n
 * @return {string}
 */
var smallestGoodBase = function(n) {
    
};","# @param {String} n
# @return {String}
def smallest_good_base(n)
    
end","class Solution {
    func smallestGoodBase(_ n: String) -> String {
        
    }
}","func smallestGoodBase(n string) string {
    
}","object Solution {
    def smallestGoodBase(n: String): String = {
        
    }
}","class Solution {
    fun smallestGoodBase(n: String): String {
        
    }
}","impl Solution {
    pub fn smallest_good_base(n: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $n
     * @return String
     */
    function smallestGoodBase($n) {
        
    }
}","function smallestGoodBase(n: string): string {

};","(define/contract (smallest-good-base n)
  (-> string? string?)

  )","-spec smallest_good_base(N :: unicode:unicode_binary()) -> unicode:unicode_binary().
smallest_good_base(N) ->
  .","defmodule Solution do
  @spec smallest_good_base(n :: String.t) :: String.t
  def smallest_good_base(n) do

  end
end","class Solution {
  String smallestGoodBase(String n) {

  }
}",,,,smallest-good-base
70,488,Zuma Game,"Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.
Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.
Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.",0,Hard,,38.2,42.5,https://leetcode.com/problems/zuma-game,143,16.5K,43.2K,"Salesforce,Bloomberg",Depth-first Search,277,301,48,0,,"class Solution {
public:
    int findMinStep(string board, string hand) {
        
    }
};","class Solution {
    public int findMinStep(String board, String hand) {
        
    }
}","class Solution(object):
    def findMinStep(self, board, hand):
        """"""
        :type board: str
        :type hand: str
        :rtype: int
        """"""
        ","class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        ","int findMinStep(char * board, char * hand){

}","public class Solution {
    public int FindMinStep(string board, string hand) {
        
    }
}","/**
 * @param {string} board
 * @param {string} hand
 * @return {number}
 */
var findMinStep = function(board, hand) {
    
};","# @param {String} board
# @param {String} hand
# @return {Integer}
def find_min_step(board, hand)
    
end","class Solution {
    func findMinStep(_ board: String, _ hand: String) -> Int {
        
    }
}","func findMinStep(board string, hand string) int {
    
}","object Solution {
    def findMinStep(board: String, hand: String): Int = {
        
    }
}","class Solution {
    fun findMinStep(board: String, hand: String): Int {
        
    }
}","impl Solution {
    pub fn find_min_step(board: String, hand: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $board
     * @param String $hand
     * @return Integer
     */
    function findMinStep($board, $hand) {
        
    }
}","function findMinStep(board: string, hand: string): number {

};","(define/contract (find-min-step board hand)
  (-> string? string? exact-integer?)

  )","-spec find_min_step(Board :: unicode:unicode_binary(), Hand :: unicode:unicode_binary()) -> integer().
find_min_step(Board, Hand) ->
  .","defmodule Solution do
  @spec find_min_step(board :: String.t, hand :: String.t) :: integer
  def find_min_step(board, hand) do

  end
end","class Solution {
  int findMinStep(String board, String hand) {

  }
}",,,,zuma-game
71,493,Reverse Pairs,"Given an array `nums`, we call `(i, j)` an important reverse pair if `i < j` and `nums[i] > 2*nums[j]`.
You need to return the number of important reverse pairs in the given array.",0,Hard,/articles/reverse-pairs,27.1,51.0,https://leetcode.com/problems/reverse-pairs,291,53.2K,196K,"ByteDance,Amazon,Google","Binary Search,Divide and Conquer,Sort,Binary Indexed Tree,Segment Tree",1330,140,90,1,"[Count of Smaller Numbers After Self, /problems/count-of-smaller-numbers-after-self/, Hard], [Count of Range Sum, /problems/count-of-range-sum/, Hard]","class Solution {
public:
    int reversePairs(vector<int>& nums) {
        
    }
};","class Solution {
    public int reversePairs(int[] nums) {
        
    }
}","class Solution(object):
    def reversePairs(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        ","int reversePairs(int* nums, int numsSize){

}","public class Solution {
    public int ReversePairs(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var reversePairs = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def reverse_pairs(nums)
    
end","class Solution {
    func reversePairs(_ nums: [Int]) -> Int {
        
    }
}","func reversePairs(nums []int) int {
    
}","object Solution {
    def reversePairs(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun reversePairs(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn reverse_pairs(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function reversePairs($nums) {
        
    }
}","function reversePairs(nums: number[]): number {

};","(define/contract (reverse-pairs nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec reverse_pairs(Nums :: [integer()]) -> integer().
reverse_pairs(Nums) ->
  .","defmodule Solution do
  @spec reverse_pairs(nums :: [integer]) :: integer
  def reverse_pairs(nums) do

  end
end","class Solution {
  int reversePairs(List<int> nums) {

  }
}",,,,reverse-pairs
72,502,IPO,"Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.
You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.
To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.",0,Hard,/articles/ipo,41.8,23.1,https://leetcode.com/problems/ipo,177,22.6K,53.9K,Amazon,"Heap,Greedy",502,49,91,1,,"class Solution {
public:
    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
        
    }
};","class Solution {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        
    }
}","class Solution(object):
    def findMaximizedCapital(self, k, w, profits, capital):
        """"""
        :type k: int
        :type w: int
        :type profits: List[int]
        :type capital: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:
        ","int findMaximizedCapital(int k, int w, int* profits, int profitsSize, int* capital, int capitalSize){

}","public class Solution {
    public int FindMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        
    }
}","/**
 * @param {number} k
 * @param {number} w
 * @param {number[]} profits
 * @param {number[]} capital
 * @return {number}
 */
var findMaximizedCapital = function(k, w, profits, capital) {
    
};","# @param {Integer} k
# @param {Integer} w
# @param {Integer[]} profits
# @param {Integer[]} capital
# @return {Integer}
def find_maximized_capital(k, w, profits, capital)
    
end","class Solution {
    func findMaximizedCapital(_ k: Int, _ w: Int, _ profits: [Int], _ capital: [Int]) -> Int {
        
    }
}","func findMaximizedCapital(k int, w int, profits []int, capital []int) int {
    
}","object Solution {
    def findMaximizedCapital(k: Int, w: Int, profits: Array[Int], capital: Array[Int]): Int = {
        
    }
}","class Solution {
    fun findMaximizedCapital(k: Int, w: Int, profits: IntArray, capital: IntArray): Int {
        
    }
}","impl Solution {
    pub fn find_maximized_capital(k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $k
     * @param Integer $w
     * @param Integer[] $profits
     * @param Integer[] $capital
     * @return Integer
     */
    function findMaximizedCapital($k, $w, $profits, $capital) {
        
    }
}","function findMaximizedCapital(k: number, w: number, profits: number[], capital: number[]): number {

};","(define/contract (find-maximized-capital k w profits capital)
  (-> exact-integer? exact-integer? (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec find_maximized_capital(K :: integer(), W :: integer(), Profits :: [integer()], Capital :: [integer()]) -> integer().
find_maximized_capital(K, W, Profits, Capital) ->
  .","defmodule Solution do
  @spec find_maximized_capital(k :: integer, w :: integer, profits :: [integer], capital :: [integer]) :: integer
  def find_maximized_capital(k, w, profits, capital) do

  end
end","class Solution {
  int findMaximizedCapital(int k, int w, List<int> profits, List<int> capital) {

  }
}",,,,ipo
73,514,Freedom Trail,"In the video game Fallout 4, the quest ""Road to Freedom"" requires players to reach a metal dial called the ""Freedom Trail Ring"", and use the dial to spell a specific keyword in order to open the door.
Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword.
Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button.
At the stage of rotating the ring to spell the key character key[i]:
You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i].
If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.",0,Hard,,45.0,0.0,https://leetcode.com/problems/freedom-trail,187,22.4K,49.7K,DE Shaw,"Divide and Conquer,Dynamic Programming,Depth-first Search",522,27,95,0,,"class Solution {
public:
    int findRotateSteps(string ring, string key) {
        
    }
};","class Solution {
    public int findRotateSteps(String ring, String key) {
        
    }
}","class Solution(object):
    def findRotateSteps(self, ring, key):
        """"""
        :type ring: str
        :type key: str
        :rtype: int
        """"""
        ","class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        ","int findRotateSteps(char * ring, char * key){

}","public class Solution {
    public int FindRotateSteps(string ring, string key) {
        
    }
}","/**
 * @param {string} ring
 * @param {string} key
 * @return {number}
 */
var findRotateSteps = function(ring, key) {
    
};","# @param {String} ring
# @param {String} key
# @return {Integer}
def find_rotate_steps(ring, key)
    
end","class Solution {
    func findRotateSteps(_ ring: String, _ key: String) -> Int {
        
    }
}","func findRotateSteps(ring string, key string) int {
    
}","object Solution {
    def findRotateSteps(ring: String, key: String): Int = {
        
    }
}","class Solution {
    fun findRotateSteps(ring: String, key: String): Int {
        
    }
}","impl Solution {
    pub fn find_rotate_steps(ring: String, key: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $ring
     * @param String $key
     * @return Integer
     */
    function findRotateSteps($ring, $key) {
        
    }
}","function findRotateSteps(ring: string, key: string): number {

};","(define/contract (find-rotate-steps ring key)
  (-> string? string? exact-integer?)

  )","-spec find_rotate_steps(Ring :: unicode:unicode_binary(), Key :: unicode:unicode_binary()) -> integer().
find_rotate_steps(Ring, Key) ->
  .","defmodule Solution do
  @spec find_rotate_steps(ring :: String.t, key :: String.t) :: integer
  def find_rotate_steps(ring, key) do

  end
end","class Solution {
  int findRotateSteps(String ring, String key) {

  }
}",,,,freedom-trail
74,517,Super Washing Machines,"You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.
For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .
Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.",0,Hard,/articles/super-washing-machines,38.7,9.6,https://leetcode.com/problems/super-washing-machines,85,18.8K,48.6K,Amazon,"Math,Dynamic Programming",405,163,71,1,,"class Solution {
public:
    int findMinMoves(vector<int>& machines) {
        
    }
};","class Solution {
    public int findMinMoves(int[] machines) {
        
    }
}","class Solution(object):
    def findMinMoves(self, machines):
        """"""
        :type machines: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def findMinMoves(self, machines: List[int]) -> int:
        ","int findMinMoves(int* machines, int machinesSize){

}","public class Solution {
    public int FindMinMoves(int[] machines) {
        
    }
}","/**
 * @param {number[]} machines
 * @return {number}
 */
var findMinMoves = function(machines) {
    
};","# @param {Integer[]} machines
# @return {Integer}
def find_min_moves(machines)
    
end","class Solution {
    func findMinMoves(_ machines: [Int]) -> Int {
        
    }
}","func findMinMoves(machines []int) int {
    
}","object Solution {
    def findMinMoves(machines: Array[Int]): Int = {
        
    }
}","class Solution {
    fun findMinMoves(machines: IntArray): Int {
        
    }
}","impl Solution {
    pub fn find_min_moves(machines: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $machines
     * @return Integer
     */
    function findMinMoves($machines) {
        
    }
}","function findMinMoves(machines: number[]): number {

};","(define/contract (find-min-moves machines)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec find_min_moves(Machines :: [integer()]) -> integer().
find_min_moves(Machines) ->
  .","defmodule Solution do
  @spec find_min_moves(machines :: [integer]) :: integer
  def find_min_moves(machines) do

  end
end","class Solution {
  int findMinMoves(List<int> machines) {

  }
}",,,,super-washing-machines
75,546,Remove Boxes,"You are given several `boxes` with different colors represented by different positive numbers.
You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of `k` boxes, `k >= 1`), remove them and get `k * k` points.
Return the maximum points you can get.",0,Hard,/articles/remove-boxes,44.1,11.7,https://leetcode.com/problems/remove-boxes,75,18.7K,42.5K,"Apple,Amazon","Dynamic Programming,Depth-first Search",847,58,94,1,"[Strange Printer, /problems/strange-printer/, Hard]","class Solution {
public:
    int removeBoxes(vector<int>& boxes) {
        
    }
};","class Solution {
    public int removeBoxes(int[] boxes) {
        
    }
}","class Solution(object):
    def removeBoxes(self, boxes):
        """"""
        :type boxes: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:
        ","int removeBoxes(int* boxes, int boxesSize){

}","public class Solution {
    public int RemoveBoxes(int[] boxes) {
        
    }
}","/**
 * @param {number[]} boxes
 * @return {number}
 */
var removeBoxes = function(boxes) {
    
};","# @param {Integer[]} boxes
# @return {Integer}
def remove_boxes(boxes)
    
end","class Solution {
    func removeBoxes(_ boxes: [Int]) -> Int {
        
    }
}","func removeBoxes(boxes []int) int {
    
}","object Solution {
    def removeBoxes(boxes: Array[Int]): Int = {
        
    }
}","class Solution {
    fun removeBoxes(boxes: IntArray): Int {
        
    }
}","impl Solution {
    pub fn remove_boxes(boxes: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $boxes
     * @return Integer
     */
    function removeBoxes($boxes) {
        
    }
}","function removeBoxes(boxes: number[]): number {

};","(define/contract (remove-boxes boxes)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec remove_boxes(Boxes :: [integer()]) -> integer().
remove_boxes(Boxes) ->
  .","defmodule Solution do
  @spec remove_boxes(boxes :: [integer]) :: integer
  def remove_boxes(boxes) do

  end
end","class Solution {
  int removeBoxes(List<int> boxes) {

  }
}",,,,remove-boxes
76,552,Student Attendance Record II,"An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:
`'A'`: Absent.
`'L'`: Late.
`'P'`: Present.
Any student is eligible for an attendance award if they meet both of the following criteria:
The student was absent (`'A'`) for strictly fewer than 2 days total.
The student was never late (`'L'`) for 3 or more consecutive days.
Given an integer `n`, return the number of possible attendance records of length `n` that make a student eligible for an attendance award. The answer may be very large, so return it modulo `109 + 7`.",0,Hard,/articles/student-attendance-record-ii,37.7,25.9,https://leetcode.com/problems/student-attendance-record-ii,208,29.8K,79K,Google,Dynamic Programming,719,129,85,1,"[Student Attendance Record I, /problems/student-attendance-record-i/, Easy]","class Solution {
public:
    int checkRecord(int n) {
        
    }
};","class Solution {
    public int checkRecord(int n) {
        
    }
}","class Solution(object):
    def checkRecord(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def checkRecord(self, n: int) -> int:
        ","int checkRecord(int n){

}","public class Solution {
    public int CheckRecord(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var checkRecord = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def check_record(n)
    
end","class Solution {
    func checkRecord(_ n: Int) -> Int {
        
    }
}","func checkRecord(n int) int {
    
}","object Solution {
    def checkRecord(n: Int): Int = {
        
    }
}","class Solution {
    fun checkRecord(n: Int): Int {
        
    }
}","impl Solution {
    pub fn check_record(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function checkRecord($n) {
        
    }
}","function checkRecord(n: number): number {

};","(define/contract (check-record n)
  (-> exact-integer? exact-integer?)

  )","-spec check_record(N :: integer()) -> integer().
check_record(N) ->
  .","defmodule Solution do
  @spec check_record(n :: integer) :: integer
  def check_record(n) do

  end
end","class Solution {
  int checkRecord(int n) {

  }
}",,,,student-attendance-record-ii
77,564,Find the Closest Palindrome,"Given an integer n, find the closest integer (not including itself), which is a palindrome.
The 'closest' is defined as absolute difference minimized between two integers.",0,Hard,/articles/find-the-closest-palindrome,20.3,57.4,https://leetcode.com/problems/find-the-closest-palindrome,169,25.3K,124.5K,"Microsoft,Amazon",String,352,967,27,1,,"class Solution {
public:
    string nearestPalindromic(string n) {
        
    }
};","class Solution {
    public String nearestPalindromic(String n) {
        
    }
}","class Solution(object):
    def nearestPalindromic(self, n):
        """"""
        :type n: str
        :rtype: str
        """"""
        ","class Solution:
    def nearestPalindromic(self, n: str) -> str:
        ","char * nearestPalindromic(char * n){

}","public class Solution {
    public string NearestPalindromic(string n) {
        
    }
}","/**
 * @param {string} n
 * @return {string}
 */
var nearestPalindromic = function(n) {
    
};","# @param {String} n
# @return {String}
def nearest_palindromic(n)
    
end","class Solution {
    func nearestPalindromic(_ n: String) -> String {
        
    }
}","func nearestPalindromic(n string) string {
    
}","object Solution {
    def nearestPalindromic(n: String): String = {
        
    }
}","class Solution {
    fun nearestPalindromic(n: String): String {
        
    }
}","impl Solution {
    pub fn nearest_palindromic(n: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $n
     * @return String
     */
    function nearestPalindromic($n) {
        
    }
}","function nearestPalindromic(n: string): string {

};","(define/contract (nearest-palindromic n)
  (-> string? string?)

  )","-spec nearest_palindromic(N :: unicode:unicode_binary()) -> unicode:unicode_binary().
nearest_palindromic(N) ->
  .","defmodule Solution do
  @spec nearest_palindromic(n :: String.t) :: String.t
  def nearest_palindromic(n) do

  end
end","class Solution {
  String nearestPalindromic(String n) {

  }
}",,,,find-the-closest-palindrome
78,587,Erect the Fence,"There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.",0,Hard,/articles/erect-the-fence,36.6,6.8,https://leetcode.com/problems/erect-the-fence,74,10.9K,29.7K,Google,Geometry,284,198,59,1,,"class Solution {
public:
    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
        
    }
};","class Solution {
    public int[][] outerTrees(int[][] trees) {
        
    }
}","class Solution(object):
    def outerTrees(self, trees):
        """"""
        :type trees: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** outerTrees(int** trees, int treesSize, int* treesColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public int[][] OuterTrees(int[][] trees) {
        
    }
}","/**
 * @param {number[][]} trees
 * @return {number[][]}
 */
var outerTrees = function(trees) {
    
};","# @param {Integer[][]} trees
# @return {Integer[][]}
def outer_trees(trees)
    
end","class Solution {
    func outerTrees(_ trees: [[Int]]) -> [[Int]] {
        
    }
}","func outerTrees(trees [][]int) [][]int {
    
}","object Solution {
    def outerTrees(trees: Array[Array[Int]]): Array[Array[Int]] = {
        
    }
}","class Solution {
    fun outerTrees(trees: Array<IntArray>): Array<IntArray> {
        
    }
}","impl Solution {
    pub fn outer_trees(trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $trees
     * @return Integer[][]
     */
    function outerTrees($trees) {
        
    }
}","function outerTrees(trees: number[][]): number[][] {

};","(define/contract (outer-trees trees)
  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))

  )","-spec outer_trees(Trees :: [[integer()]]) -> [[integer()]].
outer_trees(Trees) ->
  .","defmodule Solution do
  @spec outer_trees(trees :: [[integer]]) :: [[integer]]
  def outer_trees(trees) do

  end
end","class Solution {
  List<List<int>> outerTrees(List<List<int>> trees) {

  }
}",,,,erect-the-fence
79,591,Tag Validator,"Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:
The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.
A closed tag (not necessarily valid) has exactly the following format : `<TAG_NAME>TAG_CONTENT</TAG_NAME>`. Among them, `<TAG_NAME>` is the start tag, and `</TAG_NAME>` is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.
A valid `TAG_NAME` only contain upper-case letters, and has length in range [1,9]. Otherwise, the `TAG_NAME` is invalid.
A valid `TAG_CONTENT` may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the `TAG_CONTENT` is invalid.
A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.
A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or `</`, all the subsequent characters until the next `>` should be parsed as TAG_NAME  (not necessarily valid).
The cdata has the following format : `<![CDATA[CDATA_CONTENT]]>`. The range of `CDATA_CONTENT` is defined as the characters between `<![CDATA[` and the first subsequent `]]>`.
`CDATA_CONTENT` may contain any characters. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.",0,Hard,/articles/tag-validator,34.8,15.9,https://leetcode.com/problems/tag-validator,66,8.8K,25.1K,Microsoft,"String,Stack",102,458,18,0,"[Add Bold Tag in String, /problems/add-bold-tag-in-string/, Medium]","class Solution {
public:
    bool isValid(string code) {
        
    }
};","class Solution {
    public boolean isValid(String code) {
        
    }
}","class Solution(object):
    def isValid(self, code):
        """"""
        :type code: str
        :rtype: bool
        """"""
        ","class Solution:
    def isValid(self, code: str) -> bool:
        ","bool isValid(char * code){

}","public class Solution {
    public bool IsValid(string code) {
        
    }
}","/**
 * @param {string} code
 * @return {boolean}
 */
var isValid = function(code) {
    
};","# @param {String} code
# @return {Boolean}
def is_valid(code)
    
end","class Solution {
    func isValid(_ code: String) -> Bool {
        
    }
}","func isValid(code string) bool {
    
}","object Solution {
    def isValid(code: String): Boolean = {
        
    }
}","class Solution {
    fun isValid(code: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_valid(code: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $code
     * @return Boolean
     */
    function isValid($code) {
        
    }
}","function isValid(code: string): boolean {

};","(define/contract (is-valid code)
  (-> string? boolean?)

  )","-spec is_valid(Code :: unicode:unicode_binary()) -> boolean().
is_valid(Code) ->
  .","defmodule Solution do
  @spec is_valid(code :: String.t) :: boolean
  def is_valid(code) do

  end
end","class Solution {
  bool isValid(String code) {

  }
}",,,,tag-validator
80,600,Non-negative Integers without Consecutive Ones,"Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.",0,Hard,/articles/non-negative-integers-without-consecutive-ones,34.3,6.0,https://leetcode.com/problems/non-negative-integers-without-consecutive-ones,111,14.6K,42.4K,Pocket Gems,Dynamic Programming,528,77,87,0,"[House Robber, /problems/house-robber/, Medium], [House Robber II, /problems/house-robber-ii/, Medium], [Ones and Zeroes, /problems/ones-and-zeroes/, Medium]","class Solution {
public:
    int findIntegers(int n) {
        
    }
};","class Solution {
    public int findIntegers(int n) {
        
    }
}","class Solution(object):
    def findIntegers(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def findIntegers(self, n: int) -> int:
        ","int findIntegers(int n){

}","public class Solution {
    public int FindIntegers(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var findIntegers = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def find_integers(n)
    
end","class Solution {
    func findIntegers(_ n: Int) -> Int {
        
    }
}","func findIntegers(n int) int {
    
}","object Solution {
    def findIntegers(n: Int): Int = {
        
    }
}","class Solution {
    fun findIntegers(n: Int): Int {
        
    }
}","impl Solution {
    pub fn find_integers(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function findIntegers($n) {
        
    }
}","function findIntegers(n: number): number {

};","(define/contract (find-integers n)
  (-> exact-integer? exact-integer?)

  )","-spec find_integers(N :: integer()) -> integer().
find_integers(N) ->
  .","defmodule Solution do
  @spec find_integers(n :: integer) :: integer
  def find_integers(n) do

  end
end","class Solution {
  int findIntegers(int n) {

  }
}",,,,non-negative-integers-without-consecutive-ones
81,629,K Inverse Pairs Array,"Given two integers `n` and `k`, find how many different arrays consist of numbers from `1` to `n` such that there are exactly `k` inverse pairs.
We define an inverse pair as following: For `ith` and `jth` element in the array, if `i` < `j` and `a[i]` > `a[j]` then it's an inverse pair; Otherwise, it's not.
Since the answer may be very large, the answer should be modulo 109 + 7.",0,Hard,/articles/k-inverse-pairs-array,31.7,0.0,https://leetcode.com/problems/k-inverse-pairs-array,71,12.8K,40.3K,Works Applications,Dynamic Programming,393,77,84,0,,"class Solution {
public:
    int kInversePairs(int n, int k) {
        
    }
};","class Solution {
    public int kInversePairs(int n, int k) {
        
    }
}","class Solution(object):
    def kInversePairs(self, n, k):
        """"""
        :type n: int
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def kInversePairs(self, n: int, k: int) -> int:
        ","int kInversePairs(int n, int k){

}","public class Solution {
    public int KInversePairs(int n, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var kInversePairs = function(n, k) {
    
};","# @param {Integer} n
# @param {Integer} k
# @return {Integer}
def k_inverse_pairs(n, k)
    
end","class Solution {
    func kInversePairs(_ n: Int, _ k: Int) -> Int {
        
    }
}","func kInversePairs(n int, k int) int {
    
}","object Solution {
    def kInversePairs(n: Int, k: Int): Int = {
        
    }
}","class Solution {
    fun kInversePairs(n: Int, k: Int): Int {
        
    }
}","impl Solution {
    pub fn k_inverse_pairs(n: i32, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $k
     * @return Integer
     */
    function kInversePairs($n, $k) {
        
    }
}","function kInversePairs(n: number, k: number): number {

};","(define/contract (k-inverse-pairs n k)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec k_inverse_pairs(N :: integer(), K :: integer()) -> integer().
k_inverse_pairs(N, K) ->
  .","defmodule Solution do
  @spec k_inverse_pairs(n :: integer, k :: integer) :: integer
  def k_inverse_pairs(n, k) do

  end
end","class Solution {
  int kInversePairs(int n, int k) {

  }
}",,,,k-inverse-pairs-array
82,630,Course Schedule III,"There are `n` different online courses numbered from `1` to `n`. Each course has some duration(course length) `t` and closed on `dth` day. A course should be taken continuously for `t` days and must be finished before or on the `dth` day. You will start at the `1st` day.
Given `n` online courses represented by pairs `(t,d)`, your task is to find the maximal number of courses that can be taken.",0,Hard,/articles/course-schedule-iii,33.8,8.9,https://leetcode.com/problems/course-schedule-iii,84,27.9K,82.5K,"Google,Microsoft",Greedy,1015,39,96,1,"[Course Schedule, /problems/course-schedule/, Medium], [Course Schedule II, /problems/course-schedule-ii/, Medium]","class Solution {
public:
    int scheduleCourse(vector<vector<int>>& courses) {
        
    }
};","class Solution {
    public int scheduleCourse(int[][] courses) {
        
    }
}","class Solution(object):
    def scheduleCourse(self, courses):
        """"""
        :type courses: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        ","int scheduleCourse(int** courses, int coursesSize, int* coursesColSize){

}","public class Solution {
    public int ScheduleCourse(int[][] courses) {
        
    }
}","/**
 * @param {number[][]} courses
 * @return {number}
 */
var scheduleCourse = function(courses) {
    
};","# @param {Integer[][]} courses
# @return {Integer}
def schedule_course(courses)
    
end","class Solution {
    func scheduleCourse(_ courses: [[Int]]) -> Int {
        
    }
}","func scheduleCourse(courses [][]int) int {
    
}","object Solution {
    def scheduleCourse(courses: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun scheduleCourse(courses: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn schedule_course(courses: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $courses
     * @return Integer
     */
    function scheduleCourse($courses) {
        
    }
}","function scheduleCourse(courses: number[][]): number {

};","(define/contract (schedule-course courses)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec schedule_course(Courses :: [[integer()]]) -> integer().
schedule_course(Courses) ->
  .","defmodule Solution do
  @spec schedule_course(courses :: [[integer]]) :: integer
  def schedule_course(courses) do

  end
end","class Solution {
  int scheduleCourse(List<List<int>> courses) {

  }
}",,,,course-schedule-iii
83,632,Smallest Range Covering Elements from K Lists,"You have `k` lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the `k` lists.
We define the range `[a, b]` is smaller than range `[c, d]` if `b - a < d - c` or `a < c` if `b - a == d - c`.",0,Hard,/articles/smallest-range,54.5,29.7,https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists,323,46.2K,84.9K,Amazon,"Hash Table,Two Pointers,String",1384,26,98,1,"[Minimum Window Substring, /problems/minimum-window-substring/, Hard]","class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        
    }
};","class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        
    }
}","class Solution(object):
    def smallestRange(self, nums):
        """"""
        :type nums: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* smallestRange(int** nums, int numsSize, int* numsColSize, int* returnSize){

}","public class Solution {
    public int[] SmallestRange(IList<IList<int>> nums) {
        
    }
}","/**
 * @param {number[][]} nums
 * @return {number[]}
 */
var smallestRange = function(nums) {
    
};","# @param {Integer[][]} nums
# @return {Integer[]}
def smallest_range(nums)
    
end","class Solution {
    func smallestRange(_ nums: [[Int]]) -> [Int] {
        
    }
}","func smallestRange(nums [][]int) []int {
    
}","object Solution {
    def smallestRange(nums: List[List[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun smallestRange(nums: List<List<Int>>): IntArray {
        
    }
}","impl Solution {
    pub fn smallest_range(nums: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $nums
     * @return Integer[]
     */
    function smallestRange($nums) {
        
    }
}","function smallestRange(nums: number[][]): number[] {

};","(define/contract (smallest-range nums)
  (-> (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec smallest_range(Nums :: [[integer()]]) -> [integer()].
smallest_range(Nums) ->
  .","defmodule Solution do
  @spec smallest_range(nums :: [[integer]]) :: [integer]
  def smallest_range(nums) do

  end
end","class Solution {
  List<int> smallestRange(List<List<int>> nums) {

  }
}",,,,smallest-range-covering-elements-from-k-lists
84,639,Decode Ways II,"A message containing letters from `A-Z` can be encoded into numbers using the following mapping:
'A' -> ""1""
'B' -> ""2""
...
'Z' -> ""26""
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `""11106""` can be mapped into:
`""AAJF""` with the grouping `(1 1 10 6)`
`""KJF""` with the grouping `(11 10 6)`
Note that the grouping `(1 11 06)` is invalid because `""06""` cannot be mapped into `'F'` since `""6""` is different from `""06""`.
In addition to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `""1*""` may represent any of the encoded messages `""11""`, `""12""`, `""13""`, `""14""`, `""15""`, `""16""`, `""17""`, `""18""`, or `""19""`. Decoding `""1*""` is equivalent to decoding any of the encoded messages it can represent.
Given a string `s` containing digits and the `'*'` character, return the number of ways to decode it.
Since the answer may be very large, return it modulo `109 + 7`.",0,Hard,/articles/decode-ways-ii,27.7,1.6,https://leetcode.com/problems/decode-ways-ii,250,38.5K,138.9K,"Google,Facebook",Dynamic Programming,583,592,50,1,"[Decode Ways, /problems/decode-ways/, Medium]","class Solution {
public:
    int numDecodings(string s) {
        
    }
};","class Solution {
    public int numDecodings(String s) {
        
    }
}","class Solution(object):
    def numDecodings(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def numDecodings(self, s: str) -> int:
        ","int numDecodings(char * s){

}","public class Solution {
    public int NumDecodings(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
    
};","# @param {String} s
# @return {Integer}
def num_decodings(s)
    
end","class Solution {
    func numDecodings(_ s: String) -> Int {
        
    }
}","func numDecodings(s string) int {
    
}","object Solution {
    def numDecodings(s: String): Int = {
        
    }
}","class Solution {
    fun numDecodings(s: String): Int {
        
    }
}","impl Solution {
    pub fn num_decodings(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function numDecodings($s) {
        
    }
}","function numDecodings(s: string): number {

};","(define/contract (num-decodings s)
  (-> string? exact-integer?)

  )","-spec num_decodings(S :: unicode:unicode_binary()) -> integer().
num_decodings(S) ->
  .","defmodule Solution do
  @spec num_decodings(s :: String.t) :: integer
  def num_decodings(s) do

  end
end","class Solution {
  int numDecodings(String s) {

  }
}",,,,decode-ways-ii
85,664,Strange Printer,"There is a strange printer with the following two special requirements:
The printer can only print a sequence of the same character each time.
At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.
Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.",0,Hard,/articles/strange-printer,41.6,22.4,https://leetcode.com/problems/strange-printer,88,17.8K,42.8K,NetEase,"Dynamic Programming,Depth-first Search",561,54,91,0,"[Remove Boxes, /problems/remove-boxes/, Hard], [Strange Printer II, /problems/strange-printer-ii/, Hard]","class Solution {
public:
    int strangePrinter(string s) {
        
    }
};","class Solution {
    public int strangePrinter(String s) {
        
    }
}","class Solution(object):
    def strangePrinter(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def strangePrinter(self, s: str) -> int:
        ","int strangePrinter(char * s){

}","public class Solution {
    public int StrangePrinter(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var strangePrinter = function(s) {
    
};","# @param {String} s
# @return {Integer}
def strange_printer(s)
    
end","class Solution {
    func strangePrinter(_ s: String) -> Int {
        
    }
}","func strangePrinter(s string) int {
    
}","object Solution {
    def strangePrinter(s: String): Int = {
        
    }
}","class Solution {
    fun strangePrinter(s: String): Int {
        
    }
}","impl Solution {
    pub fn strange_printer(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function strangePrinter($s) {
        
    }
}","function strangePrinter(s: string): number {

};","(define/contract (strange-printer s)
  (-> string? exact-integer?)

  )","-spec strange_printer(S :: unicode:unicode_binary()) -> integer().
strange_printer(S) ->
  .","defmodule Solution do
  @spec strange_printer(s :: String.t) :: integer
  def strange_printer(s) do

  end
end","class Solution {
  int strangePrinter(String s) {

  }
}",,,,strange-printer
86,668,Kth Smallest Number in Multiplication Table,"Nearly every one have used the Multiplication Table. But could you find out the `k-th` smallest number quickly from the multiplication table?
Given the height `m` and the length `n` of a `m * n` Multiplication Table, and a positive integer `k`, you need to return the `k-th` smallest number in this table.",0,Hard,/articles/kth-smallest-number-in-multiplication-table,47.9,0.0,https://leetcode.com/problems/kth-smallest-number-in-multiplication-table,112,26K,54.2K,"Uber,Google",Binary Search,695,25,97,1,"[Kth Smallest Element in a Sorted Matrix, /problems/kth-smallest-element-in-a-sorted-matrix/, Medium], [Find K-th Smallest Pair Distance, /problems/find-k-th-smallest-pair-distance/, Hard], [K-th Smallest Prime Fraction, /problems/k-th-smallest-prime-fraction/, Hard]","class Solution {
public:
    int findKthNumber(int m, int n, int k) {
        
    }
};","class Solution {
    public int findKthNumber(int m, int n, int k) {
        
    }
}","class Solution(object):
    def findKthNumber(self, m, n, k):
        """"""
        :type m: int
        :type n: int
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:
        ","int findKthNumber(int m, int n, int k){

}","public class Solution {
    public int FindKthNumber(int m, int n, int k) {
        
    }
}","/**
 * @param {number} m
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var findKthNumber = function(m, n, k) {
    
};","# @param {Integer} m
# @param {Integer} n
# @param {Integer} k
# @return {Integer}
def find_kth_number(m, n, k)
    
end","class Solution {
    func findKthNumber(_ m: Int, _ n: Int, _ k: Int) -> Int {
        
    }
}","func findKthNumber(m int, n int, k int) int {
    
}","object Solution {
    def findKthNumber(m: Int, n: Int, k: Int): Int = {
        
    }
}","class Solution {
    fun findKthNumber(m: Int, n: Int, k: Int): Int {
        
    }
}","impl Solution {
    pub fn find_kth_number(m: i32, n: i32, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $m
     * @param Integer $n
     * @param Integer $k
     * @return Integer
     */
    function findKthNumber($m, $n, $k) {
        
    }
}","function findKthNumber(m: number, n: number, k: number): number {

};","(define/contract (find-kth-number m n k)
  (-> exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec find_kth_number(M :: integer(), N :: integer(), K :: integer()) -> integer().
find_kth_number(M, N, K) ->
  .","defmodule Solution do
  @spec find_kth_number(m :: integer, n :: integer, k :: integer) :: integer
  def find_kth_number(m, n, k) do

  end
end","class Solution {
  int findKthNumber(int m, int n, int k) {

  }
}",,,,kth-smallest-number-in-multiplication-table
87,675,Cut Off Trees for Golf Event,"You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an `m x n` matrix. In this matrix:
`0` means the cell cannot be walked through.
`1` represents an empty cell that can be walked through.
A number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.
In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.
You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes `1` (an empty cell).
Starting from the point `(0, 0)`, return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return `-1`.
You are guaranteed that no two trees have the same height, and there is at least one tree needs to be cut off.",0,Hard,/articles/cutoff-trees-for-golf-event,35.4,15.4,https://leetcode.com/problems/cut-off-trees-for-golf-event,223,42.3K,119.4K,"Amazon,Apple",Breadth-first Search,664,388,63,1,,"class Solution {
public:
    int cutOffTree(vector<vector<int>>& forest) {
        
    }
};","class Solution {
    public int cutOffTree(List<List<Integer>> forest) {
        
    }
}","class Solution(object):
    def cutOffTree(self, forest):
        """"""
        :type forest: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def cutOffTree(self, forest: List[List[int]]) -> int:
        ","int cutOffTree(int** forest, int forestSize, int* forestColSize){

}","public class Solution {
    public int CutOffTree(IList<IList<int>> forest) {
        
    }
}","/**
 * @param {number[][]} forest
 * @return {number}
 */
var cutOffTree = function(forest) {
    
};","# @param {Integer[][]} forest
# @return {Integer}
def cut_off_tree(forest)
    
end","class Solution {
    func cutOffTree(_ forest: [[Int]]) -> Int {
        
    }
}","func cutOffTree(forest [][]int) int {
    
}","object Solution {
    def cutOffTree(forest: List[List[Int]]): Int = {
        
    }
}","class Solution {
    fun cutOffTree(forest: List<List<Int>>): Int {
        
    }
}","impl Solution {
    pub fn cut_off_tree(forest: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $forest
     * @return Integer
     */
    function cutOffTree($forest) {
        
    }
}","function cutOffTree(forest: number[][]): number {

};","(define/contract (cut-off-tree forest)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec cut_off_tree(Forest :: [[integer()]]) -> integer().
cut_off_tree(Forest) ->
  .","defmodule Solution do
  @spec cut_off_tree(forest :: [[integer]]) :: integer
  def cut_off_tree(forest) do

  end
end","class Solution {
  int cutOffTree(List<List<int>> forest) {

  }
}",,,,cut-off-trees-for-golf-event
88,679,24 Game,"You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through `*`, `/`, `+`, `-`, `(`, `)` to get the value of 24.",0,Hard,/articles/24-game,47.3,40.7,https://leetcode.com/problems/24-game,254,49.1K,103.9K,Amazon,Depth-first Search,902,180,83,1,,"class Solution {
public:
    bool judgePoint24(vector<int>& cards) {
        
    }
};","class Solution {
    public boolean judgePoint24(int[] cards) {
        
    }
}","class Solution(object):
    def judgePoint24(self, cards):
        """"""
        :type cards: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        ","bool judgePoint24(int* cards, int cardsSize){

}","public class Solution {
    public bool JudgePoint24(int[] cards) {
        
    }
}","/**
 * @param {number[]} cards
 * @return {boolean}
 */
var judgePoint24 = function(cards) {
    
};","# @param {Integer[]} cards
# @return {Boolean}
def judge_point24(cards)
    
end","class Solution {
    func judgePoint24(_ cards: [Int]) -> Bool {
        
    }
}","func judgePoint24(cards []int) bool {
    
}","object Solution {
    def judgePoint24(cards: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun judgePoint24(cards: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn judge_point24(cards: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $cards
     * @return Boolean
     */
    function judgePoint24($cards) {
        
    }
}","function judgePoint24(cards: number[]): boolean {

};","(define/contract (judge-point24 cards)
  (-> (listof exact-integer?) boolean?)

  )","-spec judge_point24(Cards :: [integer()]) -> boolean().
judge_point24(Cards) ->
  .","defmodule Solution do
  @spec judge_point24(cards :: [integer]) :: boolean
  def judge_point24(cards) do

  end
end","class Solution {
  bool judgePoint24(List<int> cards) {

  }
}",,,,24-game
89,685,Redundant Connection II,"In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.
The given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.
The resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.
Return an edge that can be removed so that the resulting graph is a rooted tree of `n` nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.",0,Hard,/articles/redundant-connection-ii,33.2,7.0,https://leetcode.com/problems/redundant-connection-ii,233,42K,126.8K,Amazon,"Tree,Depth-first Search,Union Find,Graph",1061,243,81,1,"[Redundant Connection, /problems/redundant-connection/, Medium]","class Solution {
public:
    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int[] findRedundantDirectedConnection(int[][] edges) {
        
    }
}","class Solution(object):
    def findRedundantDirectedConnection(self, edges):
        """"""
        :type edges: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findRedundantDirectedConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){

}","public class Solution {
    public int[] FindRedundantDirectedConnection(int[][] edges) {
        
    }
}","/**
 * @param {number[][]} edges
 * @return {number[]}
 */
var findRedundantDirectedConnection = function(edges) {
    
};","# @param {Integer[][]} edges
# @return {Integer[]}
def find_redundant_directed_connection(edges)
    
end","class Solution {
    func findRedundantDirectedConnection(_ edges: [[Int]]) -> [Int] {
        
    }
}","func findRedundantDirectedConnection(edges [][]int) []int {
    
}","object Solution {
    def findRedundantDirectedConnection(edges: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun findRedundantDirectedConnection(edges: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn find_redundant_directed_connection(edges: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $edges
     * @return Integer[]
     */
    function findRedundantDirectedConnection($edges) {
        
    }
}","function findRedundantDirectedConnection(edges: number[][]): number[] {

};","(define/contract (find-redundant-directed-connection edges)
  (-> (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec find_redundant_directed_connection(Edges :: [[integer()]]) -> [integer()].
find_redundant_directed_connection(Edges) ->
  .","defmodule Solution do
  @spec find_redundant_directed_connection(edges :: [[integer]]) :: [integer]
  def find_redundant_directed_connection(edges) do

  end
end","class Solution {
  List<int> findRedundantDirectedConnection(List<List<int>> edges) {

  }
}",,,,redundant-connection-ii
90,689,Maximum Sum of 3 Non-Overlapping Subarrays,"In a given array `nums` of positive integers, find three non-overlapping subarrays with maximum sum.
Each subarray will be of size `k`, and we want to maximize the sum of all `3*k` entries.
Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.",0,Hard,/articles/maximum-sum-of-3-non-overlapping-intervals,47.3,32.3,https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays,251,53.2K,112.4K,Facebook,"Array,Dynamic Programming",1214,81,94,1,"[Best Time to Buy and Sell Stock III, /problems/best-time-to-buy-and-sell-stock-iii/, Hard]","class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        
    }
}","class Solution(object):
    def maxSumOfThreeSubarrays(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* maxSumOfThreeSubarrays(int* nums, int numsSize, int k, int* returnSize){

}","public class Solution {
    public int[] MaxSumOfThreeSubarrays(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSumOfThreeSubarrays = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer[]}
def max_sum_of_three_subarrays(nums, k)
    
end","class Solution {
    func maxSumOfThreeSubarrays(_ nums: [Int], _ k: Int) -> [Int] {
        
    }
}","func maxSumOfThreeSubarrays(nums []int, k int) []int {
    
}","object Solution {
    def maxSumOfThreeSubarrays(nums: Array[Int], k: Int): Array[Int] = {
        
    }
}","class Solution {
    fun maxSumOfThreeSubarrays(nums: IntArray, k: Int): IntArray {
        
    }
}","impl Solution {
    pub fn max_sum_of_three_subarrays(nums: Vec<i32>, k: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer[]
     */
    function maxSumOfThreeSubarrays($nums, $k) {
        
    }
}","function maxSumOfThreeSubarrays(nums: number[], k: number): number[] {

};","(define/contract (max-sum-of-three-subarrays nums k)
  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))

  )","-spec max_sum_of_three_subarrays(Nums :: [integer()], K :: integer()) -> [integer()].
max_sum_of_three_subarrays(Nums, K) ->
  .","defmodule Solution do
  @spec max_sum_of_three_subarrays(nums :: [integer], k :: integer) :: [integer]
  def max_sum_of_three_subarrays(nums, k) do

  end
end","class Solution {
  List<int> maxSumOfThreeSubarrays(List<int> nums, int k) {

  }
}",,,,maximum-sum-of-3-non-overlapping-subarrays
91,691,Stickers to Spell Word,"We are given N different types of stickers.  Each sticker has a lowercase English word on it.
You would like to spell out the given `target` string by cutting individual letters from your collection of stickers and rearranging them.
You can use each sticker more than once if you want, and you have infinite quantities of each sticker.
What is the minimum number of stickers that you need to spell out the `target`?  If the task is impossible, return -1.",0,Hard,/articles/stickers-to-spell-word,45.1,11.0,https://leetcode.com/problems/stickers-to-spell-word,97,20K,44.3K,Facebook,"Dynamic Programming,Backtracking",499,46,92,1,"[Ransom Note, /problems/ransom-note/, Easy]","class Solution {
public:
    int minStickers(vector<string>& stickers, string target) {
        
    }
};","class Solution {
    public int minStickers(String[] stickers, String target) {
        
    }
}","class Solution(object):
    def minStickers(self, stickers, target):
        """"""
        :type stickers: List[str]
        :type target: str
        :rtype: int
        """"""
        ","class Solution:
    def minStickers(self, stickers: List[str], target: str) -> int:
        ","int minStickers(char ** stickers, int stickersSize, char * target){

}","public class Solution {
    public int MinStickers(string[] stickers, string target) {
        
    }
}","/**
 * @param {string[]} stickers
 * @param {string} target
 * @return {number}
 */
var minStickers = function(stickers, target) {
    
};","# @param {String[]} stickers
# @param {String} target
# @return {Integer}
def min_stickers(stickers, target)
    
end","class Solution {
    func minStickers(_ stickers: [String], _ target: String) -> Int {
        
    }
}","func minStickers(stickers []string, target string) int {
    
}","object Solution {
    def minStickers(stickers: Array[String], target: String): Int = {
        
    }
}","class Solution {
    fun minStickers(stickers: Array<String>, target: String): Int {
        
    }
}","impl Solution {
    pub fn min_stickers(stickers: Vec<String>, target: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $stickers
     * @param String $target
     * @return Integer
     */
    function minStickers($stickers, $target) {
        
    }
}","function minStickers(stickers: string[], target: string): number {

};","(define/contract (min-stickers stickers target)
  (-> (listof string?) string? exact-integer?)

  )","-spec min_stickers(Stickers :: [unicode:unicode_binary()], Target :: unicode:unicode_binary()) -> integer().
min_stickers(Stickers, Target) ->
  .","defmodule Solution do
  @spec min_stickers(stickers :: [String.t], target :: String.t) :: integer
  def min_stickers(stickers, target) do

  end
end","class Solution {
  int minStickers(List<String> stickers, String target) {

  }
}",,,,stickers-to-spell-word
92,699,Falling Squares,"On an infinite number line (x-axis), we drop given squares in the order they are given.
The `i`-th square dropped (`positions[i] = (left, side_length)`) is a square with the left-most point being `positions[i][0]` and sidelength `positions[i][1]`.
The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares. We wait for each square to stick before dropping the next.
The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square). Squares dropped adjacent to each other will not stick together prematurely.
Return a list `ans` of heights. Each height `ans[i]` represents the current highest height of any square we have dropped, after dropping squares represented by `positions[0], positions[1], ..., positions[i]`.",0,Hard,/articles/falling-squares,43.2,2.1,https://leetcode.com/problems/falling-squares,103,16K,37K,"Amazon,Uber,Square","Segment Tree,Ordered Map",330,65,84,1,"[The Skyline Problem, /problems/the-skyline-problem/, Hard]","class Solution {
public:
    vector<int> fallingSquares(vector<vector<int>>& positions) {
        
    }
};","class Solution {
    public List<Integer> fallingSquares(int[][] positions) {
        
    }
}","class Solution(object):
    def fallingSquares(self, positions):
        """"""
        :type positions: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def fallingSquares(self, positions: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* fallingSquares(int** positions, int positionsSize, int* positionsColSize, int* returnSize){

}","public class Solution {
    public IList<int> FallingSquares(int[][] positions) {
        
    }
}","/**
 * @param {number[][]} positions
 * @return {number[]}
 */
var fallingSquares = function(positions) {
    
};","# @param {Integer[][]} positions
# @return {Integer[]}
def falling_squares(positions)
    
end","class Solution {
    func fallingSquares(_ positions: [[Int]]) -> [Int] {
        
    }
}","func fallingSquares(positions [][]int) []int {
    
}","object Solution {
    def fallingSquares(positions: Array[Array[Int]]): List[Int] = {
        
    }
}","class Solution {
    fun fallingSquares(positions: Array<IntArray>): List<Int> {
        
    }
}","impl Solution {
    pub fn falling_squares(positions: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $positions
     * @return Integer[]
     */
    function fallingSquares($positions) {
        
    }
}","function fallingSquares(positions: number[][]): number[] {

};","(define/contract (falling-squares positions)
  (-> (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec falling_squares(Positions :: [[integer()]]) -> [integer()].
falling_squares(Positions) ->
  .","defmodule Solution do
  @spec falling_squares(positions :: [[integer]]) :: [integer]
  def falling_squares(positions) do

  end
end","class Solution {
  List<int> fallingSquares(List<List<int>> positions) {

  }
}",,,,falling-squares
95,719,Find K-th Smallest Pair Distance,"Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.",0,Hard,/articles/find-k-th-smallest-pair-distance,32.6,14.7,https://leetcode.com/problems/find-k-th-smallest-pair-distance,147,42.6K,130.4K,"Google,Amazon","Array,Binary Search,Heap",1304,49,96,1,"[Find K Pairs with Smallest Sums, /problems/find-k-pairs-with-smallest-sums/, Medium], [Kth Smallest Element in a Sorted Matrix, /problems/kth-smallest-element-in-a-sorted-matrix/, Medium], [Find K Closest Elements, /problems/find-k-closest-elements/, Medium], [Kth Smallest Number in Multiplication Table, /problems/kth-smallest-number-in-multiplication-table/, Hard], [K-th Smallest Prime Fraction, /problems/k-th-smallest-prime-fraction/, Hard]","class Solution {
public:
    int smallestDistancePair(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int smallestDistancePair(int[] nums, int k) {
        
    }
}","class Solution(object):
    def smallestDistancePair(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        ","int smallestDistancePair(int* nums, int numsSize, int k){

}","public class Solution {
    public int SmallestDistancePair(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var smallestDistancePair = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def smallest_distance_pair(nums, k)
    
end","class Solution {
    func smallestDistancePair(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func smallestDistancePair(nums []int, k int) int {
    
}","object Solution {
    def smallestDistancePair(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun smallestDistancePair(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn smallest_distance_pair(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function smallestDistancePair($nums, $k) {
        
    }
}","function smallestDistancePair(nums: number[], k: number): number {

};","(define/contract (smallest-distance-pair nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec smallest_distance_pair(Nums :: [integer()], K :: integer()) -> integer().
smallest_distance_pair(Nums, K) ->
  .","defmodule Solution do
  @spec smallest_distance_pair(nums :: [integer], k :: integer) :: integer
  def smallest_distance_pair(nums, k) do

  end
end","class Solution {
  int smallestDistancePair(List<int> nums, int k) {

  }
}",,,,find-k-th-smallest-pair-distance
96,726,Number of Atoms,"Given a chemical `formula` (given as a string), return the count of each atom.
The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.
One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.
Two formulas concatenated together to produce another formula. For example, H2O2He3Mg4 is also a formula.
A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.
Given a `formula`, return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.",0,Hard,/articles/number-of-atoms,51.0,60.4,https://leetcode.com/problems/number-of-atoms,302,32.2K,63.2K,"ByteDance,Amazon,Pinterest,Microsoft","Hash Table,Stack,Recursion",622,161,79,1,"[Decode String, /problems/decode-string/, Medium], [Encode String with Shortest Length, /problems/encode-string-with-shortest-length/, Hard], [Parse Lisp Expression, /problems/parse-lisp-expression/, Hard]","class Solution {
public:
    string countOfAtoms(string formula) {
        
    }
};","class Solution {
    public String countOfAtoms(String formula) {
        
    }
}","class Solution(object):
    def countOfAtoms(self, formula):
        """"""
        :type formula: str
        :rtype: str
        """"""
        ","class Solution:
    def countOfAtoms(self, formula: str) -> str:
        ","char * countOfAtoms(char * formula){

}","public class Solution {
    public string CountOfAtoms(string formula) {
        
    }
}","/**
 * @param {string} formula
 * @return {string}
 */
var countOfAtoms = function(formula) {
    
};","# @param {String} formula
# @return {String}
def count_of_atoms(formula)
    
end","class Solution {
    func countOfAtoms(_ formula: String) -> String {
        
    }
}","func countOfAtoms(formula string) string {
    
}","object Solution {
    def countOfAtoms(formula: String): String = {
        
    }
}","class Solution {
    fun countOfAtoms(formula: String): String {
        
    }
}","impl Solution {
    pub fn count_of_atoms(formula: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $formula
     * @return String
     */
    function countOfAtoms($formula) {
        
    }
}","function countOfAtoms(formula: string): string {

};","(define/contract (count-of-atoms formula)
  (-> string? string?)

  )","-spec count_of_atoms(Formula :: unicode:unicode_binary()) -> unicode:unicode_binary().
count_of_atoms(Formula) ->
  .","defmodule Solution do
  @spec count_of_atoms(formula :: String.t) :: String.t
  def count_of_atoms(formula) do

  end
end","class Solution {
  String countOfAtoms(String formula) {

  }
}",,,,number-of-atoms
97,730,Count Different Palindromic Subsequences,"Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo `10^9 + 7`.
A subsequence of a string S is obtained by deleting 0 or more characters from S.
A sequence is palindromic if it is equal to the sequence reversed.
Two sequences `A_1, A_2, ...` and `B_1, B_2, ...` are different if there is some `i` for which `A_i != B_i`.",0,Hard,/articles/count-different-palindromic-subsequences,43.4,18.5,https://leetcode.com/problems/count-different-palindromic-subsequences,82,19.4K,44.6K,"LinkedIn,Google,Facebook","String,Dynamic Programming",762,50,94,1,"[Longest Palindromic Subsequence, /problems/longest-palindromic-subsequence/, Medium]","class Solution {
public:
    int countPalindromicSubsequences(string s) {
        
    }
};","class Solution {
    public int countPalindromicSubsequences(String s) {
        
    }
}","class Solution(object):
    def countPalindromicSubsequences(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def countPalindromicSubsequences(self, s: str) -> int:
        ","int countPalindromicSubsequences(char * s){

}","public class Solution {
    public int CountPalindromicSubsequences(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var countPalindromicSubsequences = function(s) {
    
};","# @param {String} s
# @return {Integer}
def count_palindromic_subsequences(s)
    
end","class Solution {
    func countPalindromicSubsequences(_ s: String) -> Int {
        
    }
}","func countPalindromicSubsequences(s string) int {
    
}","object Solution {
    def countPalindromicSubsequences(s: String): Int = {
        
    }
}","class Solution {
    fun countPalindromicSubsequences(s: String): Int {
        
    }
}","impl Solution {
    pub fn count_palindromic_subsequences(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function countPalindromicSubsequences($s) {
        
    }
}","function countPalindromicSubsequences(s: string): number {

};","(define/contract (count-palindromic-subsequences s)
  (-> string? exact-integer?)

  )","-spec count_palindromic_subsequences(S :: unicode:unicode_binary()) -> integer().
count_palindromic_subsequences(S) ->
  .","defmodule Solution do
  @spec count_palindromic_subsequences(s :: String.t) :: integer
  def count_palindromic_subsequences(s) do

  end
end","class Solution {
  int countPalindromicSubsequences(String s) {

  }
}",,,,count-different-palindromic-subsequences
99,736,Parse Lisp Expression,"You are given a string `expression` representing a Lisp-like expression to return the integer value of.
The syntax for these expressions is given as follows.
An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.
(An integer could be positive or negative.)
A let-expression takes the form `(let v1 e1 v2 e2 ... vn en expr)`, where `let` is always the string `""let""`, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable `v1` is assigned the value of the expression `e1`, the second variable `v2` is assigned the value of the expression `e2`, and so on sequentially; and then the value of this let-expression is the value of the expression `expr`.
An add-expression takes the form `(add e1 e2)` where `add` is always the string `""add""`, there are always two expressions `e1, e2`, and this expression evaluates to the addition of the evaluation of `e1` and the evaluation of `e2`.
A mult-expression takes the form `(mult e1 e2)` where `mult` is always the string `""mult""`, there are always two expressions `e1, e2`, and this expression evaluates to the multiplication of the evaluation of `e1` and the evaluation of `e2`.
For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names ""add"", ""let"", or ""mult"" are protected and will never be used as variable names.
Finally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.",0,Hard,/articles/parse-lisp-expression,49.7,6.5,https://leetcode.com/problems/parse-lisp-expression,134,14.9K,30K,Google,String,323,239,57,1,"[Ternary Expression Parser, /problems/ternary-expression-parser/, Medium], [Number of Atoms, /problems/number-of-atoms/, Hard], [Basic Calculator IV, /problems/basic-calculator-iv/, Hard]","class Solution {
public:
    int evaluate(string expression) {
        
    }
};","class Solution {
    public int evaluate(String expression) {
        
    }
}","class Solution(object):
    def evaluate(self, expression):
        """"""
        :type expression: str
        :rtype: int
        """"""
        ","class Solution:
    def evaluate(self, expression: str) -> int:
        ","int evaluate(char * expression){

}","public class Solution {
    public int Evaluate(string expression) {
        
    }
}","/**
 * @param {string} expression
 * @return {number}
 */
var evaluate = function(expression) {
    
};","# @param {String} expression
# @return {Integer}
def evaluate(expression)
    
end","class Solution {
    func evaluate(_ expression: String) -> Int {
        
    }
}","func evaluate(expression string) int {
    
}","object Solution {
    def evaluate(expression: String): Int = {
        
    }
}","class Solution {
    fun evaluate(expression: String): Int {
        
    }
}","impl Solution {
    pub fn evaluate(expression: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $expression
     * @return Integer
     */
    function evaluate($expression) {
        
    }
}","function evaluate(expression: string): number {

};","(define/contract (evaluate expression)
  (-> string? exact-integer?)

  )","-spec evaluate(Expression :: unicode:unicode_binary()) -> integer().
evaluate(Expression) ->
  .","defmodule Solution do
  @spec evaluate(expression :: String.t) :: integer
  def evaluate(expression) do

  end
end","class Solution {
  int evaluate(String expression) {

  }
}",,,,parse-lisp-expression
100,741,Cherry Pickup,"You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.
`0` means the cell is empty, so you can pass through,
`1` means the cell contains a cherry that you can pick up and pass through, or
`-1` means the cell contains a thorn that blocks your way.
Return the maximum number of cherries you can collect by following the rules below:
Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).
After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.
When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.
If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected.",0,Hard,/articles/cherry-pickup,35.2,61.6,https://leetcode.com/problems/cherry-pickup,181,37.1K,105.5K,"Swiggy,Facebook,Mathworks",Dynamic Programming,1562,93,94,1,"[Minimum Path Sum, /problems/minimum-path-sum/, Medium], [Dungeon Game, /problems/dungeon-game/, Hard]","class Solution {
public:
    int cherryPickup(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int cherryPickup(int[][] grid) {
        
    }
}","class Solution(object):
    def cherryPickup(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        ","int cherryPickup(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int CherryPickup(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var cherryPickup = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def cherry_pickup(grid)
    
end","class Solution {
    func cherryPickup(_ grid: [[Int]]) -> Int {
        
    }
}","func cherryPickup(grid [][]int) int {
    
}","object Solution {
    def cherryPickup(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun cherryPickup(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn cherry_pickup(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function cherryPickup($grid) {
        
    }
}","function cherryPickup(grid: number[][]): number {

};","(define/contract (cherry-pickup grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec cherry_pickup(Grid :: [[integer()]]) -> integer().
cherry_pickup(Grid) ->
  .","defmodule Solution do
  @spec cherry_pickup(grid :: [[integer]]) :: integer
  def cherry_pickup(grid) do

  end
end","class Solution {
  int cherryPickup(List<List<int>> grid) {

  }
}",,,,cherry-pickup
102,749,Contain Virus,"A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.
The world is modeled as a 2-D array of cells, where `0` represents uninfected cells, and `1` represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.
Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.
Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.
Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.",0,Hard,/articles/contain-virus,48.3,23.5,https://leetcode.com/problems/contain-virus,74,6.4K,13.3K,Accolite,Depth-first Search,138,308,31,0,,"class Solution {
public:
    int containVirus(vector<vector<int>>& isInfected) {
        
    }
};","class Solution {
    public int containVirus(int[][] isInfected) {
        
    }
}","class Solution(object):
    def containVirus(self, isInfected):
        """"""
        :type isInfected: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def containVirus(self, isInfected: List[List[int]]) -> int:
        ","int containVirus(int** isInfected, int isInfectedSize, int* isInfectedColSize){

}","public class Solution {
    public int ContainVirus(int[][] isInfected) {
        
    }
}","/**
 * @param {number[][]} isInfected
 * @return {number}
 */
var containVirus = function(isInfected) {
    
};","# @param {Integer[][]} is_infected
# @return {Integer}
def contain_virus(is_infected)
    
end","class Solution {
    func containVirus(_ isInfected: [[Int]]) -> Int {
        
    }
}","func containVirus(isInfected [][]int) int {
    
}","object Solution {
    def containVirus(isInfected: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun containVirus(isInfected: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn contain_virus(is_infected: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $isInfected
     * @return Integer
     */
    function containVirus($isInfected) {
        
    }
}","function containVirus(isInfected: number[][]): number {

};","(define/contract (contain-virus isInfected)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec contain_virus(IsInfected :: [[integer()]]) -> integer().
contain_virus(IsInfected) ->
  .","defmodule Solution do
  @spec contain_virus(is_infected :: [[integer]]) :: integer
  def contain_virus(is_infected) do

  end
end","class Solution {
  int containVirus(List<List<int>> isInfected) {

  }
}",,,,contain-virus
103,753,Cracking the Safe,"There is a box protected by a password. The password is a sequence of `n` digits where each digit can be one of the first `k` digits `0, 1, ..., k-1`.
While entering a password, the last `n` digits entered will automatically be matched against the correct password.
For example, assuming the correct password is `""345""`, if you type `""012345""`, the box will open because the correct password matches the suffix of the entered password.
Return any password of minimum length that is guaranteed to open the box at some point of entering it.",0,Hard,/articles/cracking-the-safe,52.5,29.4,https://leetcode.com/problems/cracking-the-safe,133,35.6K,67.9K,Google,"Math,Depth-first Search",548,807,40,1,,"class Solution {
public:
    string crackSafe(int n, int k) {
        
    }
};","class Solution {
    public String crackSafe(int n, int k) {
        
    }
}","class Solution(object):
    def crackSafe(self, n, k):
        """"""
        :type n: int
        :type k: int
        :rtype: str
        """"""
        ","class Solution:
    def crackSafe(self, n: int, k: int) -> str:
        ","char * crackSafe(int n, int k){

}","public class Solution {
    public string CrackSafe(int n, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number} k
 * @return {string}
 */
var crackSafe = function(n, k) {
    
};","# @param {Integer} n
# @param {Integer} k
# @return {String}
def crack_safe(n, k)
    
end","class Solution {
    func crackSafe(_ n: Int, _ k: Int) -> String {
        
    }
}","func crackSafe(n int, k int) string {
    
}","object Solution {
    def crackSafe(n: Int, k: Int): String = {
        
    }
}","class Solution {
    fun crackSafe(n: Int, k: Int): String {
        
    }
}","impl Solution {
    pub fn crack_safe(n: i32, k: i32) -> String {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $k
     * @return String
     */
    function crackSafe($n, $k) {
        
    }
}","function crackSafe(n: number, k: number): string {

};","(define/contract (crack-safe n k)
  (-> exact-integer? exact-integer? string?)

  )","-spec crack_safe(N :: integer(), K :: integer()) -> unicode:unicode_binary().
crack_safe(N, K) ->
  .","defmodule Solution do
  @spec crack_safe(n :: integer, k :: integer) :: String.t
  def crack_safe(n, k) do

  end
end","class Solution {
  String crackSafe(int n, int k) {

  }
}",,,,cracking-the-safe
104,757,Set Intersection Size At Least Two,"An integer interval `[a, b]` (for integers `a < b`) is a set of all consecutive integers from `a` to `b`, including `a` and `b`.
Find the minimum size of a set S such that for every integer interval A in `intervals`, the intersection of S with A has a size of at least two.",0,Hard,/articles/set-intersection-size-at-least-two,42.5,14.5,https://leetcode.com/problems/set-intersection-size-at-least-two,74,12.4K,29.1K,Uber,Greedy,356,44,89,0,,"class Solution {
public:
    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        
    }
};","class Solution {
    public int intersectionSizeTwo(int[][] intervals) {
        
    }
}","class Solution(object):
    def intersectionSizeTwo(self, intervals):
        """"""
        :type intervals: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        ","int intersectionSizeTwo(int** intervals, int intervalsSize, int* intervalsColSize){

}","public class Solution {
    public int IntersectionSizeTwo(int[][] intervals) {
        
    }
}","/**
 * @param {number[][]} intervals
 * @return {number}
 */
var intersectionSizeTwo = function(intervals) {
    
};","# @param {Integer[][]} intervals
# @return {Integer}
def intersection_size_two(intervals)
    
end","class Solution {
    func intersectionSizeTwo(_ intervals: [[Int]]) -> Int {
        
    }
}","func intersectionSizeTwo(intervals [][]int) int {
    
}","object Solution {
    def intersectionSizeTwo(intervals: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun intersectionSizeTwo(intervals: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn intersection_size_two(intervals: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $intervals
     * @return Integer
     */
    function intersectionSizeTwo($intervals) {
        
    }
}","function intersectionSizeTwo(intervals: number[][]): number {

};","(define/contract (intersection-size-two intervals)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec intersection_size_two(Intervals :: [[integer()]]) -> integer().
intersection_size_two(Intervals) ->
  .","defmodule Solution do
  @spec intersection_size_two(intervals :: [[integer]]) :: integer
  def intersection_size_two(intervals) do

  end
end","class Solution {
  int intersectionSizeTwo(List<List<int>> intervals) {

  }
}",,,,set-intersection-size-at-least-two
105,761,Special Binary String,"Special binary strings are binary strings with the following two properties:
The number of 0's is equal to the number of 1's.
Every prefix of the binary string has at least as many 1's as 0's.
Given a special string `S`, a move consists of choosing two consecutive, non-empty, special substrings of `S`, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)
At the end of any number of moves, what is the lexicographically largest resulting string possible?",0,Hard,/articles/special-binary-string,58.7,55.1,https://leetcode.com/problems/special-binary-string,54,11.1K,18.8K,Citrix,"String,Recursion",401,134,75,0,"[Valid Parenthesis String, /problems/valid-parenthesis-string/, Medium]","class Solution {
public:
    string makeLargestSpecial(string s) {
        
    }
};","class Solution {
    public String makeLargestSpecial(String s) {
        
    }
}","class Solution(object):
    def makeLargestSpecial(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        ","class Solution:
    def makeLargestSpecial(self, s: str) -> str:
        ","char * makeLargestSpecial(char * s){

}","public class Solution {
    public string MakeLargestSpecial(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string}
 */
var makeLargestSpecial = function(s) {
    
};","# @param {String} s
# @return {String}
def make_largest_special(s)
    
end","class Solution {
    func makeLargestSpecial(_ s: String) -> String {
        
    }
}","func makeLargestSpecial(s string) string {
    
}","object Solution {
    def makeLargestSpecial(s: String): String = {
        
    }
}","class Solution {
    fun makeLargestSpecial(s: String): String {
        
    }
}","impl Solution {
    pub fn make_largest_special(s: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String
     */
    function makeLargestSpecial($s) {
        
    }
}","function makeLargestSpecial(s: string): string {

};","(define/contract (make-largest-special s)
  (-> string? string?)

  )","-spec make_largest_special(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
make_largest_special(S) ->
  .","defmodule Solution do
  @spec make_largest_special(s :: String.t) :: String.t
  def make_largest_special(s) do

  end
end","class Solution {
  String makeLargestSpecial(String s) {

  }
}",,,,special-binary-string
106,765,Couples Holding Hands,"N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats.
The people and seats are represented by an integer from `0` to `2N-1`, the couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2N-2, 2N-1)`.
The couples' initial seating is given by `row[i]` being the value of the person who is initially sitting in the i-th seat.",0,Hard,/articles/couples-holding-hands,55.6,20.0,https://leetcode.com/problems/couples-holding-hands,364,33K,59.4K,Google,"Greedy,Union Find,Graph",1026,68,94,1,"[First Missing Positive, /problems/first-missing-positive/, Hard], [Missing Number, /problems/missing-number/, Easy], [K-Similar Strings, /problems/k-similar-strings/, Hard]","class Solution {
public:
    int minSwapsCouples(vector<int>& row) {
        
    }
};","class Solution {
    public int minSwapsCouples(int[] row) {
        
    }
}","class Solution(object):
    def minSwapsCouples(self, row):
        """"""
        :type row: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        ","int minSwapsCouples(int* row, int rowSize){

}","public class Solution {
    public int MinSwapsCouples(int[] row) {
        
    }
}","/**
 * @param {number[]} row
 * @return {number}
 */
var minSwapsCouples = function(row) {
    
};","# @param {Integer[]} row
# @return {Integer}
def min_swaps_couples(row)
    
end","class Solution {
    func minSwapsCouples(_ row: [Int]) -> Int {
        
    }
}","func minSwapsCouples(row []int) int {
    
}","object Solution {
    def minSwapsCouples(row: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minSwapsCouples(row: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_swaps_couples(row: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $row
     * @return Integer
     */
    function minSwapsCouples($row) {
        
    }
}","function minSwapsCouples(row: number[]): number {

};","(define/contract (min-swaps-couples row)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec min_swaps_couples(Row :: [integer()]) -> integer().
min_swaps_couples(Row) ->
  .","defmodule Solution do
  @spec min_swaps_couples(row :: [integer]) :: integer
  def min_swaps_couples(row) do

  end
end","class Solution {
  int minSwapsCouples(List<int> row) {

  }
}",,,,couples-holding-hands
107,768,Max Chunks To Make Sorted II,"This question is the same as ""Max Chunks to Make Sorted"" except the integers of the given array are not necessarily distinct, the input array could be up to length `2000`, and the elements could be up to `10**8`.
Given an array `arr` of integers (not necessarily distinct), we split the array into some number of ""chunks"" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.
What is the most number of chunks we could have made?",0,Hard,/articles/max-chunks-to-make-sorted-ii,49.8,7.6,https://leetcode.com/problems/max-chunks-to-make-sorted-ii,204,26K,52.2K,"Microsoft,Google",Array,562,23,96,1,"[Max Chunks To Make Sorted, /problems/max-chunks-to-make-sorted/, Medium]","class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        
    }
};","class Solution {
    public int maxChunksToSorted(int[] arr) {
        
    }
}","class Solution(object):
    def maxChunksToSorted(self, arr):
        """"""
        :type arr: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        ","int maxChunksToSorted(int* arr, int arrSize){

}","public class Solution {
    public int MaxChunksToSorted(int[] arr) {
        
    }
}","/**
 * @param {number[]} arr
 * @return {number}
 */
var maxChunksToSorted = function(arr) {
    
};","# @param {Integer[]} arr
# @return {Integer}
def max_chunks_to_sorted(arr)
    
end","class Solution {
    func maxChunksToSorted(_ arr: [Int]) -> Int {
        
    }
}","func maxChunksToSorted(arr []int) int {
    
}","object Solution {
    def maxChunksToSorted(arr: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxChunksToSorted(arr: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_chunks_to_sorted(arr: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr
     * @return Integer
     */
    function maxChunksToSorted($arr) {
        
    }
}","function maxChunksToSorted(arr: number[]): number {

};","(define/contract (max-chunks-to-sorted arr)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_chunks_to_sorted(Arr :: [integer()]) -> integer().
max_chunks_to_sorted(Arr) ->
  .","defmodule Solution do
  @spec max_chunks_to_sorted(arr :: [integer]) :: integer
  def max_chunks_to_sorted(arr) do

  end
end","class Solution {
  int maxChunksToSorted(List<int> arr) {

  }
}",,,,max-chunks-to-make-sorted-ii
108,770,Basic Calculator IV,"Given an `expression` such as `expression = ""e + 8 - a + 5""` and an evaluation map such as `{""e"": 1}` (given in terms of `evalvars = [""e""]` and `evalints = [1]`), return a list of tokens representing the simplified expression, such as `[""-1*a"",""14""]`
An expression alternates chunks and symbols, with a space separating each chunk and symbol.
A chunk is either an expression in parentheses, a variable, or a non-negative integer.
A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like `""2x""` or `""-x""`.
Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, `expression = ""1 + 2 * 3""` has an answer of `[""7""]`.
The format of the output is as follows:
For each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like `""b*a*c""`, only `""a*b*c""`.
Terms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, `""a*a*b*c""` has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.
The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.)  A leading coefficient of 1 is still printed.
An example of a well formatted answer is `[""-2*a*a*a"", ""3*a*a*b"", ""3*b*b"", ""4*a"", ""5*c"", ""-6""]`
Terms (including constant terms) with coefficient 0 are not included.  For example, an expression of ""0"" has an output of [].",0,Hard,/articles/basic-calculator-iv,54.4,62.5,https://leetcode.com/problems/basic-calculator-iv,62,6.2K,11.4K,Roblox,"Hash Table,String,Stack",91,785,10,0,"[Parse Lisp Expression, /problems/parse-lisp-expression/, Hard], [Basic Calculator III, /problems/basic-calculator-iii/, Hard]","class Solution {
public:
    vector<string> basicCalculatorIV(string expression, vector<string>& evalvars, vector<int>& evalints) {
        
    }
};","class Solution {
    public List<String> basicCalculatorIV(String expression, String[] evalvars, int[] evalints) {
        
    }
}","class Solution(object):
    def basicCalculatorIV(self, expression, evalvars, evalints):
        """"""
        :type expression: str
        :type evalvars: List[str]
        :type evalints: List[int]
        :rtype: List[str]
        """"""
        ","class Solution:
    def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** basicCalculatorIV(char * expression, char ** evalvars, int evalvarsSize, int* evalints, int evalintsSize, int* returnSize){

}","public class Solution {
    public IList<string> BasicCalculatorIV(string expression, string[] evalvars, int[] evalints) {
        
    }
}","/**
 * @param {string} expression
 * @param {string[]} evalvars
 * @param {number[]} evalints
 * @return {string[]}
 */
var basicCalculatorIV = function(expression, evalvars, evalints) {
    
};","# @param {String} expression
# @param {String[]} evalvars
# @param {Integer[]} evalints
# @return {String[]}
def basic_calculator_iv(expression, evalvars, evalints)
    
end","class Solution {
    func basicCalculatorIV(_ expression: String, _ evalvars: [String], _ evalints: [Int]) -> [String] {
        
    }
}","func basicCalculatorIV(expression string, evalvars []string, evalints []int) []string {
    
}","object Solution {
    def basicCalculatorIV(expression: String, evalvars: Array[String], evalints: Array[Int]): List[String] = {
        
    }
}","class Solution {
    fun basicCalculatorIV(expression: String, evalvars: Array<String>, evalints: IntArray): List<String> {
        
    }
}","impl Solution {
    pub fn basic_calculator_iv(expression: String, evalvars: Vec<String>, evalints: Vec<i32>) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String $expression
     * @param String[] $evalvars
     * @param Integer[] $evalints
     * @return String[]
     */
    function basicCalculatorIV($expression, $evalvars, $evalints) {
        
    }
}","function basicCalculatorIV(expression: string, evalvars: string[], evalints: number[]): string[] {

};","(define/contract (basic-calculator-iv expression evalvars evalints)
  (-> string? (listof string?) (listof exact-integer?) (listof string?))

  )","-spec basic_calculator_iv(Expression :: unicode:unicode_binary(), Evalvars :: [unicode:unicode_binary()], Evalints :: [integer()]) -> [unicode:unicode_binary()].
basic_calculator_iv(Expression, Evalvars, Evalints) ->
  .","defmodule Solution do
  @spec basic_calculator_iv(expression :: String.t, evalvars :: [String.t], evalints :: [integer]) :: [String.t]
  def basic_calculator_iv(expression, evalvars, evalints) do

  end
end","class Solution {
  List<String> basicCalculatorIV(String expression, List<String> evalvars, List<int> evalints) {

  }
}",,,,basic-calculator-iv
109,773,Sliding Puzzle,"On a 2x3 `board`, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.
A move consists of choosing `0` and a 4-directionally adjacent number and swapping it.
The state of the board is solved if and only if the `board` is `[[1,2,3],[4,5,0]].`
Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.",0,Hard,/articles/sliding-puzzle,61.2,46.8,https://leetcode.com/problems/sliding-puzzle,331,52.1K,85.1K,"Uber,Airbnb,Facebook",Breadth-first Search,941,30,97,1,,"class Solution {
public:
    int slidingPuzzle(vector<vector<int>>& board) {
        
    }
};","class Solution {
    public int slidingPuzzle(int[][] board) {
        
    }
}","class Solution(object):
    def slidingPuzzle(self, board):
        """"""
        :type board: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        ","int slidingPuzzle(int** board, int boardSize, int* boardColSize){

}","public class Solution {
    public int SlidingPuzzle(int[][] board) {
        
    }
}","/**
 * @param {number[][]} board
 * @return {number}
 */
var slidingPuzzle = function(board) {
    
};","# @param {Integer[][]} board
# @return {Integer}
def sliding_puzzle(board)
    
end","class Solution {
    func slidingPuzzle(_ board: [[Int]]) -> Int {
        
    }
}","func slidingPuzzle(board [][]int) int {
    
}","object Solution {
    def slidingPuzzle(board: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun slidingPuzzle(board: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn sliding_puzzle(board: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $board
     * @return Integer
     */
    function slidingPuzzle($board) {
        
    }
}","function slidingPuzzle(board: number[][]): number {

};","(define/contract (sliding-puzzle board)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec sliding_puzzle(Board :: [[integer()]]) -> integer().
sliding_puzzle(Board) ->
  .","defmodule Solution do
  @spec sliding_puzzle(board :: [[integer]]) :: integer
  def sliding_puzzle(board) do

  end
end","class Solution {
  int slidingPuzzle(List<List<int>> board) {

  }
}",,,,sliding-puzzle
110,778,Swim in Rising Water,"On an N x N `grid`, each square `grid[i][j]` represents the elevation at that point `(i,j)`.
Now rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.
You start at the top left square `(0, 0)`. What is the least time until you can reach the bottom right square `(N-1, N-1)`?",0,Hard,/articles/swim-in-rising-water,54.9,15.7,https://leetcode.com/problems/swim-in-rising-water,271,33.7K,61.4K,Facebook,"Binary Search,Heap,Depth-first Search,Union Find",868,66,93,1,,"class Solution {
public:
    int swimInWater(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int swimInWater(int[][] grid) {
        
    }
}","class Solution(object):
    def swimInWater(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        ","int swimInWater(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int SwimInWater(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var swimInWater = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def swim_in_water(grid)
    
end","class Solution {
    func swimInWater(_ grid: [[Int]]) -> Int {
        
    }
}","func swimInWater(grid [][]int) int {
    
}","object Solution {
    def swimInWater(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun swimInWater(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn swim_in_water(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function swimInWater($grid) {
        
    }
}","function swimInWater(grid: number[][]): number {

};","(define/contract (swim-in-water grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec swim_in_water(Grid :: [[integer()]]) -> integer().
swim_in_water(Grid) ->
  .","defmodule Solution do
  @spec swim_in_water(grid :: [[integer]]) :: integer
  def swim_in_water(grid) do

  end
end","class Solution {
  int swimInWater(List<List<int>> grid) {

  }
}",,,,swim-in-rising-water
111,780,Reaching Points,"A move consists of taking a point `(x, y)` and transforming it to either `(x, x+y)` or `(x+y, y)`.
Given a starting point `(sx, sy)` and a target point `(tx, ty)`, return `True` if and only if a sequence of moves exists to transform the point `(sx, sy)` to `(tx, ty)`. Otherwise, return `False`.",0,Hard,/articles/reaching-points,30.4,64.1,https://leetcode.com/problems/reaching-points,110,31K,101.9K,"Twitter,Goldman Sachs",Math,713,128,85,0,,"class Solution {
public:
    bool reachingPoints(int sx, int sy, int tx, int ty) {
        
    }
};","class Solution {
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        
    }
}","class Solution(object):
    def reachingPoints(self, sx, sy, tx, ty):
        """"""
        :type sx: int
        :type sy: int
        :type tx: int
        :type ty: int
        :rtype: bool
        """"""
        ","class Solution:
    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
        ","bool reachingPoints(int sx, int sy, int tx, int ty){

}","public class Solution {
    public bool ReachingPoints(int sx, int sy, int tx, int ty) {
        
    }
}","/**
 * @param {number} sx
 * @param {number} sy
 * @param {number} tx
 * @param {number} ty
 * @return {boolean}
 */
var reachingPoints = function(sx, sy, tx, ty) {
    
};","# @param {Integer} sx
# @param {Integer} sy
# @param {Integer} tx
# @param {Integer} ty
# @return {Boolean}
def reaching_points(sx, sy, tx, ty)
    
end","class Solution {
    func reachingPoints(_ sx: Int, _ sy: Int, _ tx: Int, _ ty: Int) -> Bool {
        
    }
}","func reachingPoints(sx int, sy int, tx int, ty int) bool {
    
}","object Solution {
    def reachingPoints(sx: Int, sy: Int, tx: Int, ty: Int): Boolean = {
        
    }
}","class Solution {
    fun reachingPoints(sx: Int, sy: Int, tx: Int, ty: Int): Boolean {
        
    }
}","impl Solution {
    pub fn reaching_points(sx: i32, sy: i32, tx: i32, ty: i32) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer $sx
     * @param Integer $sy
     * @param Integer $tx
     * @param Integer $ty
     * @return Boolean
     */
    function reachingPoints($sx, $sy, $tx, $ty) {
        
    }
}","function reachingPoints(sx: number, sy: number, tx: number, ty: number): boolean {

};","(define/contract (reaching-points sx sy tx ty)
  (-> exact-integer? exact-integer? exact-integer? exact-integer? boolean?)

  )","-spec reaching_points(Sx :: integer(), Sy :: integer(), Tx :: integer(), Ty :: integer()) -> boolean().
reaching_points(Sx, Sy, Tx, Ty) ->
  .","defmodule Solution do
  @spec reaching_points(sx :: integer, sy :: integer, tx :: integer, ty :: integer) :: boolean
  def reaching_points(sx, sy, tx, ty) do

  end
end","class Solution {
  bool reachingPoints(int sx, int sy, int tx, int ty) {

  }
}",,,,reaching-points
112,782,Transform to Chessboard,"An N x N `board` contains only `0`s and `1`s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.
What is the minimum number of moves to transform the board into a ""chessboard"" - a board where no `0`s and no `1`s are 4-directionally adjacent? If the task is impossible, return -1.",0,Hard,/articles/transform-to-chessboard,47.0,21.7,https://leetcode.com/problems/transform-to-chessboard,29,6.6K,14K,Google,"Array,Math",149,152,50,1,,"class Solution {
public:
    int movesToChessboard(vector<vector<int>>& board) {
        
    }
};","class Solution {
    public int movesToChessboard(int[][] board) {
        
    }
}","class Solution(object):
    def movesToChessboard(self, board):
        """"""
        :type board: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        ","int movesToChessboard(int** board, int boardSize, int* boardColSize){

}","public class Solution {
    public int MovesToChessboard(int[][] board) {
        
    }
}","/**
 * @param {number[][]} board
 * @return {number}
 */
var movesToChessboard = function(board) {
    
};","# @param {Integer[][]} board
# @return {Integer}
def moves_to_chessboard(board)
    
end","class Solution {
    func movesToChessboard(_ board: [[Int]]) -> Int {
        
    }
}","func movesToChessboard(board [][]int) int {
    
}","object Solution {
    def movesToChessboard(board: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun movesToChessboard(board: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn moves_to_chessboard(board: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $board
     * @return Integer
     */
    function movesToChessboard($board) {
        
    }
}","function movesToChessboard(board: number[][]): number {

};","(define/contract (moves-to-chessboard board)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec moves_to_chessboard(Board :: [[integer()]]) -> integer().
moves_to_chessboard(Board) ->
  .","defmodule Solution do
  @spec moves_to_chessboard(board :: [[integer]]) :: integer
  def moves_to_chessboard(board) do

  end
end","class Solution {
  int movesToChessboard(List<List<int>> board) {

  }
}",,,,transform-to-chessboard
113,786,K-th Smallest Prime Fraction,"You are given a sorted integer array `arr` containing `1` and prime numbers, where all the integers of `arr` are unique. You are also given an integer `k`.
For every `i` and `j` where `0 <= i < j < arr.length`, we consider the fraction `arr[i] / arr[j]`.
Return the `kth` smallest fraction considered. Return your answer as an array of integers of size `2`, where `answer[0] == arr[i]` and `answer[1] == arr[j]`.",0,Hard,/articles/k-th-smallest-prime-fraction,43.3,21.2,https://leetcode.com/problems/k-th-smallest-prime-fraction,92,18.2K,42.1K,Robinhood,"Binary Search,Heap",507,29,95,0,"[Kth Smallest Element in a Sorted Matrix, /problems/kth-smallest-element-in-a-sorted-matrix/, Medium], [Kth Smallest Number in Multiplication Table, /problems/kth-smallest-number-in-multiplication-table/, Hard], [Find K-th Smallest Pair Distance, /problems/find-k-th-smallest-pair-distance/, Hard]","class Solution {
public:
    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
        
    }
};","class Solution {
    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        
    }
}","class Solution(object):
    def kthSmallestPrimeFraction(self, arr, k):
        """"""
        :type arr: List[int]
        :type k: int
        :rtype: List[int]
        """"""
        ","class Solution:
    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* kthSmallestPrimeFraction(int* arr, int arrSize, int k, int* returnSize){

}","public class Solution {
    public int[] KthSmallestPrimeFraction(int[] arr, int k) {
        
    }
}","/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var kthSmallestPrimeFraction = function(arr, k) {
    
};","# @param {Integer[]} arr
# @param {Integer} k
# @return {Integer[]}
def kth_smallest_prime_fraction(arr, k)
    
end","class Solution {
    func kthSmallestPrimeFraction(_ arr: [Int], _ k: Int) -> [Int] {
        
    }
}","func kthSmallestPrimeFraction(arr []int, k int) []int {
    
}","object Solution {
    def kthSmallestPrimeFraction(arr: Array[Int], k: Int): Array[Int] = {
        
    }
}","class Solution {
    fun kthSmallestPrimeFraction(arr: IntArray, k: Int): IntArray {
        
    }
}","impl Solution {
    pub fn kth_smallest_prime_fraction(arr: Vec<i32>, k: i32) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr
     * @param Integer $k
     * @return Integer[]
     */
    function kthSmallestPrimeFraction($arr, $k) {
        
    }
}","function kthSmallestPrimeFraction(arr: number[], k: number): number[] {

};","(define/contract (kth-smallest-prime-fraction arr k)
  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))

  )","-spec kth_smallest_prime_fraction(Arr :: [integer()], K :: integer()) -> [integer()].
kth_smallest_prime_fraction(Arr, K) ->
  .","defmodule Solution do
  @spec kth_smallest_prime_fraction(arr :: [integer], k :: integer) :: [integer]
  def kth_smallest_prime_fraction(arr, k) do

  end
end","class Solution {
  List<int> kthSmallestPrimeFraction(List<int> arr, int k) {

  }
}",,,,k-th-smallest-prime-fraction
114,793,Preimage Size of Factorial Zeroes Function,"Let `f(x)` be the number of zeroes at the end of `x!`. (Recall that `x! = 1 * 2 * 3 * ... * x`, and by convention, `0! = 1`.)
For example, `f(3) = 0` because 3! = 6 has no zeroes at the end, while `f(11) = 2` because 11! = 39916800 has 2 zeroes at the end. Given `K`, find how many non-negative integers `x` have the property that `f(x) = K`.",0,Hard,/articles/preimage-size-of-factorial-zeroes-function,40.6,0.0,https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function,91,9.5K,23.4K,Adobe,Binary Search,217,62,78,0,"[Factorial Trailing Zeroes, /problems/factorial-trailing-zeroes/, Easy]","class Solution {
public:
    int preimageSizeFZF(int k) {
        
    }
};","class Solution {
    public int preimageSizeFZF(int k) {
        
    }
}","class Solution(object):
    def preimageSizeFZF(self, k):
        """"""
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def preimageSizeFZF(self, k: int) -> int:
        ","int preimageSizeFZF(int k){

}","public class Solution {
    public int PreimageSizeFZF(int k) {
        
    }
}","/**
 * @param {number} k
 * @return {number}
 */
var preimageSizeFZF = function(k) {
    
};","# @param {Integer} k
# @return {Integer}
def preimage_size_fzf(k)
    
end","class Solution {
    func preimageSizeFZF(_ k: Int) -> Int {
        
    }
}","func preimageSizeFZF(k int) int {
    
}","object Solution {
    def preimageSizeFZF(k: Int): Int = {
        
    }
}","class Solution {
    fun preimageSizeFZF(k: Int): Int {
        
    }
}","impl Solution {
    pub fn preimage_size_fzf(k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $k
     * @return Integer
     */
    function preimageSizeFZF($k) {
        
    }
}","function preimageSizeFZF(k: number): number {

};","(define/contract (preimage-size-fzf k)
  (-> exact-integer? exact-integer?)

  )","-spec preimage_size_fzf(K :: integer()) -> integer().
preimage_size_fzf(K) ->
  .","defmodule Solution do
  @spec preimage_size_fzf(k :: integer) :: integer
  def preimage_size_fzf(k) do

  end
end","class Solution {
  int preimageSizeFZF(int k) {

  }
}",,,,preimage-size-of-factorial-zeroes-function
115,798,Smallest Rotation with Highest Score,"Given an array `A`, we may rotate it by a non-negative integer `K` so that the array becomes `A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]`.  Afterward, any entries that are less than or equal to their index are worth 1 point.
For example, if we have `[2, 4, 1, 3, 0]`, and we rotate by `K = 2`, it becomes `[1, 3, 0, 2, 4]`.  This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].
Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.",0,Hard,/articles/smallest-rotation-with-highest-score,45.0,0.0,https://leetcode.com/problems/smallest-rotation-with-highest-score,51,6.9K,15.4K,,,262,17,94,0,,"class Solution {
public:
    int bestRotation(vector<int>& nums) {
        
    }
};","class Solution {
    public int bestRotation(int[] nums) {
        
    }
}","class Solution(object):
    def bestRotation(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        ","int bestRotation(int* nums, int numsSize){

}","public class Solution {
    public int BestRotation(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var bestRotation = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def best_rotation(nums)
    
end","class Solution {
    func bestRotation(_ nums: [Int]) -> Int {
        
    }
}","func bestRotation(nums []int) int {
    
}","object Solution {
    def bestRotation(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun bestRotation(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn best_rotation(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function bestRotation($nums) {
        
    }
}","function bestRotation(nums: number[]): number {

};","(define/contract (best-rotation nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec best_rotation(Nums :: [integer()]) -> integer().
best_rotation(Nums) ->
  .","defmodule Solution do
  @spec best_rotation(nums :: [integer]) :: integer
  def best_rotation(nums) do

  end
end","class Solution {
  int bestRotation(List<int> nums) {

  }
}",,,,smallest-rotation-with-highest-score
116,803,Bricks Falling When Hit,"You are given an `m x n` binary `grid`, where each `1` represents a brick and `0` represents an empty space. A brick is stable if:
It is directly connected to the top of the grid, or
At least one other brick in its four adjacent cells is stable.
You are also given an array `hits`, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location `hits[i] = (rowi, coli)`. The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the `grid` (i.e., it does not land on other stable bricks).
Return an array `result`, where each `result[i]` is the number of bricks that will fall after the `ith` erasure is applied.
Note that an erasure may refer to a location with no brick, and if it does, no bricks drop.",0,Hard,/articles/bricks-falling-when-hit,31.8,2.4,https://leetcode.com/problems/bricks-falling-when-hit,57,17.8K,55.9K,Google,Union Find,534,151,78,1,,"class Solution {
public:
    vector<int> hitBricks(vector<vector<int>>& grid, vector<vector<int>>& hits) {
        
    }
};","class Solution {
    public int[] hitBricks(int[][] grid, int[][] hits) {
        
    }
}","class Solution(object):
    def hitBricks(self, grid, hits):
        """"""
        :type grid: List[List[int]]
        :type hits: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* hitBricks(int** grid, int gridSize, int* gridColSize, int** hits, int hitsSize, int* hitsColSize, int* returnSize){

}","public class Solution {
    public int[] HitBricks(int[][] grid, int[][] hits) {
        
    }
}","/**
 * @param {number[][]} grid
 * @param {number[][]} hits
 * @return {number[]}
 */
var hitBricks = function(grid, hits) {
    
};","# @param {Integer[][]} grid
# @param {Integer[][]} hits
# @return {Integer[]}
def hit_bricks(grid, hits)
    
end","class Solution {
    func hitBricks(_ grid: [[Int]], _ hits: [[Int]]) -> [Int] {
        
    }
}","func hitBricks(grid [][]int, hits [][]int) []int {
    
}","object Solution {
    def hitBricks(grid: Array[Array[Int]], hits: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun hitBricks(grid: Array<IntArray>, hits: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn hit_bricks(grid: Vec<Vec<i32>>, hits: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @param Integer[][] $hits
     * @return Integer[]
     */
    function hitBricks($grid, $hits) {
        
    }
}","function hitBricks(grid: number[][], hits: number[][]): number[] {

};","(define/contract (hit-bricks grid hits)
  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec hit_bricks(Grid :: [[integer()]], Hits :: [[integer()]]) -> [integer()].
hit_bricks(Grid, Hits) ->
  .","defmodule Solution do
  @spec hit_bricks(grid :: [[integer]], hits :: [[integer]]) :: [integer]
  def hit_bricks(grid, hits) do

  end
end","class Solution {
  List<int> hitBricks(List<List<int>> grid, List<List<int>> hits) {

  }
}",,,,bricks-falling-when-hit
117,805,Split Array With Same Average,"You are given an integer array `nums`.
You should move each element of `nums` into one of the two arrays `A` and `B` such that `A` and `B` are non-empty, and `average(A) == average(B)`.
Return `true` if it is possible to achieve that and `false` otherwise.
Note that for an array `arr`, `average(arr)` is the sum of all the elements of `arr` over the length of `arr`.",0,Hard,/articles/split-array-with-same-average,26.9,7.9,https://leetcode.com/problems/split-array-with-same-average,127,19.3K,71.7K,Apple,Math,506,94,84,1,,"class Solution {
public:
    bool splitArraySameAverage(vector<int>& nums) {
        
    }
};","class Solution {
    public boolean splitArraySameAverage(int[] nums) {
        
    }
}","class Solution(object):
    def splitArraySameAverage(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def splitArraySameAverage(self, nums: List[int]) -> bool:
        ","bool splitArraySameAverage(int* nums, int numsSize){

}","public class Solution {
    public bool SplitArraySameAverage(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {boolean}
 */
var splitArraySameAverage = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Boolean}
def split_array_same_average(nums)
    
end","class Solution {
    func splitArraySameAverage(_ nums: [Int]) -> Bool {
        
    }
}","func splitArraySameAverage(nums []int) bool {
    
}","object Solution {
    def splitArraySameAverage(nums: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun splitArraySameAverage(nums: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn split_array_same_average(nums: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    function splitArraySameAverage($nums) {
        
    }
}","function splitArraySameAverage(nums: number[]): boolean {

};","(define/contract (split-array-same-average nums)
  (-> (listof exact-integer?) boolean?)

  )","-spec split_array_same_average(Nums :: [integer()]) -> boolean().
split_array_same_average(Nums) ->
  .","defmodule Solution do
  @spec split_array_same_average(nums :: [integer]) :: boolean
  def split_array_same_average(nums) do

  end
end","class Solution {
  bool splitArraySameAverage(List<int> nums) {

  }
}",,,,split-array-with-same-average
118,810,Chalkboard XOR Game,"We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)
Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.
Return True if and only if Alice wins the game, assuming both players play optimally.",0,Hard,/articles/chalkboard-xor-game,50.2,4.8,https://leetcode.com/problems/chalkboard-xor-game,41,5K,9.9K,Garena,Math,80,197,29,0,,"class Solution {
public:
    bool xorGame(vector<int>& nums) {
        
    }
};","class Solution {
    public boolean xorGame(int[] nums) {
        
    }
}","class Solution(object):
    def xorGame(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def xorGame(self, nums: List[int]) -> bool:
        ","bool xorGame(int* nums, int numsSize){

}","public class Solution {
    public bool XorGame(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {boolean}
 */
var xorGame = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Boolean}
def xor_game(nums)
    
end","class Solution {
    func xorGame(_ nums: [Int]) -> Bool {
        
    }
}","func xorGame(nums []int) bool {
    
}","object Solution {
    def xorGame(nums: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun xorGame(nums: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn xor_game(nums: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    function xorGame($nums) {
        
    }
}","function xorGame(nums: number[]): boolean {

};","(define/contract (xor-game nums)
  (-> (listof exact-integer?) boolean?)

  )","-spec xor_game(Nums :: [integer()]) -> boolean().
xor_game(Nums) ->
  .","defmodule Solution do
  @spec xor_game(nums :: [integer]) :: boolean
  def xor_game(nums) do

  end
end","class Solution {
  bool xorGame(List<int> nums) {

  }
}",,,,chalkboard-xor-game
119,815,Bus Routes,"You are given an array `routes` representing bus routes where `routes[i]` is a bus route that the `ith` bus repeats forever.
For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.
You will start at the bus stop `source` (You are not on any bus initially), and you want to go to the bus stop `target`. You can travel between bus stops by buses only.
Return the least number of buses you must take to travel from `source` to `target`. Return `-1` if it is not possible.",0,Hard,/articles/bus-routes,43.6,42.7,https://leetcode.com/problems/bus-routes,234,48.4K,111.1K,"Amazon,Square,Uber",Breadth-first Search,1072,33,97,1,,"class Solution {
public:
    int numBusesToDestination(vector<vector<int>>& routes, int source, int target) {
        
    }
};","class Solution {
    public int numBusesToDestination(int[][] routes, int source, int target) {
        
    }
}","class Solution(object):
    def numBusesToDestination(self, routes, source, target):
        """"""
        :type routes: List[List[int]]
        :type source: int
        :type target: int
        :rtype: int
        """"""
        ","class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        ","int numBusesToDestination(int** routes, int routesSize, int* routesColSize, int source, int target){

}","public class Solution {
    public int NumBusesToDestination(int[][] routes, int source, int target) {
        
    }
}","/**
 * @param {number[][]} routes
 * @param {number} source
 * @param {number} target
 * @return {number}
 */
var numBusesToDestination = function(routes, source, target) {
    
};","# @param {Integer[][]} routes
# @param {Integer} source
# @param {Integer} target
# @return {Integer}
def num_buses_to_destination(routes, source, target)
    
end","class Solution {
    func numBusesToDestination(_ routes: [[Int]], _ source: Int, _ target: Int) -> Int {
        
    }
}","func numBusesToDestination(routes [][]int, source int, target int) int {
    
}","object Solution {
    def numBusesToDestination(routes: Array[Array[Int]], source: Int, target: Int): Int = {
        
    }
}","class Solution {
    fun numBusesToDestination(routes: Array<IntArray>, source: Int, target: Int): Int {
        
    }
}","impl Solution {
    pub fn num_buses_to_destination(routes: Vec<Vec<i32>>, source: i32, target: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $routes
     * @param Integer $source
     * @param Integer $target
     * @return Integer
     */
    function numBusesToDestination($routes, $source, $target) {
        
    }
}","function numBusesToDestination(routes: number[][], source: number, target: number): number {

};","(define/contract (num-buses-to-destination routes source target)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer? exact-integer?)

  )","-spec num_buses_to_destination(Routes :: [[integer()]], Source :: integer(), Target :: integer()) -> integer().
num_buses_to_destination(Routes, Source, Target) ->
  .","defmodule Solution do
  @spec num_buses_to_destination(routes :: [[integer]], source :: integer, target :: integer) :: integer
  def num_buses_to_destination(routes, source, target) do

  end
end","class Solution {
  int numBusesToDestination(List<List<int>> routes, int source, int target) {

  }
}",,,,bus-routes
120,818,Race Car,"Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.)
Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).
When you get an instruction ""A"", your car does the following: `position += speed, speed *= 2`.
When you get an instruction ""R"", your car does the following: if your speed is positive then `speed = -1` , otherwise `speed = 1`.  (Your position stays the same.)
For example, after commands ""AAR"", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1.
Now for some target position, say the length of the shortest sequence of instructions to get there.",0,Hard,/articles/race-car,40.3,13.5,https://leetcode.com/problems/race-car,102,24.4K,60.5K,Google,"Dynamic Programming,Heap",632,69,90,1,,"class Solution {
public:
    int racecar(int target) {
        
    }
};","class Solution {
    public int racecar(int target) {
        
    }
}","class Solution(object):
    def racecar(self, target):
        """"""
        :type target: int
        :rtype: int
        """"""
        ","class Solution:
    def racecar(self, target: int) -> int:
        ","int racecar(int target){

}","public class Solution {
    public int Racecar(int target) {
        
    }
}","/**
 * @param {number} target
 * @return {number}
 */
var racecar = function(target) {
    
};","# @param {Integer} target
# @return {Integer}
def racecar(target)
    
end","class Solution {
    func racecar(_ target: Int) -> Int {
        
    }
}","func racecar(target int) int {
    
}","object Solution {
    def racecar(target: Int): Int = {
        
    }
}","class Solution {
    fun racecar(target: Int): Int {
        
    }
}","impl Solution {
    pub fn racecar(target: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $target
     * @return Integer
     */
    function racecar($target) {
        
    }
}","function racecar(target: number): number {

};","(define/contract (racecar target)
  (-> exact-integer? exact-integer?)

  )","-spec racecar(Target :: integer()) -> integer().
racecar(Target) ->
  .","defmodule Solution do
  @spec racecar(target :: integer) :: integer
  def racecar(target) do

  end
end","class Solution {
  int racecar(int target) {

  }
}",,,,race-car
121,827,Making A Large Island,"You are given an `n x n` binary matrix `grid`. You are allowed to change at most one `0` to be `1`.
Return the size of the largest island in `grid` after applying this operation.
An island is a 4-directionally connected group of `1`s.",0,Hard,/articles/making-a-large-island,47.3,36.3,https://leetcode.com/problems/making-a-large-island,290,31.1K,65.9K,"Facebook,Google,Amazon","Depth-first Search,Breadth-first Search",712,22,97,1,,"class Solution {
public:
    int largestIsland(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int largestIsland(int[][] grid) {
        
    }
}","class Solution(object):
    def largestIsland(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        ","

int largestIsland(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int LargestIsland(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var largestIsland = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def largest_island(grid)
    
end","class Solution {
    func largestIsland(_ grid: [[Int]]) -> Int {
        
    }
}","func largestIsland(grid [][]int) int {
    
}","object Solution {
    def largestIsland(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun largestIsland(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn largest_island(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function largestIsland($grid) {
        
    }
}","function largestIsland(grid: number[][]): number {

};","(define/contract (largest-island grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )",,,,,,,making-a-large-island
122,828,Count Unique Characters of All Substrings of a Given String,"Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`, for example if `s = ""LEETCODE""` then `""L""`, `""T""`,`""C""`,`""O""`,`""D""` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`.
On this problem given a string `s` we need to return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. Notice that some substrings can be repeated so on this case you have to count the repeated ones too.
Since the answer can be very large, return the answer modulo `10 ^ 9 + 7`.",0,Hard,/articles/unique-letter-string,46.9,27.7,https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string,127,15.2K,32.4K,Microsoft,Two Pointers,608,61,91,0,,"class Solution {
public:
    int uniqueLetterString(string s) {
        
    }
};","class Solution {
    public int uniqueLetterString(String s) {
        
    }
}","class Solution(object):
    def uniqueLetterString(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def uniqueLetterString(self, s: str) -> int:
        ","int uniqueLetterString(char * s){

}","public class Solution {
    public int UniqueLetterString(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var uniqueLetterString = function(s) {
    
};","# @param {String} s
# @return {Integer}
def unique_letter_string(s)
    
end","class Solution {
    func uniqueLetterString(_ s: String) -> Int {
        
    }
}","func uniqueLetterString(s string) int {
    
}","object Solution {
    def uniqueLetterString(s: String): Int = {
        
    }
}","class Solution {
    fun uniqueLetterString(s: String): Int {
        
    }
}","impl Solution {
    pub fn unique_letter_string(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function uniqueLetterString($s) {
        
    }
}","function uniqueLetterString(s: string): number {

};","(define/contract (unique-letter-string s)
  (-> string? exact-integer?)

  )","-spec unique_letter_string(S :: unicode:unicode_binary()) -> integer().
unique_letter_string(S) ->
  .","defmodule Solution do
  @spec unique_letter_string(s :: String.t) :: integer
  def unique_letter_string(s) do

  end
end","class Solution {
  int uniqueLetterString(String s) {

  }
}",,,,count-unique-characters-of-all-substrings-of-a-given-string
123,829,Consecutive Numbers Sum,"Given a positive integer `N`, how many ways can we write it as a sum of consecutive positive integers?",0,Hard,/articles/consecutive-numbers-sum,39.3,86.1,https://leetcode.com/problems/consecutive-numbers-sum,236,44.9K,114.3K,"Citadel,Visa,Amazon,Nvidia",Math,598,750,44,1,,"class Solution {
public:
    int consecutiveNumbersSum(int n) {
        
    }
};","class Solution {
    public int consecutiveNumbersSum(int n) {
        
    }
}","class Solution(object):
    def consecutiveNumbersSum(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def consecutiveNumbersSum(self, n: int) -> int:
        ","int consecutiveNumbersSum(int n){

}","public class Solution {
    public int ConsecutiveNumbersSum(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var consecutiveNumbersSum = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def consecutive_numbers_sum(n)
    
end","class Solution {
    func consecutiveNumbersSum(_ n: Int) -> Int {
        
    }
}","func consecutiveNumbersSum(n int) int {
    
}","object Solution {
    def consecutiveNumbersSum(n: Int): Int = {
        
    }
}","class Solution {
    fun consecutiveNumbersSum(n: Int): Int {
        
    }
}","impl Solution {
    pub fn consecutive_numbers_sum(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function consecutiveNumbersSum($n) {
        
    }
}","function consecutiveNumbersSum(n: number): number {

};","(define/contract (consecutive-numbers-sum n)
  (-> exact-integer? exact-integer?)

  )","-spec consecutive_numbers_sum(N :: integer()) -> integer().
consecutive_numbers_sum(N) ->
  .","defmodule Solution do
  @spec consecutive_numbers_sum(n :: integer) :: integer
  def consecutive_numbers_sum(n) do

  end
end","class Solution {
  int consecutiveNumbersSum(int n) {

  }
}",,,,consecutive-numbers-sum
124,834,Sum of Distances in Tree,"An undirected, connected tree with `N` nodes labelled `0...N-1` and `N-1` `edges` are given.
The `i`th edge connects nodes `edges[i][0] `and` edges[i][1]` together.
Return a list `ans`, where `ans[i]` is the sum of the distances between node `i` and all other nodes.",0,Hard,/articles/sum-of-distances-in-tree,46.5,19.4,https://leetcode.com/problems/sum-of-distances-in-tree,115,19.9K,42.7K,Google,"Tree,Depth-first Search",1218,46,96,1,"[Distribute Coins in Binary Tree, /problems/distribute-coins-in-binary-tree/, Medium]","class Solution {
public:
    vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int[] sumOfDistancesInTree(int n, int[][] edges) {
        
    }
}","class Solution(object):
    def sumOfDistancesInTree(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sumOfDistancesInTree(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){

}","public class Solution {
    public int[] SumOfDistancesInTree(int n, int[][] edges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
var sumOfDistancesInTree = function(n, edges) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer[]}
def sum_of_distances_in_tree(n, edges)
    
end","class Solution {
    func sumOfDistancesInTree(_ n: Int, _ edges: [[Int]]) -> [Int] {
        
    }
}","func sumOfDistancesInTree(n int, edges [][]int) []int {
    
}","object Solution {
    def sumOfDistancesInTree(n: Int, edges: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun sumOfDistancesInTree(n: Int, edges: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn sum_of_distances_in_tree(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @return Integer[]
     */
    function sumOfDistancesInTree($n, $edges) {
        
    }
}","function sumOfDistancesInTree(n: number, edges: number[][]): number[] {

};","(define/contract (sum-of-distances-in-tree n edges)
  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec sum_of_distances_in_tree(N :: integer(), Edges :: [[integer()]]) -> [integer()].
sum_of_distances_in_tree(N, Edges) ->
  .","defmodule Solution do
  @spec sum_of_distances_in_tree(n :: integer, edges :: [[integer]]) :: [integer]
  def sum_of_distances_in_tree(n, edges) do

  end
end","class Solution {
  List<int> sumOfDistancesInTree(int n, List<List<int>> edges) {

  }
}",,,,sum-of-distances-in-tree
125,839,Similar String Groups,"Two strings `X` and `Y` are similar if we can swap two letters (in different positions) of `X`, so that it equals `Y`. Also two strings `X` and `Y` are similar if they are equal.
For example, `""tars""` and `""rats""` are similar (swapping at positions `0` and `2`), and `""rats""` and `""arts""` are similar, but `""star""` is not similar to `""tars""`, `""rats""`, or `""arts""`.
Together, these form two connected groups by similarity: `{""tars"", ""rats"", ""arts""}` and `{""star""}`.  Notice that `""tars""` and `""arts""` are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.
We are given a list `strs` of strings where every string in `strs` is an anagram of every other string in `strs`. How many groups are there?",0,Hard,/articles/similar-string-groups,41.6,14.6,https://leetcode.com/problems/similar-string-groups,266,35.2K,84.7K,Facebook,"Depth-first Search,Union Find,Graph",514,148,78,1,,"class Solution {
public:
    int numSimilarGroups(vector<string>& strs) {
        
    }
};","class Solution {
    public int numSimilarGroups(String[] strs) {
        
    }
}","class Solution(object):
    def numSimilarGroups(self, strs):
        """"""
        :type strs: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        ","int numSimilarGroups(char ** strs, int strsSize){

}","public class Solution {
    public int NumSimilarGroups(string[] strs) {
        
    }
}","/**
 * @param {string[]} strs
 * @return {number}
 */
var numSimilarGroups = function(strs) {
    
};","# @param {String[]} strs
# @return {Integer}
def num_similar_groups(strs)
    
end","class Solution {
    func numSimilarGroups(_ strs: [String]) -> Int {
        
    }
}","func numSimilarGroups(strs []string) int {
    
}","object Solution {
    def numSimilarGroups(strs: Array[String]): Int = {
        
    }
}","class Solution {
    fun numSimilarGroups(strs: Array<String>): Int {
        
    }
}","impl Solution {
    pub fn num_similar_groups(strs: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $strs
     * @return Integer
     */
    function numSimilarGroups($strs) {
        
    }
}","function numSimilarGroups(strs: string[]): number {

};","(define/contract (num-similar-groups strs)
  (-> (listof string?) exact-integer?)

  )","-spec num_similar_groups(Strs :: [unicode:unicode_binary()]) -> integer().
num_similar_groups(Strs) ->
  .","defmodule Solution do
  @spec num_similar_groups(strs :: [String.t]) :: integer
  def num_similar_groups(strs) do

  end
end","class Solution {
  int numSimilarGroups(List<String> strs) {

  }
}",,,,similar-string-groups
127,847,Shortest Path Visiting All Nodes,"An undirected, connected graph of N nodes (labeled `0, 1, 2, ..., N-1`) is given as `graph`.
`graph.length = N`, and `j != i` is in the list `graph[i]` exactly once, if and only if nodes `i` and `j` are connected.
Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.",0,Hard,/articles/shortest-path-visiting-all-nodes,54.1,19.8,https://leetcode.com/problems/shortest-path-visiting-all-nodes,136,21.7K,40.1K,Google,"Dynamic Programming,Breadth-first Search",787,84,90,1,,"class Solution {
public:
    int shortestPathLength(vector<vector<int>>& graph) {
        
    }
};","class Solution {
    public int shortestPathLength(int[][] graph) {
        
    }
}","class Solution(object):
    def shortestPathLength(self, graph):
        """"""
        :type graph: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def shortestPathLength(self, graph: List[List[int]]) -> int:
        ","int shortestPathLength(int** graph, int graphSize, int* graphColSize){

}","public class Solution {
    public int ShortestPathLength(int[][] graph) {
        
    }
}","/**
 * @param {number[][]} graph
 * @return {number}
 */
var shortestPathLength = function(graph) {
    
};","# @param {Integer[][]} graph
# @return {Integer}
def shortest_path_length(graph)
    
end","class Solution {
    func shortestPathLength(_ graph: [[Int]]) -> Int {
        
    }
}","func shortestPathLength(graph [][]int) int {
    
}","object Solution {
    def shortestPathLength(graph: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun shortestPathLength(graph: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn shortest_path_length(graph: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $graph
     * @return Integer
     */
    function shortestPathLength($graph) {
        
    }
}","function shortestPathLength(graph: number[][]): number {

};","(define/contract (shortest-path-length graph)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec shortest_path_length(Graph :: [[integer()]]) -> integer().
shortest_path_length(Graph) ->
  .","defmodule Solution do
  @spec shortest_path_length(graph :: [[integer]]) :: integer
  def shortest_path_length(graph) do

  end
end","class Solution {
  int shortestPathLength(List<List<int>> graph) {

  }
}",,,,shortest-path-visiting-all-nodes
128,850,Rectangle Area II,"We are given a list of (axis-aligned) `rectangles`. Each `rectangle[i] = [xi1, yi1, xi2, yi2] `, where `(xi1, yi1)` are the coordinates of the bottom-left corner, and `(xi2, yi2)` are the coordinates of the top-right corner of the `ith` rectangle.
Find the total area covered by all `rectangles` in the plane. Since the answer may be too large, return it modulo `109 + 7`.",0,Hard,/articles/rectangle-area-ii,48.4,29.4,https://leetcode.com/problems/rectangle-area-ii,84,15.3K,31.6K,Sumologic,"Segment Tree,Line Sweep",449,32,93,0,,"class Solution {
public:
    int rectangleArea(vector<vector<int>>& rectangles) {
        
    }
};","class Solution {
    public int rectangleArea(int[][] rectangles) {
        
    }
}","class Solution(object):
    def rectangleArea(self, rectangles):
        """"""
        :type rectangles: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def rectangleArea(self, rectangles: List[List[int]]) -> int:
        ","int rectangleArea(int** rectangles, int rectanglesSize, int* rectanglesColSize){

}","public class Solution {
    public int RectangleArea(int[][] rectangles) {
        
    }
}","/**
 * @param {number[][]} rectangles
 * @return {number}
 */
var rectangleArea = function(rectangles) {
    
};","# @param {Integer[][]} rectangles
# @return {Integer}
def rectangle_area(rectangles)
    
end","class Solution {
    func rectangleArea(_ rectangles: [[Int]]) -> Int {
        
    }
}","func rectangleArea(rectangles [][]int) int {
    
}","object Solution {
    def rectangleArea(rectangles: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun rectangleArea(rectangles: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn rectangle_area(rectangles: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $rectangles
     * @return Integer
     */
    function rectangleArea($rectangles) {
        
    }
}","function rectangleArea(rectangles: number[][]): number {

};",,"-spec rectangle_area(Rectangles :: [[integer()]]) -> integer().
rectangle_area(Rectangles) ->
  .","defmodule Solution do
  @spec rectangle_area(rectangles :: [[integer]]) :: integer
  def rectangle_area(rectangles) do

  end
end","class Solution {
  int rectangleArea(List<List<int>> rectangles) {

  }
}",,,,rectangle-area-ii
129,854,K-Similar Strings,"Strings `s1` and `s2` are `k`-similar (for some non-negative integer `k`) if we can swap the positions of two letters in `s1` exactly `k` times so that the resulting string equals `s2`.
Given two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and `s2` are `k`-similar.",0,Hard,/articles/k-similar-strings,38.8,4.4,https://leetcode.com/problems/k-similar-strings,143,23.5K,60.5K,Amazon,"Breadth-first Search,Graph",567,43,93,1,"[Couples Holding Hands, /problems/couples-holding-hands/, Hard]","class Solution {
public:
    int kSimilarity(string s1, string s2) {
        
    }
};","class Solution {
    public int kSimilarity(String s1, String s2) {
        
    }
}","class Solution(object):
    def kSimilarity(self, s1, s2):
        """"""
        :type s1: str
        :type s2: str
        :rtype: int
        """"""
        ","class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        ","int kSimilarity(char * s1, char * s2){

}","public class Solution {
    public int KSimilarity(string s1, string s2) {
        
    }
}","/**
 * @param {string} s1
 * @param {string} s2
 * @return {number}
 */
var kSimilarity = function(s1, s2) {
    
};","# @param {String} s1
# @param {String} s2
# @return {Integer}
def k_similarity(s1, s2)
    
end","class Solution {
    func kSimilarity(_ s1: String, _ s2: String) -> Int {
        
    }
}","func kSimilarity(s1 string, s2 string) int {
    
}","object Solution {
    def kSimilarity(s1: String, s2: String): Int = {
        
    }
}","class Solution {
    fun kSimilarity(s1: String, s2: String): Int {
        
    }
}","impl Solution {
    pub fn k_similarity(s1: String, s2: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s1
     * @param String $s2
     * @return Integer
     */
    function kSimilarity($s1, $s2) {
        
    }
}","function kSimilarity(s1: string, s2: string): number {

};","(define/contract (k-similarity s1 s2)
  (-> string? string? exact-integer?)

  )","-spec k_similarity(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary()) -> integer().
k_similarity(S1, S2) ->
  .","defmodule Solution do
  @spec k_similarity(s1 :: String.t, s2 :: String.t) :: integer
  def k_similarity(s1, s2) do

  end
end","class Solution {
  int kSimilarity(String s1, String s2) {

  }
}",,,,k-similar-strings
130,857,Minimum Cost to Hire K Workers,"There are `N` workers.  The `i`-th worker has a `quality[i]` and a minimum wage expectation `wage[i]`.
Now we want to hire exactly `K` workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:
Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.
Every worker in the paid group must be paid at least their minimum wage expectation.
Return the least amount of money needed to form a paid group satisfying the above conditions.",0,Hard,/articles/minimum-cost-to-hire-k-workers,50.5,23.6,https://leetcode.com/problems/minimum-cost-to-hire-k-workers,132,37.8K,74.8K,Google,Heap,1142,134,89,1,,"class Solution {
public:
    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {
        
    }
};","class Solution {
    public double mincostToHireWorkers(int[] quality, int[] wage, int k) {
        
    }
}","class Solution(object):
    def mincostToHireWorkers(self, quality, wage, k):
        """"""
        :type quality: List[int]
        :type wage: List[int]
        :type k: int
        :rtype: float
        """"""
        ","class Solution:
    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:
        ","double mincostToHireWorkers(int* quality, int qualitySize, int* wage, int wageSize, int k){

}","public class Solution {
    public double MincostToHireWorkers(int[] quality, int[] wage, int k) {
        
    }
}","/**
 * @param {number[]} quality
 * @param {number[]} wage
 * @param {number} k
 * @return {number}
 */
var mincostToHireWorkers = function(quality, wage, k) {
    
};","# @param {Integer[]} quality
# @param {Integer[]} wage
# @param {Integer} k
# @return {Float}
def mincost_to_hire_workers(quality, wage, k)
    
end","class Solution {
    func mincostToHireWorkers(_ quality: [Int], _ wage: [Int], _ k: Int) -> Double {
        
    }
}","func mincostToHireWorkers(quality []int, wage []int, k int) float64 {
    
}","object Solution {
    def mincostToHireWorkers(quality: Array[Int], wage: Array[Int], k: Int): Double = {
        
    }
}","class Solution {
    fun mincostToHireWorkers(quality: IntArray, wage: IntArray, k: Int): Double {
        
    }
}","impl Solution {
    pub fn mincost_to_hire_workers(quality: Vec<i32>, wage: Vec<i32>, k: i32) -> f64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $quality
     * @param Integer[] $wage
     * @param Integer $k
     * @return Float
     */
    function mincostToHireWorkers($quality, $wage, $k) {
        
    }
}","function mincostToHireWorkers(quality: number[], wage: number[], k: number): number {

};","(define/contract (mincost-to-hire-workers quality wage k)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? flonum?)

  )","-spec mincost_to_hire_workers(Quality :: [integer()], Wage :: [integer()], K :: integer()) -> float().
mincost_to_hire_workers(Quality, Wage, K) ->
  .","defmodule Solution do
  @spec mincost_to_hire_workers(quality :: [integer], wage :: [integer], k :: integer) :: float
  def mincost_to_hire_workers(quality, wage, k) do

  end
end","class Solution {
  double mincostToHireWorkers(List<int> quality, List<int> wage, int k) {

  }
}",,,,minimum-cost-to-hire-k-workers
131,862,Shortest Subarray with Sum at Least K,"Return the length of the shortest, non-empty, contiguous subarray of `A` with sum at least `K`.
If there is no non-empty subarray with sum at least `K`, return `-1`.",0,Hard,/articles/shortest-subarray-with-sum-at-least-k,25.3,46.6,https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k,179,45.1K,178.2K,Goldman Sachs,"Binary Search,Queue",1714,39,98,0,,"class Solution {
public:
    int shortestSubarray(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int shortestSubarray(int[] nums, int k) {
        
    }
}","class Solution(object):
    def shortestSubarray(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def shortestSubarray(self, nums: List[int], k: int) -> int:
        ","int shortestSubarray(int* nums, int numsSize, int k){

}","public class Solution {
    public int ShortestSubarray(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var shortestSubarray = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def shortest_subarray(nums, k)
    
end","class Solution {
    func shortestSubarray(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func shortestSubarray(nums []int, k int) int {
    
}","object Solution {
    def shortestSubarray(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun shortestSubarray(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn shortest_subarray(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function shortestSubarray($nums, $k) {
        
    }
}","function shortestSubarray(nums: number[], k: number): number {

};","(define/contract (shortest-subarray nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec shortest_subarray(Nums :: [integer()], K :: integer()) -> integer().
shortest_subarray(Nums, K) ->
  .","defmodule Solution do
  @spec shortest_subarray(nums :: [integer], k :: integer) :: integer
  def shortest_subarray(nums, k) do

  end
end","class Solution {
  int shortestSubarray(List<int> nums, int k) {

  }
}",,,,shortest-subarray-with-sum-at-least-k
132,864,Shortest Path to Get All Keys,"We are given a 2-dimensional `grid`. `"".""` is an empty cell, `""#""` is a wall, `""@""` is the starting point, (`""a""`, `""b""`, ...) are keys, and (`""A""`, `""B""`, ...) are locks.
We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key.
For some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first `K` letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.
Return the lowest number of moves to acquire all keys.  If it's impossible, return `-1`.",0,Hard,/articles/shortest-path-to-get-all-keys,42.4,36.8,https://leetcode.com/problems/shortest-path-to-get-all-keys,139,15.6K,36.7K,"ByteDance,Airbnb","Heap,Breadth-first Search",543,19,97,0,,"class Solution {
public:
    int shortestPathAllKeys(vector<string>& grid) {
        
    }
};","class Solution {
    public int shortestPathAllKeys(String[] grid) {
        
    }
}","class Solution(object):
    def shortestPathAllKeys(self, grid):
        """"""
        :type grid: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:
        ","int shortestPathAllKeys(char ** grid, int gridSize){

}","public class Solution {
    public int ShortestPathAllKeys(string[] grid) {
        
    }
}","/**
 * @param {string[]} grid
 * @return {number}
 */
var shortestPathAllKeys = function(grid) {
    
};","# @param {String[]} grid
# @return {Integer}
def shortest_path_all_keys(grid)
    
end","class Solution {
    func shortestPathAllKeys(_ grid: [String]) -> Int {
        
    }
}","func shortestPathAllKeys(grid []string) int {
    
}","object Solution {
    def shortestPathAllKeys(grid: Array[String]): Int = {
        
    }
}","class Solution {
    fun shortestPathAllKeys(grid: Array<String>): Int {
        
    }
}","impl Solution {
    pub fn shortest_path_all_keys(grid: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $grid
     * @return Integer
     */
    function shortestPathAllKeys($grid) {
        
    }
}","function shortestPathAllKeys(grid: string[]): number {

};","(define/contract (shortest-path-all-keys grid)
  (-> (listof string?) exact-integer?)

  )","-spec shortest_path_all_keys(Grid :: [unicode:unicode_binary()]) -> integer().
shortest_path_all_keys(Grid) ->
  .","defmodule Solution do
  @spec shortest_path_all_keys(grid :: [String.t]) :: integer
  def shortest_path_all_keys(grid) do

  end
end","class Solution {
  int shortestPathAllKeys(List<String> grid) {

  }
}",,,,shortest-path-to-get-all-keys
133,871,Minimum Number of Refueling Stops,"A car travels from a starting position to a destination which is `target` miles east of the starting position.
Along the way, there are gas stations.  Each `station[i]` represents a gas station that is `station[i][0]` miles east of the starting position, and has `station[i][1]` liters of gas.
The car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.
When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.
What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return `-1`.
Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.",0,Hard,/articles/minimum-number-of-refueling-stops,32.4,62.5,https://leetcode.com/problems/minimum-number-of-refueling-stops,173,28K,86.4K,"Flipkart,Google","Dynamic Programming,Heap",1143,26,98,1,,"class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        
    }
};","class Solution {
    public int minRefuelStops(int target, int startFuel, int[][] stations) {
        
    }
}","class Solution(object):
    def minRefuelStops(self, target, startFuel, stations):
        """"""
        :type target: int
        :type startFuel: int
        :type stations: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        ","int minRefuelStops(int target, int startFuel, int** stations, int stationsSize, int* stationsColSize){

}","public class Solution {
    public int MinRefuelStops(int target, int startFuel, int[][] stations) {
        
    }
}","/**
 * @param {number} target
 * @param {number} startFuel
 * @param {number[][]} stations
 * @return {number}
 */
var minRefuelStops = function(target, startFuel, stations) {
    
};","# @param {Integer} target
# @param {Integer} start_fuel
# @param {Integer[][]} stations
# @return {Integer}
def min_refuel_stops(target, start_fuel, stations)
    
end","class Solution {
    func minRefuelStops(_ target: Int, _ startFuel: Int, _ stations: [[Int]]) -> Int {
        
    }
}","func minRefuelStops(target int, startFuel int, stations [][]int) int {
    
}","object Solution {
    def minRefuelStops(target: Int, startFuel: Int, stations: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minRefuelStops(target: Int, startFuel: Int, stations: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn min_refuel_stops(target: i32, start_fuel: i32, stations: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $target
     * @param Integer $startFuel
     * @param Integer[][] $stations
     * @return Integer
     */
    function minRefuelStops($target, $startFuel, $stations) {
        
    }
}","function minRefuelStops(target: number, startFuel: number, stations: number[][]): number {

};","(define/contract (min-refuel-stops target startFuel stations)
  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec min_refuel_stops(Target :: integer(), StartFuel :: integer(), Stations :: [[integer()]]) -> integer().
min_refuel_stops(Target, StartFuel, Stations) ->
  .","defmodule Solution do
  @spec min_refuel_stops(target :: integer, start_fuel :: integer, stations :: [[integer]]) :: integer
  def min_refuel_stops(target, start_fuel, stations) do

  end
end","class Solution {
  int minRefuelStops(int target, int startFuel, List<List<int>> stations) {

  }
}",,,,minimum-number-of-refueling-stops
134,878,Nth Magical Number,"A positive integer is magical if it is divisible by either `a` or `b`.
Given the three integers `n`, `a`, and `b`, return the `nth` magical number. Since the answer may be very large, return it modulo `109 + 7`.",0,Hard,/articles/nth-magical-number,28.9,7.3,https://leetcode.com/problems/nth-magical-number,97,11.7K,40.4K,,,265,67,80,0,,"class Solution {
public:
    int nthMagicalNumber(int n, int a, int b) {
        
    }
};","class Solution {
    public int nthMagicalNumber(int n, int a, int b) {
        
    }
}","class Solution(object):
    def nthMagicalNumber(self, n, a, b):
        """"""
        :type n: int
        :type a: int
        :type b: int
        :rtype: int
        """"""
        ","class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        ","int nthMagicalNumber(int n, int a, int b){

}","public class Solution {
    public int NthMagicalNumber(int n, int a, int b) {
        
    }
}","/**
 * @param {number} n
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var nthMagicalNumber = function(n, a, b) {
    
};","# @param {Integer} n
# @param {Integer} a
# @param {Integer} b
# @return {Integer}
def nth_magical_number(n, a, b)
    
end","class Solution {
    func nthMagicalNumber(_ n: Int, _ a: Int, _ b: Int) -> Int {
        
    }
}","func nthMagicalNumber(n int, a int, b int) int {
    
}","object Solution {
    def nthMagicalNumber(n: Int, a: Int, b: Int): Int = {
        
    }
}","class Solution {
    fun nthMagicalNumber(n: Int, a: Int, b: Int): Int {
        
    }
}","impl Solution {
    pub fn nth_magical_number(n: i32, a: i32, b: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $a
     * @param Integer $b
     * @return Integer
     */
    function nthMagicalNumber($n, $a, $b) {
        
    }
}","function nthMagicalNumber(n: number, a: number, b: number): number {

};","(define/contract (nth-magical-number n a b)
  (-> exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec nth_magical_number(N :: integer(), A :: integer(), B :: integer()) -> integer().
nth_magical_number(N, A, B) ->
  .","defmodule Solution do
  @spec nth_magical_number(n :: integer, a :: integer, b :: integer) :: integer
  def nth_magical_number(n, a, b) do

  end
end","class Solution {
  int nthMagicalNumber(int n, int a, int b) {

  }
}",,,,nth-magical-number
135,879,Profitable Schemes,"There is a group of `n` members, and a list of various crimes they could commit. The `ith` crime generates a `profit[i]` and requires `group[i]` members to participate in it. If a member participates in one crime, that member can't participate in another crime.
Let's call a profitable scheme any subset of these crimes that generates at least `minProfit` profit, and the total number of members participating in that subset of crimes is at most `n`.
Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo `109 + 7`.",0,Hard,/articles/profitable-schemes,39.9,9.7,https://leetcode.com/problems/profitable-schemes,68,11.4K,28.5K,Google,Dynamic Programming,297,32,90,1,,"class Solution {
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        
    }
};","class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        
    }
}","class Solution(object):
    def profitableSchemes(self, n, minProfit, group, profit):
        """"""
        :type n: int
        :type minProfit: int
        :type group: List[int]
        :type profit: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        ","int profitableSchemes(int n, int minProfit, int* group, int groupSize, int* profit, int profitSize){

}","public class Solution {
    public int ProfitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        
    }
}","/**
 * @param {number} n
 * @param {number} minProfit
 * @param {number[]} group
 * @param {number[]} profit
 * @return {number}
 */
var profitableSchemes = function(n, minProfit, group, profit) {
    
};","# @param {Integer} n
# @param {Integer} min_profit
# @param {Integer[]} group
# @param {Integer[]} profit
# @return {Integer}
def profitable_schemes(n, min_profit, group, profit)
    
end","class Solution {
    func profitableSchemes(_ n: Int, _ minProfit: Int, _ group: [Int], _ profit: [Int]) -> Int {
        
    }
}","func profitableSchemes(n int, minProfit int, group []int, profit []int) int {
    
}","object Solution {
    def profitableSchemes(n: Int, minProfit: Int, group: Array[Int], profit: Array[Int]): Int = {
        
    }
}","class Solution {
    fun profitableSchemes(n: Int, minProfit: Int, group: IntArray, profit: IntArray): Int {
        
    }
}","impl Solution {
    pub fn profitable_schemes(n: i32, min_profit: i32, group: Vec<i32>, profit: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $minProfit
     * @param Integer[] $group
     * @param Integer[] $profit
     * @return Integer
     */
    function profitableSchemes($n, $minProfit, $group, $profit) {
        
    }
}","function profitableSchemes(n: number, minProfit: number, group: number[], profit: number[]): number {

};","(define/contract (profitable-schemes n minProfit group profit)
  (-> exact-integer? exact-integer? (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec profitable_schemes(N :: integer(), MinProfit :: integer(), Group :: [integer()], Profit :: [integer()]) -> integer().
profitable_schemes(N, MinProfit, Group, Profit) ->
  .","defmodule Solution do
  @spec profitable_schemes(n :: integer, min_profit :: integer, group :: [integer], profit :: [integer]) :: integer
  def profitable_schemes(n, min_profit, group, profit) do

  end
end","class Solution {
  int profitableSchemes(int n, int minProfit, List<int> group, List<int> profit) {

  }
}",,,,profitable-schemes
136,882,Reachable Nodes In Subdivided Graph,"You are given an undirected graph (the ""original graph"") with `n` nodes labeled from `0` to `n - 1`. You decide to subdivide each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.
The graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]` indicates that there is an edge between nodes `ui` and `vi` in the original graph, and `cnti` is the total number of new nodes that you will subdivide the edge into. Note that `cnti == 0` means you will not subdivide the edge.
To subdivide the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and `cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new edges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti+1, xcnti]`, `[xcnti, vi]`.
In this new graph, you want to know how many nodes are reachable from the node `0`, where a node is reachable if the distance is `maxMoves` or less.
Given the original graph and `maxMoves`, return the number of nodes that are reachable from node `0` in the new graph.",0,Hard,/articles/reachable-nodes-in-subdivided-graph,43.1,14.3,https://leetcode.com/problems/reachable-nodes-in-subdivided-graph,53,7.3K,17K,Amazon,"Heap,Breadth-first Search",183,155,54,1,,"class Solution {
public:
    int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
        
    }
};","class Solution {
    public int reachableNodes(int[][] edges, int maxMoves, int n) {
        
    }
}","class Solution(object):
    def reachableNodes(self, edges, maxMoves, n):
        """"""
        :type edges: List[List[int]]
        :type maxMoves: int
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
        ","int reachableNodes(int** edges, int edgesSize, int* edgesColSize, int maxMoves, int n){

}","public class Solution {
    public int ReachableNodes(int[][] edges, int maxMoves, int n) {
        
    }
}","/**
 * @param {number[][]} edges
 * @param {number} maxMoves
 * @param {number} n
 * @return {number}
 */
var reachableNodes = function(edges, maxMoves, n) {
    
};","# @param {Integer[][]} edges
# @param {Integer} max_moves
# @param {Integer} n
# @return {Integer}
def reachable_nodes(edges, max_moves, n)
    
end","class Solution {
    func reachableNodes(_ edges: [[Int]], _ maxMoves: Int, _ n: Int) -> Int {
        
    }
}","func reachableNodes(edges [][]int, maxMoves int, n int) int {
    
}","object Solution {
    def reachableNodes(edges: Array[Array[Int]], maxMoves: Int, n: Int): Int = {
        
    }
}","class Solution {
    fun reachableNodes(edges: Array<IntArray>, maxMoves: Int, n: Int): Int {
        
    }
}","impl Solution {
    pub fn reachable_nodes(edges: Vec<Vec<i32>>, max_moves: i32, n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $edges
     * @param Integer $maxMoves
     * @param Integer $n
     * @return Integer
     */
    function reachableNodes($edges, $maxMoves, $n) {
        
    }
}","function reachableNodes(edges: number[][], maxMoves: number, n: number): number {

};","(define/contract (reachable-nodes edges maxMoves n)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer? exact-integer?)

  )","-spec reachable_nodes(Edges :: [[integer()]], MaxMoves :: integer(), N :: integer()) -> integer().
reachable_nodes(Edges, MaxMoves, N) ->
  .","defmodule Solution do
  @spec reachable_nodes(edges :: [[integer]], max_moves :: integer, n :: integer) :: integer
  def reachable_nodes(edges, max_moves, n) do

  end
end","class Solution {
  int reachableNodes(List<List<int>> edges, int maxMoves, int n) {

  }
}",,,,reachable-nodes-in-subdivided-graph
137,887,Super Egg Drop,"You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.
You know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor higher than `f` will break, and any egg dropped at or below floor `f` will not break.
Each move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.
Return the minimum number of moves that you need to determine with certainty what the value of `f` is.",0,Hard,/articles/super-egg-drop,27.0,42.2,https://leetcode.com/problems/super-egg-drop,121,28.8K,106.7K,Amazon,"Math,Binary Search,Dynamic Programming",1332,96,93,1,,"class Solution {
public:
    int superEggDrop(int k, int n) {
        
    }
};","class Solution {
    public int superEggDrop(int k, int n) {
        
    }
}","class Solution(object):
    def superEggDrop(self, k, n):
        """"""
        :type k: int
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        ","int superEggDrop(int k, int n){

}","public class Solution {
    public int SuperEggDrop(int k, int n) {
        
    }
}","/**
 * @param {number} k
 * @param {number} n
 * @return {number}
 */
var superEggDrop = function(k, n) {
    
};","# @param {Integer} k
# @param {Integer} n
# @return {Integer}
def super_egg_drop(k, n)
    
end","class Solution {
    func superEggDrop(_ k: Int, _ n: Int) -> Int {
        
    }
}","func superEggDrop(k int, n int) int {
    
}","object Solution {
    def superEggDrop(k: Int, n: Int): Int = {
        
    }
}","class Solution {
    fun superEggDrop(k: Int, n: Int): Int {
        
    }
}","impl Solution {
    pub fn super_egg_drop(k: i32, n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $k
     * @param Integer $n
     * @return Integer
     */
    function superEggDrop($k, $n) {
        
    }
}","function superEggDrop(k: number, n: number): number {

};","(define/contract (super-egg-drop k n)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec super_egg_drop(K :: integer(), N :: integer()) -> integer().
super_egg_drop(K, N) ->
  .","defmodule Solution do
  @spec super_egg_drop(k :: integer, n :: integer) :: integer
  def super_egg_drop(k, n) do

  end
end","class Solution {
  int superEggDrop(int k, int n) {

  }
}",,,,super-egg-drop
138,891,Sum of Subsequence Widths,"Given an array of integers `A`, consider all non-empty subsequences of `A`.
For any sequence S, let the width of S be the difference between the maximum and minimum element of S.
Return the sum of the widths of all subsequences of A.
As the answer may be very large, return the answer modulo 10^9 + 7.",0,Hard,/articles/sum-of-subsequence-widths,33.1,3.3,https://leetcode.com/problems/sum-of-subsequence-widths,59,10.5K,31.7K,Sapient,"Array,Math",319,110,74,0,,"class Solution {
public:
    int sumSubseqWidths(vector<int>& nums) {
        
    }
};","class Solution {
    public int sumSubseqWidths(int[] nums) {
        
    }
}","class Solution(object):
    def sumSubseqWidths(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def sumSubseqWidths(self, nums: List[int]) -> int:
        ","int sumSubseqWidths(int* nums, int numsSize){

}","public class Solution {
    public int SumSubseqWidths(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var sumSubseqWidths = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def sum_subseq_widths(nums)
    
end","class Solution {
    func sumSubseqWidths(_ nums: [Int]) -> Int {
        
    }
}","func sumSubseqWidths(nums []int) int {
    
}","object Solution {
    def sumSubseqWidths(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun sumSubseqWidths(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn sum_subseq_widths(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function sumSubseqWidths($nums) {
        
    }
}","function sumSubseqWidths(nums: number[]): number {

};","(define/contract (sum-subseq-widths nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec sum_subseq_widths(Nums :: [integer()]) -> integer().
sum_subseq_widths(Nums) ->
  .","defmodule Solution do
  @spec sum_subseq_widths(nums :: [integer]) :: integer
  def sum_subseq_widths(nums) do

  end
end","class Solution {
  int sumSubseqWidths(List<int> nums) {

  }
}",,,,sum-of-subsequence-widths
140,899,Orderly Queue,"A string `S` of lowercase letters is given.  Then, we may make any number of moves.
In each move, we choose one of the first `K` letters (starting from the left), remove it, and place it at the end of the string.
Return the lexicographically smallest string we could have after any number of moves.",0,Hard,/articles/orderly-queue,53.4,4.2,https://leetcode.com/problems/orderly-queue,57,9.5K,17.7K,Amazon,"Math,String",251,225,53,1,,"class Solution {
public:
    string orderlyQueue(string s, int k) {
        
    }
};","class Solution {
    public String orderlyQueue(String s, int k) {
        
    }
}","class Solution(object):
    def orderlyQueue(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: str
        """"""
        ","class Solution:
    def orderlyQueue(self, s: str, k: int) -> str:
        ","char * orderlyQueue(char * s, int k){

}","public class Solution {
    public string OrderlyQueue(string s, int k) {
        
    }
}","/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var orderlyQueue = function(s, k) {
    
};","# @param {String} s
# @param {Integer} k
# @return {String}
def orderly_queue(s, k)
    
end","class Solution {
    func orderlyQueue(_ s: String, _ k: Int) -> String {
        
    }
}","func orderlyQueue(s string, k int) string {
    
}","object Solution {
    def orderlyQueue(s: String, k: Int): String = {
        
    }
}","class Solution {
    fun orderlyQueue(s: String, k: Int): String {
        
    }
}","impl Solution {
    pub fn orderly_queue(s: String, k: i32) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param Integer $k
     * @return String
     */
    function orderlyQueue($s, $k) {
        
    }
}","function orderlyQueue(s: string, k: number): string {

};","(define/contract (orderly-queue s k)
  (-> string? exact-integer? string?)

  )","-spec orderly_queue(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().
orderly_queue(S, K) ->
  .","defmodule Solution do
  @spec orderly_queue(s :: String.t, k :: integer) :: String.t
  def orderly_queue(s, k) do

  end
end","class Solution {
  String orderlyQueue(String s, int k) {

  }
}",,,,orderly-queue
141,902,Numbers At Most N Given Digit Set,"Given an array of `digits` which is sorted in non-decreasing order. You can write numbers using each `digits[i]` as many times as we want. For example, if `digits = ['1','3','5']`, we may write numbers such as `'13'`, `'551'`, and `'1351315'`.
Return the number of positive integers that can be generated that are less than or equal to a given integer `n`.",0,Hard,/articles/numbers-at-most-n-given-digit-set,36.1,20.2,https://leetcode.com/problems/numbers-at-most-n-given-digit-set,183,20.3K,56.2K,Amazon,"Math,Dynamic Programming",492,68,88,1,,"class Solution {
public:
    int atMostNGivenDigitSet(vector<string>& digits, int n) {
        
    }
};","class Solution {
    public int atMostNGivenDigitSet(String[] digits, int n) {
        
    }
}","class Solution(object):
    def atMostNGivenDigitSet(self, digits, n):
        """"""
        :type digits: List[str]
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        ","int atMostNGivenDigitSet(char ** digits, int digitsSize, int n){

}","public class Solution {
    public int AtMostNGivenDigitSet(string[] digits, int n) {
        
    }
}","/**
 * @param {string[]} digits
 * @param {number} n
 * @return {number}
 */
var atMostNGivenDigitSet = function(digits, n) {
    
};","# @param {String[]} digits
# @param {Integer} n
# @return {Integer}
def at_most_n_given_digit_set(digits, n)
    
end","class Solution {
    func atMostNGivenDigitSet(_ digits: [String], _ n: Int) -> Int {
        
    }
}","func atMostNGivenDigitSet(digits []string, n int) int {
    
}","object Solution {
    def atMostNGivenDigitSet(digits: Array[String], n: Int): Int = {
        
    }
}","class Solution {
    fun atMostNGivenDigitSet(digits: Array<String>, n: Int): Int {
        
    }
}","impl Solution {
    pub fn at_most_n_given_digit_set(digits: Vec<String>, n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $digits
     * @param Integer $n
     * @return Integer
     */
    function atMostNGivenDigitSet($digits, $n) {
        
    }
}","function atMostNGivenDigitSet(digits: string[], n: number): number {

};","(define/contract (at-most-n-given-digit-set digits n)
  (-> (listof string?) exact-integer? exact-integer?)

  )","-spec at_most_n_given_digit_set(Digits :: [unicode:unicode_binary()], N :: integer()) -> integer().
at_most_n_given_digit_set(Digits, N) ->
  .","defmodule Solution do
  @spec at_most_n_given_digit_set(digits :: [String.t], n :: integer) :: integer
  def at_most_n_given_digit_set(digits, n) do

  end
end","class Solution {
  int atMostNGivenDigitSet(List<String> digits, int n) {

  }
}",,,,numbers-at-most-n-given-digit-set
142,903,Valid Permutations for DI Sequence,"We are given `S`, a length `n` string of characters from the set `{'D', 'I'}`. (These letters stand for ""decreasing"" and ""increasing"".)
A valid permutation is a permutation `P[0], P[1], ..., P[n]` of integers `{0, 1, ..., n}`, such that for all `i`:
If `S[i] == 'D'`, then `P[i] > P[i+1]`, and;
If `S[i] == 'I'`, then `P[i] < P[i+1]`.
How many valid permutations are there?  Since the answer may be large, return your answer modulo `10^9 + 7`.",0,Hard,/articles/valid-permutations-for-di-sequence,54.2,21.0,https://leetcode.com/problems/valid-permutations-for-di-sequence,50,8.2K,15.1K,,,351,30,92,0,,"class Solution {
public:
    int numPermsDISequence(string s) {
        
    }
};","class Solution {
    public int numPermsDISequence(String s) {
        
    }
}","class Solution(object):
    def numPermsDISequence(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def numPermsDISequence(self, s: str) -> int:
        ","int numPermsDISequence(char * s){

}","public class Solution {
    public int NumPermsDISequence(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var numPermsDISequence = function(s) {
    
};","# @param {String} s
# @return {Integer}
def num_perms_di_sequence(s)
    
end","class Solution {
    func numPermsDISequence(_ s: String) -> Int {
        
    }
}","func numPermsDISequence(s string) int {
    
}","object Solution {
    def numPermsDISequence(s: String): Int = {
        
    }
}","class Solution {
    fun numPermsDISequence(s: String): Int {
        
    }
}","impl Solution {
    pub fn num_perms_di_sequence(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function numPermsDISequence($s) {
        
    }
}","function numPermsDISequence(s: string): number {

};","(define/contract (num-perms-di-sequence s)
  (-> string? exact-integer?)

  )","-spec num_perms_di_sequence(S :: unicode:unicode_binary()) -> integer().
num_perms_di_sequence(S) ->
  .","defmodule Solution do
  @spec num_perms_di_sequence(s :: String.t) :: integer
  def num_perms_di_sequence(s) do

  end
end","class Solution {
  int numPermsDISequence(String s) {

  }
}",,,,valid-permutations-for-di-sequence
143,906,Super Palindromes,"Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome.
Given two positive integers `left` and `right` represented as strings, return the number of super-palindromes integers in the inclusive range `[left, right]`.",0,Hard,/articles/super-palindromes,32.7,6.4,https://leetcode.com/problems/super-palindromes,57,6.5K,19.8K,Google,Math,98,176,36,1,,"class Solution {
public:
    int superpalindromesInRange(string left, string right) {
        
    }
};","class Solution {
    public int superpalindromesInRange(String left, String right) {
        
    }
}","class Solution(object):
    def superpalindromesInRange(self, left, right):
        """"""
        :type left: str
        :type right: str
        :rtype: int
        """"""
        ","class Solution:
    def superpalindromesInRange(self, left: str, right: str) -> int:
        ","int superpalindromesInRange(char * left, char * right){

}","public class Solution {
    public int SuperpalindromesInRange(string left, string right) {
        
    }
}","/**
 * @param {string} left
 * @param {string} right
 * @return {number}
 */
var superpalindromesInRange = function(left, right) {
    
};","# @param {String} left
# @param {String} right
# @return {Integer}
def superpalindromes_in_range(left, right)
    
end","class Solution {
    func superpalindromesInRange(_ left: String, _ right: String) -> Int {
        
    }
}","func superpalindromesInRange(left string, right string) int {
    
}","object Solution {
    def superpalindromesInRange(left: String, right: String): Int = {
        
    }
}","class Solution {
    fun superpalindromesInRange(left: String, right: String): Int {
        
    }
}","impl Solution {
    pub fn superpalindromes_in_range(left: String, right: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $left
     * @param String $right
     * @return Integer
     */
    function superpalindromesInRange($left, $right) {
        
    }
}","function superpalindromesInRange(left: string, right: string): number {

};","(define/contract (superpalindromes-in-range left right)
  (-> string? string? exact-integer?)

  )","-spec superpalindromes_in_range(Left :: unicode:unicode_binary(), Right :: unicode:unicode_binary()) -> integer().
superpalindromes_in_range(Left, Right) ->
  .","defmodule Solution do
  @spec superpalindromes_in_range(left :: String.t, right :: String.t) :: integer
  def superpalindromes_in_range(left, right) do

  end
end","class Solution {
  int superpalindromesInRange(String left, String right) {

  }
}",,,,super-palindromes
144,913,Cat and Mouse,"A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.
The graph is given as follows: `graph[a]` is a list of all nodes `b` such that `ab` is an edge of the graph.
The mouse starts at node `1` and goes first, the cat starts at node `2` and goes second, and there is a hole at node `0`.
During each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in `graph[1]`.
Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)
Then, the game can end in three ways:
If ever the Cat occupies the same node as the Mouse, the Cat wins.
If ever the Mouse reaches the Hole, the Mouse wins.
If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.
Given a `graph`, and assuming both players play optimally, return
`1` if the mouse wins the game,
`2` if the cat wins the game, or
`0` if the game is a draw.",0,Hard,/articles/cat-and-mouse-game,34.8,28.4,https://leetcode.com/problems/cat-and-mouse,92,11.5K,33.1K,Google,"Breadth-first Search,Minimax",439,88,83,1,"[Cat and Mouse II, /problems/cat-and-mouse-ii/, Hard]","class Solution {
public:
    int catMouseGame(vector<vector<int>>& graph) {
        
    }
};","class Solution {
    public int catMouseGame(int[][] graph) {
        
    }
}","class Solution(object):
    def catMouseGame(self, graph):
        """"""
        :type graph: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def catMouseGame(self, graph: List[List[int]]) -> int:
        ","int catMouseGame(int** graph, int graphSize, int* graphColSize){

}","public class Solution {
    public int CatMouseGame(int[][] graph) {
        
    }
}","/**
 * @param {number[][]} graph
 * @return {number}
 */
var catMouseGame = function(graph) {
    
};","# @param {Integer[][]} graph
# @return {Integer}
def cat_mouse_game(graph)
    
end","class Solution {
    func catMouseGame(_ graph: [[Int]]) -> Int {
        
    }
}","func catMouseGame(graph [][]int) int {
    
}","object Solution {
    def catMouseGame(graph: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun catMouseGame(graph: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn cat_mouse_game(graph: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $graph
     * @return Integer
     */
    function catMouseGame($graph) {
        
    }
}","function catMouseGame(graph: number[][]): number {

};","(define/contract (cat-mouse-game graph)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec cat_mouse_game(Graph :: [[integer()]]) -> integer().
cat_mouse_game(Graph) ->
  .","defmodule Solution do
  @spec cat_mouse_game(graph :: [[integer]]) :: integer
  def cat_mouse_game(graph) do

  end
end","class Solution {
  int catMouseGame(List<List<int>> graph) {

  }
}",,,,cat-and-mouse
145,920,Number of Music Playlists,"Your music player contains `N` different songs and she wants to listen to `L` (not necessarily different) songs during your trip.  You create a playlist so that:
Every song is played at least once
A song can only be played again only if `K` other songs have been played
Return the number of possible playlists.  As the answer can be very large, return it modulo `10^9 + 7`.",0,Hard,/articles/number-of-music-playlists,48.0,35.4,https://leetcode.com/problems/number-of-music-playlists,74,14.2K,29.6K,"Salesforce,Facebook",Dynamic Programming,542,56,91,1,,"class Solution {
public:
    int numMusicPlaylists(int n, int goal, int k) {
        
    }
};","class Solution {
    public int numMusicPlaylists(int n, int goal, int k) {
        
    }
}","class Solution(object):
    def numMusicPlaylists(self, n, goal, k):
        """"""
        :type n: int
        :type goal: int
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:
        ","int numMusicPlaylists(int n, int goal, int k){

}","public class Solution {
    public int NumMusicPlaylists(int n, int goal, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number} goal
 * @param {number} k
 * @return {number}
 */
var numMusicPlaylists = function(n, goal, k) {
    
};","# @param {Integer} n
# @param {Integer} goal
# @param {Integer} k
# @return {Integer}
def num_music_playlists(n, goal, k)
    
end","class Solution {
    func numMusicPlaylists(_ n: Int, _ goal: Int, _ k: Int) -> Int {
        
    }
}","func numMusicPlaylists(n int, goal int, k int) int {
    
}","object Solution {
    def numMusicPlaylists(n: Int, goal: Int, k: Int): Int = {
        
    }
}","class Solution {
    fun numMusicPlaylists(n: Int, goal: Int, k: Int): Int {
        
    }
}","impl Solution {
    pub fn num_music_playlists(n: i32, goal: i32, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $goal
     * @param Integer $k
     * @return Integer
     */
    function numMusicPlaylists($n, $goal, $k) {
        
    }
}","function numMusicPlaylists(n: number, goal: number, k: number): number {

};","(define/contract (num-music-playlists n goal k)
  (-> exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec num_music_playlists(N :: integer(), Goal :: integer(), K :: integer()) -> integer().
num_music_playlists(N, Goal, K) ->
  .","defmodule Solution do
  @spec num_music_playlists(n :: integer, goal :: integer, k :: integer) :: integer
  def num_music_playlists(n, goal, k) do

  end
end","class Solution {
  int numMusicPlaylists(int n, int goal, int k) {

  }
}",,,,number-of-music-playlists
146,924,Minimize Malware Spread,"You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.
Some nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.
Suppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from `initial`.
Return the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.
Note that if a node was removed from the `initial` list of infected nodes, it might still be infected later due to the malware spread.",0,Hard,/articles/minimize-malware-spread,41.9,14.4,https://leetcode.com/problems/minimize-malware-spread,207,30K,71.4K,ByteDance,"Depth-first Search,Union Find",411,307,57,0,,"class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
    }
};","class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
    }
}","class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """"""
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        ","int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){

}","public class Solution {
    public int MinMalwareSpread(int[][] graph, int[] initial) {
        
    }
}","/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
    
};","# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread(graph, initial)
    
end","class Solution {
    func minMalwareSpread(_ graph: [[Int]], _ initial: [Int]) -> Int {
        
    }
}","func minMalwareSpread(graph [][]int, initial []int) int {
    
}","object Solution {
    def minMalwareSpread(graph: Array[Array[Int]], initial: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minMalwareSpread(graph: Array<IntArray>, initial: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $graph
     * @param Integer[] $initial
     * @return Integer
     */
    function minMalwareSpread($graph, $initial) {
        
    }
}","function minMalwareSpread(graph: number[][], initial: number[]): number {

};","(define/contract (min-malware-spread graph initial)
  (-> (listof (listof exact-integer?)) (listof exact-integer?) exact-integer?)

  )","-spec min_malware_spread(Graph :: [[integer()]], Initial :: [integer()]) -> integer().
min_malware_spread(Graph, Initial) ->
  .","defmodule Solution do
  @spec min_malware_spread(graph :: [[integer]], initial :: [integer]) :: integer
  def min_malware_spread(graph, initial) do

  end
end","class Solution {
  int minMalwareSpread(List<List<int>> graph, List<int> initial) {

  }
}",,,,minimize-malware-spread
147,927,Three Equal Parts,"You are given an array `arr` which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value.
If it is possible, return any `[i, j]` with `i + 1 < j`, such that:
`arr[0], arr[1], ..., arr[i]` is the first part,
`arr[i + 1], arr[i + 2], ..., arr[j - 1]` is the second part, and
`arr[j], arr[j + 1], ..., arr[arr.length - 1]` is the third part.
All three parts have equal binary values.
If it is not possible, return `[-1, -1]`.
Note that the entire part is used when considering what binary value it represents. For example, `[1,1,0]` represents `6` in decimal, not `3`. Also, leading zeros are allowed, so `[0,1,1]` and `[1,1]` represent the same value.",0,Hard,/articles/three-equal-parts,34.7,5.5,https://leetcode.com/problems/three-equal-parts,131,9.2K,26.4K,"Netflix,Hotstar","Math,Binary Search,Greedy",296,63,82,1,,"class Solution {
public:
    vector<int> threeEqualParts(vector<int>& arr) {
        
    }
};","class Solution {
    public int[] threeEqualParts(int[] arr) {
        
    }
}","class Solution(object):
    def threeEqualParts(self, arr):
        """"""
        :type arr: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def threeEqualParts(self, arr: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* threeEqualParts(int* arr, int arrSize, int* returnSize){

}","public class Solution {
    public int[] ThreeEqualParts(int[] arr) {
        
    }
}","/**
 * @param {number[]} arr
 * @return {number[]}
 */
var threeEqualParts = function(arr) {
    
};","# @param {Integer[]} arr
# @return {Integer[]}
def three_equal_parts(arr)
    
end","class Solution {
    func threeEqualParts(_ arr: [Int]) -> [Int] {
        
    }
}","func threeEqualParts(arr []int) []int {
    
}","object Solution {
    def threeEqualParts(arr: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun threeEqualParts(arr: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn three_equal_parts(arr: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr
     * @return Integer[]
     */
    function threeEqualParts($arr) {
        
    }
}","function threeEqualParts(arr: number[]): number[] {

};","(define/contract (three-equal-parts arr)
  (-> (listof exact-integer?) (listof exact-integer?))

  )","-spec three_equal_parts(Arr :: [integer()]) -> [integer()].
three_equal_parts(Arr) ->
  .","defmodule Solution do
  @spec three_equal_parts(arr :: [integer]) :: [integer]
  def three_equal_parts(arr) do

  end
end","class Solution {
  List<int> threeEqualParts(List<int> arr) {

  }
}",,,,three-equal-parts
148,928,Minimize Malware Spread II,"You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.
Some nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.
Suppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops.
We will remove exactly one node from `initial`, completely removing it and any connections from this node to any other node.
Return the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.",0,Hard,/articles/minimize-malware-spread-ii,41.5,14.6,https://leetcode.com/problems/minimize-malware-spread-ii,107,12.2K,29.3K,Dropbox,"Depth-first Search,Union Find,Graph",278,60,82,0,,"class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
    }
};","class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
    }
}","class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """"""
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        ","int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){

}","public class Solution {
    public int MinMalwareSpread(int[][] graph, int[] initial) {
        
    }
}","/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
    
};","# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread(graph, initial)
    
end","class Solution {
    func minMalwareSpread(_ graph: [[Int]], _ initial: [Int]) -> Int {
        
    }
}","func minMalwareSpread(graph [][]int, initial []int) int {
    
}","object Solution {
    def minMalwareSpread(graph: Array[Array[Int]], initial: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minMalwareSpread(graph: Array<IntArray>, initial: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $graph
     * @param Integer[] $initial
     * @return Integer
     */
    function minMalwareSpread($graph, $initial) {
        
    }
}","function minMalwareSpread(graph: number[][], initial: number[]): number {

};","(define/contract (min-malware-spread graph initial)
  (-> (listof (listof exact-integer?)) (listof exact-integer?) exact-integer?)

  )","-spec min_malware_spread(Graph :: [[integer()]], Initial :: [integer()]) -> integer().
min_malware_spread(Graph, Initial) ->
  .","defmodule Solution do
  @spec min_malware_spread(graph :: [[integer]], initial :: [integer]) :: integer
  def min_malware_spread(graph, initial) do

  end
end","class Solution {
  int minMalwareSpread(List<List<int>> graph, List<int> initial) {

  }
}",,,,minimize-malware-spread-ii
149,936,Stamping The Sequence,"You want to form a `target` string of lowercase letters.
At the beginning, your sequence is `target.length` `'?'` marks.  You also have a `stamp` of lowercase letters.
On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to `10 * target.length` turns.
For example, if the initial sequence is ""?????"", and your stamp is `""abc""`,  then you may make ""abc??"", ""?abc?"", ""??abc"" in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.)
If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array.
For example, if the sequence is ""ababc"", and the stamp is `""abc""`, then we could return the answer `[0, 2]`, corresponding to the moves ""?????"" -> ""abc??"" -> ""ababc"".
Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within `10 * target.length` moves.  Any answers specifying more than this number of moves will not be accepted.",0,Hard,/articles/stamping-the-sequence,53.4,0.5,https://leetcode.com/problems/stamping-the-sequence,105,21.8K,40.8K,Facebook,"String,Greedy",431,108,80,1,,"class Solution {
public:
    vector<int> movesToStamp(string stamp, string target) {
        
    }
};","class Solution {
    public int[] movesToStamp(String stamp, String target) {
        
    }
}","class Solution(object):
    def movesToStamp(self, stamp, target):
        """"""
        :type stamp: str
        :type target: str
        :rtype: List[int]
        """"""
        ","class Solution:
    def movesToStamp(self, stamp: str, target: str) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* movesToStamp(char * stamp, char * target, int* returnSize){

}","public class Solution {
    public int[] MovesToStamp(string stamp, string target) {
        
    }
}","/**
 * @param {string} stamp
 * @param {string} target
 * @return {number[]}
 */
var movesToStamp = function(stamp, target) {
    
};","# @param {String} stamp
# @param {String} target
# @return {Integer[]}
def moves_to_stamp(stamp, target)
    
end","class Solution {
    func movesToStamp(_ stamp: String, _ target: String) -> [Int] {
        
    }
}","func movesToStamp(stamp string, target string) []int {
    
}","object Solution {
    def movesToStamp(stamp: String, target: String): Array[Int] = {
        
    }
}","class Solution {
    fun movesToStamp(stamp: String, target: String): IntArray {
        
    }
}","impl Solution {
    pub fn moves_to_stamp(stamp: String, target: String) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param String $stamp
     * @param String $target
     * @return Integer[]
     */
    function movesToStamp($stamp, $target) {
        
    }
}","function movesToStamp(stamp: string, target: string): number[] {

};",,"-spec moves_to_stamp(Stamp :: unicode:unicode_binary(), Target :: unicode:unicode_binary()) -> [integer()].
moves_to_stamp(Stamp, Target) ->
  .","defmodule Solution do
  @spec moves_to_stamp(stamp :: String.t, target :: String.t) :: [integer]
  def moves_to_stamp(stamp, target) do

  end
end","class Solution {
  List<int> movesToStamp(String stamp, String target) {

  }
}",,,,stamping-the-sequence
150,940,Distinct Subsequences II,"Given a string `S`, count the number of distinct, non-empty subsequences of `S` .
Since the result may be large, return the answer modulo `10^9 + 7`.",0,Hard,/articles/distinct-subsequences-ii,41.5,25.4,https://leetcode.com/problems/distinct-subsequences-ii,84,13.9K,33.4K,,,520,17,97,0,,"class Solution {
public:
    int distinctSubseqII(string s) {
        
    }
};","class Solution {
    public int distinctSubseqII(String s) {
        
    }
}","class Solution(object):
    def distinctSubseqII(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def distinctSubseqII(self, s: str) -> int:
        ","int distinctSubseqII(char * s){

}","public class Solution {
    public int DistinctSubseqII(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var distinctSubseqII = function(s) {
    
};","# @param {String} s
# @return {Integer}
def distinct_subseq_ii(s)
    
end","class Solution {
    func distinctSubseqII(_ s: String) -> Int {
        
    }
}","func distinctSubseqII(s string) int {
    
}","object Solution {
    def distinctSubseqII(s: String): Int = {
        
    }
}","class Solution {
    fun distinctSubseqII(s: String): Int {
        
    }
}","impl Solution {
    pub fn distinct_subseq_ii(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function distinctSubseqII($s) {
        
    }
}","function distinctSubseqII(s: string): number {

};","(define/contract (distinct-subseq-ii s)
  (-> string? exact-integer?)

  )","-spec distinct_subseq_ii(S :: unicode:unicode_binary()) -> integer().
distinct_subseq_ii(S) ->
  .","defmodule Solution do
  @spec distinct_subseq_ii(s :: String.t) :: integer
  def distinct_subseq_ii(s) do

  end
end","class Solution {
  int distinctSubseqII(String s) {

  }
}",,,,distinct-subsequences-ii
151,943,Find the Shortest Superstring,"Given an array of strings `words`, return the smallest string that contains each string in `words` as a substring. If there are multiple valid strings of the smallest length, return any of them.
You may assume that no string in `words` is a substring of another string in `words`.",0,Hard,/articles/find-the-shortest-superstring,43.4,10.3,https://leetcode.com/problems/find-the-shortest-superstring,81,12.7K,29.3K,"Amazon,Google",Dynamic Programming,515,78,87,1,,"class Solution {
public:
    string shortestSuperstring(vector<string>& words) {
        
    }
};","class Solution {
    public String shortestSuperstring(String[] words) {
        
    }
}","class Solution(object):
    def shortestSuperstring(self, words):
        """"""
        :type words: List[str]
        :rtype: str
        """"""
        ","class Solution:
    def shortestSuperstring(self, words: List[str]) -> str:
        ","char * shortestSuperstring(char ** words, int wordsSize){

}","public class Solution {
    public string ShortestSuperstring(string[] words) {
        
    }
}","/**
 * @param {string[]} words
 * @return {string}
 */
var shortestSuperstring = function(words) {
    
};","# @param {String[]} words
# @return {String}
def shortest_superstring(words)
    
end","class Solution {
    func shortestSuperstring(_ words: [String]) -> String {
        
    }
}","func shortestSuperstring(words []string) string {
    
}","object Solution {
    def shortestSuperstring(words: Array[String]): String = {
        
    }
}","class Solution {
    fun shortestSuperstring(words: Array<String>): String {
        
    }
}","impl Solution {
    pub fn shortest_superstring(words: Vec<String>) -> String {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @return String
     */
    function shortestSuperstring($words) {
        
    }
}","function shortestSuperstring(words: string[]): string {

};","(define/contract (shortest-superstring words)
  (-> (listof string?) string?)

  )","-spec shortest_superstring(Words :: [unicode:unicode_binary()]) -> unicode:unicode_binary().
shortest_superstring(Words) ->
  .","defmodule Solution do
  @spec shortest_superstring(words :: [String.t]) :: String.t
  def shortest_superstring(words) do

  end
end","class Solution {
  String shortestSuperstring(List<String> words) {

  }
}",,,,find-the-shortest-superstring
152,952,Largest Component Size by Common Factor,"Given a non-empty array of unique positive integers `A`, consider the following graph:
There are `A.length` nodes, labelled `A[0]` to `A[A.length - 1];`
There is an edge between `A[i]` and `A[j]` if and only if `A[i]` and `A[j]` share a common factor greater than 1.
Return the size of the largest connected component in the graph.",0,Hard,/articles/largest-component-size-by-common-factor,36.4,2.2,https://leetcode.com/problems/largest-component-size-by-common-factor,145,26.1K,71.8K,Google,"Math,Union Find",564,67,89,1,,"class Solution {
public:
    int largestComponentSize(vector<int>& nums) {
        
    }
};","class Solution {
    public int largestComponentSize(int[] nums) {
        
    }
}","class Solution(object):
    def largestComponentSize(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def largestComponentSize(self, nums: List[int]) -> int:
        ","int largestComponentSize(int* nums, int numsSize){

}","public class Solution {
    public int LargestComponentSize(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var largestComponentSize = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def largest_component_size(nums)
    
end","class Solution {
    func largestComponentSize(_ nums: [Int]) -> Int {
        
    }
}","func largestComponentSize(nums []int) int {
    
}","object Solution {
    def largestComponentSize(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun largestComponentSize(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn largest_component_size(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function largestComponentSize($nums) {
        
    }
}","function largestComponentSize(nums: number[]): number {

};","(define/contract (largest-component-size nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec largest_component_size(Nums :: [integer()]) -> integer().
largest_component_size(Nums) ->
  .","defmodule Solution do
  @spec largest_component_size(nums :: [integer]) :: integer
  def largest_component_size(nums) do

  end
end","class Solution {
  int largestComponentSize(List<int> nums) {

  }
}",,,,largest-component-size-by-common-factor
153,956,Tallest Billboard,"You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.
You are given a collection of `rods` that can be welded together. For example, if you have rods of lengths `1`, `2`, and `3`, you can weld them together to make a support of length `6`.
Return the largest possible height of your billboard installation. If you cannot support the billboard, return `0`.",0,Hard,/articles/tallest-billboard,39.9,23.5,https://leetcode.com/problems/tallest-billboard,63,9.7K,24.4K,,,441,18,96,0,,"class Solution {
public:
    int tallestBillboard(vector<int>& rods) {
        
    }
};","class Solution {
    public int tallestBillboard(int[] rods) {
        
    }
}","class Solution(object):
    def tallestBillboard(self, rods):
        """"""
        :type rods: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def tallestBillboard(self, rods: List[int]) -> int:
        ","int tallestBillboard(int* rods, int rodsSize){

}","public class Solution {
    public int TallestBillboard(int[] rods) {
        
    }
}","/**
 * @param {number[]} rods
 * @return {number}
 */
var tallestBillboard = function(rods) {
    
};","# @param {Integer[]} rods
# @return {Integer}
def tallest_billboard(rods)
    
end","class Solution {
    func tallestBillboard(_ rods: [Int]) -> Int {
        
    }
}","func tallestBillboard(rods []int) int {
    
}","object Solution {
    def tallestBillboard(rods: Array[Int]): Int = {
        
    }
}","class Solution {
    fun tallestBillboard(rods: IntArray): Int {
        
    }
}","impl Solution {
    pub fn tallest_billboard(rods: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $rods
     * @return Integer
     */
    function tallestBillboard($rods) {
        
    }
}","function tallestBillboard(rods: number[]): number {

};","(define/contract (tallest-billboard rods)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec tallest_billboard(Rods :: [integer()]) -> integer().
tallest_billboard(Rods) ->
  .","defmodule Solution do
  @spec tallest_billboard(rods :: [integer]) :: integer
  def tallest_billboard(rods) do

  end
end","class Solution {
  int tallestBillboard(List<int> rods) {

  }
}",,,,tallest-billboard
154,960,Delete Columns to Make Sorted III,"You are given an array of `n` strings `strs`, all of the same length.
We may choose any deletion indices, and we delete all the characters in those indices for each string.
For example, if we have `strs = [""abcdef"",""uvwxyz""]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `[""bef"", ""vyz""]`.
Suppose we chose a set of deletion indices `answer` such that after deletions, the final array has every string (row) in lexicographic order. (i.e., `(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])`, and `(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])`, and so on). Return the minimum possible value of `answer.length`.",0,Hard,/articles/delete-columns-to-make-sorted-iii,55.1,7.0,https://leetcode.com/problems/delete-columns-to-make-sorted-iii,62,8.1K,14.8K,Google,Dynamic Programming,301,9,97,1,,"class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        
    }
};","class Solution {
    public int minDeletionSize(String[] strs) {
        
    }
}","class Solution(object):
    def minDeletionSize(self, strs):
        """"""
        :type strs: List[str]
        :rtype: int
        """"""
        ","class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        ","int minDeletionSize(char ** strs, int strsSize){

}","public class Solution {
    public int MinDeletionSize(string[] strs) {
        
    }
}","/**
 * @param {string[]} strs
 * @return {number}
 */
var minDeletionSize = function(strs) {
    
};","# @param {String[]} strs
# @return {Integer}
def min_deletion_size(strs)
    
end","class Solution {
    func minDeletionSize(_ strs: [String]) -> Int {
        
    }
}","func minDeletionSize(strs []string) int {
    
}","object Solution {
    def minDeletionSize(strs: Array[String]): Int = {
        
    }
}","class Solution {
    fun minDeletionSize(strs: Array<String>): Int {
        
    }
}","impl Solution {
    pub fn min_deletion_size(strs: Vec<String>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $strs
     * @return Integer
     */
    function minDeletionSize($strs) {
        
    }
}","function minDeletionSize(strs: string[]): number {

};","(define/contract (min-deletion-size strs)
  (-> (listof string?) exact-integer?)

  )","-spec min_deletion_size(Strs :: [unicode:unicode_binary()]) -> integer().
min_deletion_size(Strs) ->
  .","defmodule Solution do
  @spec min_deletion_size(strs :: [String.t]) :: integer
  def min_deletion_size(strs) do

  end
end","class Solution {
  int minDeletionSize(List<String> strs) {

  }
}",,,,delete-columns-to-make-sorted-iii
155,964,Least Operators to Express Number,"Given a single positive integer `x`, we will write an expression of the form `x (op1) x (op2) x (op3) x ...` where each operator `op1`, `op2`, etc. is either addition, subtraction, multiplication, or division (`+`, `-`, `*`, or `/)`. For example, with `x = 3`, we might write `3 * 3 / 3 + 3 - 3` which is a value of 3.
When writing such an expression, we adhere to the following conventions:
The division operator (`/`) returns rational numbers.
There are no parentheses placed anywhere.
We use the usual order of operations: multiplication and division happen before addition and subtraction.
It is not allowed to use the unary negation operator (`-`). For example, ""`x - x`"" is a valid expression as it only uses subtraction, but ""`-x + x`"" is not because it uses negation.
We would like to write an expression with the least number of operators such that the expression equals the given `target`. Return the least number of operators used.",0,Hard,/articles/least-operators-to-express-number,45.2,11.4,https://leetcode.com/problems/least-operators-to-express-number,42,6.3K,13.9K,Snapchat,"Math,Dynamic Programming",207,54,79,0,,"class Solution {
public:
    int leastOpsExpressTarget(int x, int target) {
        
    }
};","class Solution {
    public int leastOpsExpressTarget(int x, int target) {
        
    }
}","class Solution(object):
    def leastOpsExpressTarget(self, x, target):
        """"""
        :type x: int
        :type target: int
        :rtype: int
        """"""
        ","class Solution:
    def leastOpsExpressTarget(self, x: int, target: int) -> int:
        ","int leastOpsExpressTarget(int x, int target){

}","public class Solution {
    public int LeastOpsExpressTarget(int x, int target) {
        
    }
}","/**
 * @param {number} x
 * @param {number} target
 * @return {number}
 */
var leastOpsExpressTarget = function(x, target) {
    
};","# @param {Integer} x
# @param {Integer} target
# @return {Integer}
def least_ops_express_target(x, target)
    
end","class Solution {
    func leastOpsExpressTarget(_ x: Int, _ target: Int) -> Int {
        
    }
}","func leastOpsExpressTarget(x int, target int) int {
    
}","object Solution {
    def leastOpsExpressTarget(x: Int, target: Int): Int = {
        
    }
}","class Solution {
    fun leastOpsExpressTarget(x: Int, target: Int): Int {
        
    }
}","impl Solution {
    pub fn least_ops_express_target(x: i32, target: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $x
     * @param Integer $target
     * @return Integer
     */
    function leastOpsExpressTarget($x, $target) {
        
    }
}","function leastOpsExpressTarget(x: number, target: number): number {

};","(define/contract (least-ops-express-target x target)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec least_ops_express_target(X :: integer(), Target :: integer()) -> integer().
least_ops_express_target(X, Target) ->
  .","defmodule Solution do
  @spec least_ops_express_target(x :: integer, target :: integer) :: integer
  def least_ops_express_target(x, target) do

  end
end","class Solution {
  int leastOpsExpressTarget(int x, int target) {

  }
}",,,,least-operators-to-express-number
157,972,Equal Rational Numbers,"Given two strings `s` and `t`, each of which represents a non-negative rational number, return `true` if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.
A rational number can be represented using up to three parts: `<IntegerPart>`, `<NonRepeatingPart>`, and a `<RepeatingPart>`. The number will be represented in one of the following three ways:
`<IntegerPart>`
For example, `12`, `0`, and `123`.
`<IntegerPart><.><NonRepeatingPart>`
For example, `0.5`, `1.`, `2.12`, and `123.0001`.
`<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>`
For example, `0.1(6)`, `1.(9)`, `123.00(1212)`.
The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example:
`1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)`.",0,Hard,/articles/equal-rational-numbers,42.1,0.0,https://leetcode.com/problems/equal-rational-numbers,60,4.6K,10.8K,Microsoft,Math,54,160,25,0,,"class Solution {
public:
    bool isRationalEqual(string s, string t) {
        
    }
};","class Solution {
    public boolean isRationalEqual(String s, String t) {
        
    }
}","class Solution(object):
    def isRationalEqual(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: bool
        """"""
        ","class Solution:
    def isRationalEqual(self, s: str, t: str) -> bool:
        ","bool isRationalEqual(char * s, char * t){

}","public class Solution {
    public bool IsRationalEqual(string s, string t) {
        
    }
}","/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isRationalEqual = function(s, t) {
    
};","# @param {String} s
# @param {String} t
# @return {Boolean}
def is_rational_equal(s, t)
    
end","class Solution {
    func isRationalEqual(_ s: String, _ t: String) -> Bool {
        
    }
}","func isRationalEqual(s string, t string) bool {
    
}","object Solution {
    def isRationalEqual(s: String, t: String): Boolean = {
        
    }
}","class Solution {
    fun isRationalEqual(s: String, t: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_rational_equal(s: String, t: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $t
     * @return Boolean
     */
    function isRationalEqual($s, $t) {
        
    }
}","function isRationalEqual(s: string, t: string): boolean {

};","(define/contract (is-rational-equal s t)
  (-> string? string? boolean?)

  )","-spec is_rational_equal(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> boolean().
is_rational_equal(S, T) ->
  .","defmodule Solution do
  @spec is_rational_equal(s :: String.t, t :: String.t) :: boolean
  def is_rational_equal(s, t) do

  end
end","class Solution {
  bool isRationalEqual(String s, String t) {

  }
}",,,,equal-rational-numbers
158,975,Odd Even Jump,"You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.
You may jump forward from index `i` to index `j` (with `i < j`) in the following way:
During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.
During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.
It may be the case that for some index `i`, there are no legal jumps.
A starting index is good if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).
Return the number of good starting indices.",0,Hard,/articles/odd-even-jump,41.5,7.1,https://leetcode.com/problems/odd-even-jump,220,40.2K,97K,Google,"Dynamic Programming,Stack,Ordered Map",916,283,76,1,,"class Solution {
public:
    int oddEvenJumps(vector<int>& arr) {
        
    }
};","class Solution {
    public int oddEvenJumps(int[] arr) {
        
    }
}","class Solution(object):
    def oddEvenJumps(self, arr):
        """"""
        :type arr: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def oddEvenJumps(self, arr: List[int]) -> int:
        ","int oddEvenJumps(int* arr, int arrSize){

}","public class Solution {
    public int OddEvenJumps(int[] arr) {
        
    }
}","/**
 * @param {number[]} arr
 * @return {number}
 */
var oddEvenJumps = function(arr) {
    
};","# @param {Integer[]} arr
# @return {Integer}
def odd_even_jumps(arr)
    
end","class Solution {
    func oddEvenJumps(_ arr: [Int]) -> Int {
        
    }
}","func oddEvenJumps(arr []int) int {
    
}","object Solution {
    def oddEvenJumps(arr: Array[Int]): Int = {
        
    }
}","class Solution {
    fun oddEvenJumps(arr: IntArray): Int {
        
    }
}","impl Solution {
    pub fn odd_even_jumps(arr: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr
     * @return Integer
     */
    function oddEvenJumps($arr) {
        
    }
}","function oddEvenJumps(arr: number[]): number {

};","(define/contract (odd-even-jumps arr)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec odd_even_jumps(Arr :: [integer()]) -> integer().
odd_even_jumps(Arr) ->
  .","defmodule Solution do
  @spec odd_even_jumps(arr :: [integer]) :: integer
  def odd_even_jumps(arr) do

  end
end","class Solution {
  int oddEvenJumps(List<int> arr) {

  }
}",,,,odd-even-jump
159,980,Unique Paths III,"On a 2-dimensional `grid`, there are 4 types of squares:
`1` represents the starting square.  There is exactly one starting square.
`2` represents the ending square.  There is exactly one ending square.
`0` represents empty squares we can walk over.
`-1` represents obstacles that we cannot walk over.
Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.",0,Hard,/articles/unique-paths-iii,77.0,26.6,https://leetcode.com/problems/unique-paths-iii,695,68.6K,89K,"Amazon,JPMorgan","Backtracking,Depth-first Search",1376,90,94,1,"[Sudoku Solver, /problems/sudoku-solver/, Hard], [Unique Paths II, /problems/unique-paths-ii/, Medium], [Word Search II, /problems/word-search-ii/, Hard]","class Solution {
public:
    int uniquePathsIII(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int uniquePathsIII(int[][] grid) {
        
    }
}","class Solution(object):
    def uniquePathsIII(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        ","int uniquePathsIII(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int UniquePathsIII(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var uniquePathsIII = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def unique_paths_iii(grid)
    
end","class Solution {
    func uniquePathsIII(_ grid: [[Int]]) -> Int {
        
    }
}","func uniquePathsIII(grid [][]int) int {
    
}","object Solution {
    def uniquePathsIII(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun uniquePathsIII(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn unique_paths_iii(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function uniquePathsIII($grid) {
        
    }
}","function uniquePathsIII(grid: number[][]): number {

};",,"-spec unique_paths_iii(Grid :: [[integer()]]) -> integer().
unique_paths_iii(Grid) ->
  .","defmodule Solution do
  @spec unique_paths_iii(grid :: [[integer]]) :: integer
  def unique_paths_iii(grid) do

  end
end","class Solution {
  int uniquePathsIII(List<List<int>> grid) {

  }
}",,,,unique-paths-iii
160,982,Triples with Bitwise AND Equal To Zero,"Given an array of integers `A`, find the number of triples of indices (i, j, k) such that:
`0 <= i < A.length`
`0 <= j < A.length`
`0 <= k < A.length`
`A[i] & A[j] & A[k] == 0`, where `&` represents the bitwise-AND operator.",0,Hard,,56.3,0.0,https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero,79,9.8K,17.3K,Flipkart,Dynamic Programming,148,156,49,0,,"class Solution {
public:
    int countTriplets(vector<int>& nums) {
        
    }
};","class Solution {
    public int countTriplets(int[] nums) {
        
    }
}","class Solution(object):
    def countTriplets(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def countTriplets(self, nums: List[int]) -> int:
        ","int countTriplets(int* nums, int numsSize){

}","public class Solution {
    public int CountTriplets(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var countTriplets = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def count_triplets(nums)
    
end","class Solution {
    func countTriplets(_ nums: [Int]) -> Int {
        
    }
}","func countTriplets(nums []int) int {
    
}","object Solution {
    def countTriplets(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun countTriplets(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn count_triplets(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function countTriplets($nums) {
        
    }
}","function countTriplets(nums: number[]): number {

};","(define/contract (count-triplets nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec count_triplets(Nums :: [integer()]) -> integer().
count_triplets(Nums) ->
  .","defmodule Solution do
  @spec count_triplets(nums :: [integer]) :: integer
  def count_triplets(nums) do

  end
end","class Solution {
  int countTriplets(List<int> nums) {

  }
}",,,,triples-with-bitwise-and-equal-to-zero
162,992,Subarrays with K Different Integers,"Given an array `A` of positive integers, call a (contiguous, not necessarily distinct) subarray of `A` good if the number of different integers in that subarray is exactly `K`.
(For example, `[1,2,3,1,2]` has `3` different integers: `1`, `2`, and `3`.)
Return the number of good subarrays of `A`.",0,Hard,/articles/subarrays-with-k-different-integers,50.9,38.8,https://leetcode.com/problems/subarrays-with-k-different-integers,227,42.8K,84.1K,"Amazon,Google","Hash Table,Two Pointers,Sliding Window",1663,28,98,1,"[Longest Substring Without Repeating Characters, /problems/longest-substring-without-repeating-characters/, Medium], [Longest Substring with At Most Two Distinct Characters, /problems/longest-substring-with-at-most-two-distinct-characters/, Medium], [Longest Substring with At Most K Distinct Characters, /problems/longest-substring-with-at-most-k-distinct-characters/, Medium]","class Solution {
public:
    int subarraysWithKDistinct(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int subarraysWithKDistinct(int[] nums, int k) {
        
    }
}","class Solution(object):
    def subarraysWithKDistinct(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
        ","int subarraysWithKDistinct(int* nums, int numsSize, int k){

}","public class Solution {
    public int SubarraysWithKDistinct(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraysWithKDistinct = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def subarrays_with_k_distinct(nums, k)
    
end","class Solution {
    func subarraysWithKDistinct(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func subarraysWithKDistinct(nums []int, k int) int {
    
}","object Solution {
    def subarraysWithKDistinct(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn subarrays_with_k_distinct(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function subarraysWithKDistinct($nums, $k) {
        
    }
}","function subarraysWithKDistinct(nums: number[], k: number): number {

};","(define/contract (subarrays-with-k-distinct nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec subarrays_with_k_distinct(Nums :: [integer()], K :: integer()) -> integer().
subarrays_with_k_distinct(Nums, K) ->
  .","defmodule Solution do
  @spec subarrays_with_k_distinct(nums :: [integer], k :: integer) :: integer
  def subarrays_with_k_distinct(nums, k) do

  end
end","class Solution {
  int subarraysWithKDistinct(List<int> nums, int k) {

  }
}",,,,subarrays-with-k-different-integers
163,995,Minimum Number of K Consecutive Bit Flips,"In an array `A` containing only 0s and 1s, a `K`-bit flip consists of choosing a (contiguous) subarray of length `K` and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.
Return the minimum number of `K`-bit flips required so that there is no 0 in the array.  If it is not possible, return `-1`.",0,Hard,/articles/minimum-number-of-k-consecutive-bit-flips,50.0,15.0,https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips,111,19.4K,38.8K,"Google,Amazon","Greedy,Sliding Window",517,42,92,1,"[Bulb Switcher, /problems/bulb-switcher/, Medium]","class Solution {
public:
    int minKBitFlips(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int minKBitFlips(int[] nums, int k) {
        
    }
}","class Solution(object):
    def minKBitFlips(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minKBitFlips(self, nums: List[int], k: int) -> int:
        ","int minKBitFlips(int* nums, int numsSize, int k){

}","public class Solution {
    public int MinKBitFlips(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minKBitFlips = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def min_k_bit_flips(nums, k)
    
end","class Solution {
    func minKBitFlips(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func minKBitFlips(nums []int, k int) int {
    
}","object Solution {
    def minKBitFlips(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun minKBitFlips(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function minKBitFlips($nums, $k) {
        
    }
}","function minKBitFlips(nums: number[], k: number): number {

};","(define/contract (min-k-bit-flips nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_k_bit_flips(Nums :: [integer()], K :: integer()) -> integer().
min_k_bit_flips(Nums, K) ->
  .","defmodule Solution do
  @spec min_k_bit_flips(nums :: [integer], k :: integer) :: integer
  def min_k_bit_flips(nums, k) do

  end
end","class Solution {
  int minKBitFlips(List<int> nums, int k) {

  }
}",,,,minimum-number-of-k-consecutive-bit-flips
164,996,Number of Squareful Arrays,"Given an array `A` of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.
Return the number of permutations of A that are squareful.  Two permutations `A1` and `A2` differ if and only if there is some index `i` such that `A1[i] != A2[i]`.",0,Hard,/articles/number-of-squareful-arrays,48.6,12.2,https://leetcode.com/problems/number-of-squareful-arrays,208,18.6K,38.3K,"Apple,Codenation","Math,Backtracking,Graph",465,23,95,1,"[Permutations II, /problems/permutations-ii/, Medium]","class Solution {
public:
    int numSquarefulPerms(vector<int>& nums) {
        
    }
};","class Solution {
    public int numSquarefulPerms(int[] nums) {
        
    }
}","class Solution(object):
    def numSquarefulPerms(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def numSquarefulPerms(self, nums: List[int]) -> int:
        ","int numSquarefulPerms(int* nums, int numsSize){

}","public class Solution {
    public int NumSquarefulPerms(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var numSquarefulPerms = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def num_squareful_perms(nums)
    
end","class Solution {
    func numSquarefulPerms(_ nums: [Int]) -> Int {
        
    }
}","func numSquarefulPerms(nums []int) int {
    
}","object Solution {
    def numSquarefulPerms(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun numSquarefulPerms(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn num_squareful_perms(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function numSquarefulPerms($nums) {
        
    }
}","function numSquarefulPerms(nums: number[]): number {

};","(define/contract (num-squareful-perms nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec num_squareful_perms(Nums :: [integer()]) -> integer().
num_squareful_perms(Nums) ->
  .","defmodule Solution do
  @spec num_squareful_perms(nums :: [integer]) :: integer
  def num_squareful_perms(nums) do

  end
end","class Solution {
  int numSquarefulPerms(List<int> nums) {

  }
}",,,,number-of-squareful-arrays
165,1000,Minimum Cost to Merge Stones,"There are `N` piles of stones arranged in a row.  The `i`-th pile has `stones[i]` stones.
A move consists of merging exactly `K` consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these `K` piles.
Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return `-1`.",0,Hard,,40.5,20.6,https://leetcode.com/problems/minimum-cost-to-merge-stones,112,19.6K,48.4K,Amazon,Dynamic Programming,903,58,94,1,"[Burst Balloons, /problems/burst-balloons/, Hard], [Minimum Cost to Connect Sticks, /problems/minimum-cost-to-connect-sticks/, Medium]","class Solution {
public:
    int mergeStones(vector<int>& stones, int k) {
        
    }
};","class Solution {
    public int mergeStones(int[] stones, int k) {
        
    }
}","class Solution(object):
    def mergeStones(self, stones, k):
        """"""
        :type stones: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        ","int mergeStones(int* stones, int stonesSize, int k){

}","public class Solution {
    public int MergeStones(int[] stones, int k) {
        
    }
}","/**
 * @param {number[]} stones
 * @param {number} k
 * @return {number}
 */
var mergeStones = function(stones, k) {
    
};","# @param {Integer[]} stones
# @param {Integer} k
# @return {Integer}
def merge_stones(stones, k)
    
end","class Solution {
    func mergeStones(_ stones: [Int], _ k: Int) -> Int {
        
    }
}","func mergeStones(stones []int, k int) int {
    
}","object Solution {
    def mergeStones(stones: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun mergeStones(stones: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn merge_stones(stones: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $stones
     * @param Integer $k
     * @return Integer
     */
    function mergeStones($stones, $k) {
        
    }
}","function mergeStones(stones: number[], k: number): number {

};","(define/contract (merge-stones stones k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec merge_stones(Stones :: [integer()], K :: integer()) -> integer().
merge_stones(Stones, K) ->
  .","defmodule Solution do
  @spec merge_stones(stones :: [integer], k :: integer) :: integer
  def merge_stones(stones, k) do

  end
end","class Solution {
  int mergeStones(List<int> stones, int k) {

  }
}",,,,minimum-cost-to-merge-stones
166,1001,Grid Illumination,"You are given a `grid` of size `N x N`, and each cell of this grid has a lamp that is initially turned off.
You are also given an array of lamp positions `lamps`, where `lamps[i] = [rowi, coli]` indicates that the lamp at `grid[rowi][coli]` is turned on. When a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal.
Finally, you are given a query array `queries`, where `queries[i] = [rowi, coli]`. For the `ith` query, determine whether `grid[rowi][coli]` is illuminated or not. After answering the `ith` query, turn off the lamp at `grid[rowi][coli]` and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with `grid[rowi][coli]`.
Return an array of integers `ans`, where `ans[i]` should be `1` if the lamp in the `ith` query was illuminated, or `0` if the lamp was not.",0,Hard,,36.0,32.9,https://leetcode.com/problems/grid-illumination,138,11.4K,31.5K,Dropbox,Hash Table,256,76,77,0,"[N-Queens, /problems/n-queens/, Hard]","class Solution {
public:
    vector<int> gridIllumination(int n, vector<vector<int>>& lamps, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public int[] gridIllumination(int n, int[][] lamps, int[][] queries) {
        
    }
}","class Solution(object):
    def gridIllumination(self, n, lamps, queries):
        """"""
        :type n: int
        :type lamps: List[List[int]]
        :type queries: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* gridIllumination(int n, int** lamps, int lampsSize, int* lampsColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public int[] GridIllumination(int n, int[][] lamps, int[][] queries) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} lamps
 * @param {number[][]} queries
 * @return {number[]}
 */
var gridIllumination = function(n, lamps, queries) {
    
};","# @param {Integer} n
# @param {Integer[][]} lamps
# @param {Integer[][]} queries
# @return {Integer[]}
def grid_illumination(n, lamps, queries)
    
end","class Solution {
    func gridIllumination(_ n: Int, _ lamps: [[Int]], _ queries: [[Int]]) -> [Int] {
        
    }
}","func gridIllumination(n int, lamps [][]int, queries [][]int) []int {
    
}","object Solution {
    def gridIllumination(n: Int, lamps: Array[Array[Int]], queries: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun gridIllumination(n: Int, lamps: Array<IntArray>, queries: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn grid_illumination(n: i32, lamps: Vec<Vec<i32>>, queries: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $lamps
     * @param Integer[][] $queries
     * @return Integer[]
     */
    function gridIllumination($n, $lamps, $queries) {
        
    }
}","function gridIllumination(n: number, lamps: number[][], queries: number[][]): number[] {

};","(define/contract (grid-illumination n lamps queries)
  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec grid_illumination(N :: integer(), Lamps :: [[integer()]], Queries :: [[integer()]]) -> [integer()].
grid_illumination(N, Lamps, Queries) ->
  .","defmodule Solution do
  @spec grid_illumination(n :: integer, lamps :: [[integer]], queries :: [[integer]]) :: [integer]
  def grid_illumination(n, lamps, queries) do

  end
end","class Solution {
  List<int> gridIllumination(int n, List<List<int>> lamps, List<List<int>> queries) {

  }
}",,,,grid-illumination
167,1012,Numbers With Repeated Digits,"Given a positive integer `N`, return the number of positive integers less than or equal to `N` that have at least 1 repeated digit.",0,Hard,,37.8,21.3,https://leetcode.com/problems/numbers-with-repeated-digits,79,7K,18.5K,"Akuna Capital,IBM","Math,Dynamic Programming",281,52,84,0,,"class Solution {
public:
    int numDupDigitsAtMostN(int n) {
        
    }
};","class Solution {
    public int numDupDigitsAtMostN(int n) {
        
    }
}","class Solution(object):
    def numDupDigitsAtMostN(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def numDupDigitsAtMostN(self, n: int) -> int:
        ","int numDupDigitsAtMostN(int n){

}","public class Solution {
    public int NumDupDigitsAtMostN(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var numDupDigitsAtMostN = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def num_dup_digits_at_most_n(n)
    
end","class Solution {
    func numDupDigitsAtMostN(_ n: Int) -> Int {
        
    }
}","func numDupDigitsAtMostN(n int) int {
    
}","object Solution {
    def numDupDigitsAtMostN(n: Int): Int = {
        
    }
}","class Solution {
    fun numDupDigitsAtMostN(n: Int): Int {
        
    }
}","impl Solution {
    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function numDupDigitsAtMostN($n) {
        
    }
}","function numDupDigitsAtMostN(n: number): number {

};","(define/contract (num-dup-digits-at-most-n n)
  (-> exact-integer? exact-integer?)

  )","-spec num_dup_digits_at_most_n(N :: integer()) -> integer().
num_dup_digits_at_most_n(N) ->
  .","defmodule Solution do
  @spec num_dup_digits_at_most_n(n :: integer) :: integer
  def num_dup_digits_at_most_n(n) do

  end
end","class Solution {
  int numDupDigitsAtMostN(int n) {

  }
}",,,,numbers-with-repeated-digits
170,1036,Escape a Large Maze,"There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are `(x, y)`.
We start at the `source = [sx, sy]` square and want to reach the `target = [tx, ty]` square. There is also an array of `blocked` squares, where each `blocked[i] = [xi, yi]` represents a blocked square with coordinates `(xi, yi)`.
Each move, we can walk one square north, east, south, or west if the square is not in the array of `blocked` squares. We are also not allowed to walk outside of the grid.
Return `true` if and only if it is possible to reach the `target` square from the `source` square through a sequence of valid moves.",0,Hard,,34.3,21.9,https://leetcode.com/problems/escape-a-large-maze,89,12K,35.1K,"Uber,Google,Facebook,UiPath",Breadth-first Search,291,117,71,1,,"class Solution {
public:
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        
    }
};","class Solution {
    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {
        
    }
}","class Solution(object):
    def isEscapePossible(self, blocked, source, target):
        """"""
        :type blocked: List[List[int]]
        :type source: List[int]
        :type target: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        ","bool isEscapePossible(int** blocked, int blockedSize, int* blockedColSize, int* source, int sourceSize, int* target, int targetSize){

}","public class Solution {
    public bool IsEscapePossible(int[][] blocked, int[] source, int[] target) {
        
    }
}","/**
 * @param {number[][]} blocked
 * @param {number[]} source
 * @param {number[]} target
 * @return {boolean}
 */
var isEscapePossible = function(blocked, source, target) {
    
};","# @param {Integer[][]} blocked
# @param {Integer[]} source
# @param {Integer[]} target
# @return {Boolean}
def is_escape_possible(blocked, source, target)
    
end","class Solution {
    func isEscapePossible(_ blocked: [[Int]], _ source: [Int], _ target: [Int]) -> Bool {
        
    }
}","func isEscapePossible(blocked [][]int, source []int, target []int) bool {
    
}","object Solution {
    def isEscapePossible(blocked: Array[Array[Int]], source: Array[Int], target: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun isEscapePossible(blocked: Array<IntArray>, source: IntArray, target: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn is_escape_possible(blocked: Vec<Vec<i32>>, source: Vec<i32>, target: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $blocked
     * @param Integer[] $source
     * @param Integer[] $target
     * @return Boolean
     */
    function isEscapePossible($blocked, $source, $target) {
        
    }
}","function isEscapePossible(blocked: number[][], source: number[], target: number[]): boolean {

};","(define/contract (is-escape-possible blocked source target)
  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?) boolean?)

  )","-spec is_escape_possible(Blocked :: [[integer()]], Source :: [integer()], Target :: [integer()]) -> boolean().
is_escape_possible(Blocked, Source, Target) ->
  .","defmodule Solution do
  @spec is_escape_possible(blocked :: [[integer]], source :: [integer], target :: [integer]) :: boolean
  def is_escape_possible(blocked, source, target) do

  end
end","class Solution {
  bool isEscapePossible(List<List<int>> blocked, List<int> source, List<int> target) {

  }
}",,,,escape-a-large-maze
171,1044,Longest Duplicate Substring,"Given a string `s`, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap.
Return any duplicated substring that has the longest possible length. If `s` does not have a duplicated substring, the answer is `""""`.",0,Hard,/articles/longest-duplicate-substring,31.4,13.5,https://leetcode.com/problems/longest-duplicate-substring,191,33.8K,107.7K,Amazon,"Hash Table,Binary Search,Suffix Array",802,248,76,1,,"class Solution {
public:
    string longestDupSubstring(string s) {
        
    }
};","class Solution {
    public String longestDupSubstring(String s) {
        
    }
}","class Solution(object):
    def longestDupSubstring(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        ","class Solution:
    def longestDupSubstring(self, s: str) -> str:
        ","char * longestDupSubstring(char * s){

}","public class Solution {
    public string LongestDupSubstring(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string}
 */
var longestDupSubstring = function(s) {
    
};","# @param {String} s
# @return {String}
def longest_dup_substring(s)
    
end","class Solution {
    func longestDupSubstring(_ s: String) -> String {
        
    }
}","func longestDupSubstring(s string) string {
    
}","object Solution {
    def longestDupSubstring(s: String): String = {
        
    }
}","class Solution {
    fun longestDupSubstring(s: String): String {
        
    }
}","impl Solution {
    pub fn longest_dup_substring(s: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String
     */
    function longestDupSubstring($s) {
        
    }
}","function longestDupSubstring(s: string): string {

};",,"-spec longest_dup_substring(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
longest_dup_substring(S) ->
  .","defmodule Solution do
  @spec longest_dup_substring(s :: String.t) :: String.t
  def longest_dup_substring(s) do

  end
end","class Solution {
  String longestDupSubstring(String s) {

  }
}",,,,longest-duplicate-substring
172,1074,Number of Submatrices That Sum to Target,"Given a `matrix` and a `target`, return the number of non-empty submatrices that sum to target.
A submatrix `x1, y1, x2, y2` is the set of all cells `matrix[x][y]` with `x1 <= x <= x2` and `y1 <= y <= y2`.
Two submatrices `(x1, y1, x2, y2)` and `(x1', y1', x2', y2')` are different if they have some coordinate that is different: for example, if `x1 != x1'`.",0,Hard,/articles/number-of-submatrices-that-sum-to-target,62.0,27.3,https://leetcode.com/problems/number-of-submatrices-that-sum-to-target,134,25K,40.3K,Google,"Array,Dynamic Programming,Sliding Window",820,31,96,1,,"class Solution {
public:
    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
        
    }
};","class Solution {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        
    }
}","class Solution(object):
    def numSubmatrixSumTarget(self, matrix, target):
        """"""
        :type matrix: List[List[int]]
        :type target: int
        :rtype: int
        """"""
        ","class Solution:
    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        ","int numSubmatrixSumTarget(int** matrix, int matrixSize, int* matrixColSize, int target){

}","public class Solution {
    public int NumSubmatrixSumTarget(int[][] matrix, int target) {
        
    }
}","/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {number}
 */
var numSubmatrixSumTarget = function(matrix, target) {
    
};","# @param {Integer[][]} matrix
# @param {Integer} target
# @return {Integer}
def num_submatrix_sum_target(matrix, target)
    
end","class Solution {
    func numSubmatrixSumTarget(_ matrix: [[Int]], _ target: Int) -> Int {
        
    }
}","func numSubmatrixSumTarget(matrix [][]int, target int) int {
    
}","object Solution {
    def numSubmatrixSumTarget(matrix: Array[Array[Int]], target: Int): Int = {
        
    }
}","class Solution {
    fun numSubmatrixSumTarget(matrix: Array<IntArray>, target: Int): Int {
        
    }
}","impl Solution {
    pub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $matrix
     * @param Integer $target
     * @return Integer
     */
    function numSubmatrixSumTarget($matrix, $target) {
        
    }
}","function numSubmatrixSumTarget(matrix: number[][], target: number): number {

};","(define/contract (num-submatrix-sum-target matrix target)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec num_submatrix_sum_target(Matrix :: [[integer()]], Target :: integer()) -> integer().
num_submatrix_sum_target(Matrix, Target) ->
  .","defmodule Solution do
  @spec num_submatrix_sum_target(matrix :: [[integer]], target :: integer) :: integer
  def num_submatrix_sum_target(matrix, target) do

  end
end","class Solution {
  int numSubmatrixSumTarget(List<List<int>> matrix, int target) {

  }
}",,,,number-of-submatrices-that-sum-to-target
173,1092,Shortest Common Supersequence,"Given two strings `str1` and `str2`, return the shortest string that has both `str1` and `str2` as subsequences.  If multiple answers exist, you may return any of them.
(A string S is a subsequence of string T if deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results in the string S.)",0,Hard,,53.2,22.4,https://leetcode.com/problems/shortest-common-supersequence,311,22.2K,41.7K,"Microsoft,Amazon",Dynamic Programming,941,25,97,1,"[Longest Common Subsequence, /problems/longest-common-subsequence/, Medium]","class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) {
        
    }
};","class Solution {
    public String shortestCommonSupersequence(String str1, String str2) {
        
    }
}","class Solution(object):
    def shortestCommonSupersequence(self, str1, str2):
        """"""
        :type str1: str
        :type str2: str
        :rtype: str
        """"""
        ","class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        ","char * shortestCommonSupersequence(char * str1, char * str2){

}","public class Solution {
    public string ShortestCommonSupersequence(string str1, string str2) {
        
    }
}","/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */
var shortestCommonSupersequence = function(str1, str2) {
    
};","# @param {String} str1
# @param {String} str2
# @return {String}
def shortest_common_supersequence(str1, str2)
    
end","class Solution {
    func shortestCommonSupersequence(_ str1: String, _ str2: String) -> String {
        
    }
}","func shortestCommonSupersequence(str1 string, str2 string) string {
    
}","object Solution {
    def shortestCommonSupersequence(str1: String, str2: String): String = {
        
    }
}","class Solution {
    fun shortestCommonSupersequence(str1: String, str2: String): String {
        
    }
}","impl Solution {
    pub fn shortest_common_supersequence(str1: String, str2: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $str1
     * @param String $str2
     * @return String
     */
    function shortestCommonSupersequence($str1, $str2) {
        
    }
}","function shortestCommonSupersequence(str1: string, str2: string): string {

};","(define/contract (shortest-common-supersequence str1 str2)
  (-> string? string? string?)

  )","-spec shortest_common_supersequence(Str1 :: unicode:unicode_binary(), Str2 :: unicode:unicode_binary()) -> unicode:unicode_binary().
shortest_common_supersequence(Str1, Str2) ->
  .","defmodule Solution do
  @spec shortest_common_supersequence(str1 :: String.t, str2 :: String.t) :: String.t
  def shortest_common_supersequence(str1, str2) do

  end
end","class Solution {
  String shortestCommonSupersequence(String str1, String str2) {

  }
}",,,,shortest-common-supersequence
175,1096,Brace Expansion II,"Under a grammar given below, strings can represent a set of lowercase words.  Let's use `R(expr)` to denote the set of words the expression represents.
Grammar can best be understood through simple examples:
Single letters represent a singleton set containing that word.
`R(""a"") = {""a""}`
`R(""w"") = {""w""}`
When we take a comma delimited list of 2 or more expressions, we take the union of possibilities.
`R(""{a,b,c}"") = {""a"",""b"",""c""}`
`R(""{{a,b},{b,c}}"") = {""a"",""b"",""c""}` (notice the final set only contains each word at most once)
When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.
`R(""{a,b}{c,d}"") = {""ac"",""ad"",""bc"",""bd""}`
`R(""a{b,c}{d,e}f{g,h}"") = {""abdfg"", ""abdfh"", ""abefg"", ""abefh"", ""acdfg"", ""acdfh"", ""acefg"", ""acefh""}`
Formally, the 3 rules for our grammar:
For every lowercase letter `x`, we have `R(x) = {x}`
For expressions `e_1, e_2, ... , e_k` with `k >= 2`, we have `R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ...`
For expressions `e_1` and `e_2`, we have `R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}`, where + denotes concatenation, and × denotes the cartesian product.
Given an `expression` representing a set of words under the given grammar, return the sorted list of words that the expression represents.",0,Hard,,62.6,11.2,https://leetcode.com/problems/brace-expansion-ii,173,13.4K,21.3K,"Google,Adobe",String,258,161,62,1,"[Brace Expansion, /problems/brace-expansion/, Medium]","class Solution {
public:
    vector<string> braceExpansionII(string expression) {
        
    }
};","class Solution {
    public List<String> braceExpansionII(String expression) {
        
    }
}","class Solution(object):
    def braceExpansionII(self, expression):
        """"""
        :type expression: str
        :rtype: List[str]
        """"""
        ","class Solution:
    def braceExpansionII(self, expression: str) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** braceExpansionII(char * expression, int* returnSize){

}","public class Solution {
    public IList<string> BraceExpansionII(string expression) {
        
    }
}","/**
 * @param {string} expression
 * @return {string[]}
 */
var braceExpansionII = function(expression) {
    
};","# @param {String} expression
# @return {String[]}
def brace_expansion_ii(expression)
    
end","class Solution {
    func braceExpansionII(_ expression: String) -> [String] {
        
    }
}","func braceExpansionII(expression string) []string {
    
}","object Solution {
    def braceExpansionII(expression: String): List[String] = {
        
    }
}","class Solution {
    fun braceExpansionII(expression: String): List<String> {
        
    }
}","impl Solution {
    pub fn brace_expansion_ii(expression: String) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String $expression
     * @return String[]
     */
    function braceExpansionII($expression) {
        
    }
}","function braceExpansionII(expression: string): string[] {

};","(define/contract (brace-expansion-ii expression)
  (-> string? (listof string?))

  )","-spec brace_expansion_ii(Expression :: unicode:unicode_binary()) -> [unicode:unicode_binary()].
brace_expansion_ii(Expression) ->
  .","defmodule Solution do
  @spec brace_expansion_ii(expression :: String.t) :: [String.t]
  def brace_expansion_ii(expression) do

  end
end","class Solution {
  List<String> braceExpansionII(String expression) {

  }
}",,,,brace-expansion-ii
176,1106,Parsing A Boolean Expression,"Return the result of evaluating a given boolean `expression`, represented as a string.
An expression can either be:
`""t""`, evaluating to `True`;
`""f""`, evaluating to `False`;
`""!(expr)""`, evaluating to the logical NOT of the inner expression `expr`;
`""&(expr1,expr2,...)""`, evaluating to the logical AND of 2 or more inner expressions `expr1, expr2, ...`;
`""|(expr1,expr2,...)""`, evaluating to the logical OR of 2 or more inner expressions `expr1, expr2, ...`",0,Hard,,59.4,31.8,https://leetcode.com/problems/parsing-a-boolean-expression,285,13.3K,22.4K,Amazon,String,341,21,94,1,,"class Solution {
public:
    bool parseBoolExpr(string expression) {
        
    }
};","class Solution {
    public boolean parseBoolExpr(String expression) {
        
    }
}","class Solution(object):
    def parseBoolExpr(self, expression):
        """"""
        :type expression: str
        :rtype: bool
        """"""
        ","class Solution:
    def parseBoolExpr(self, expression: str) -> bool:
        ","bool parseBoolExpr(char * expression){

}","public class Solution {
    public bool ParseBoolExpr(string expression) {
        
    }
}","/**
 * @param {string} expression
 * @return {boolean}
 */
var parseBoolExpr = function(expression) {
    
};","# @param {String} expression
# @return {Boolean}
def parse_bool_expr(expression)
    
end","class Solution {
    func parseBoolExpr(_ expression: String) -> Bool {
        
    }
}","func parseBoolExpr(expression string) bool {
    
}","object Solution {
    def parseBoolExpr(expression: String): Boolean = {
        
    }
}","class Solution {
    fun parseBoolExpr(expression: String): Boolean {
        
    }
}","impl Solution {
    pub fn parse_bool_expr(expression: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $expression
     * @return Boolean
     */
    function parseBoolExpr($expression) {
        
    }
}","function parseBoolExpr(expression: string): boolean {

};","(define/contract (parse-bool-expr expression)
  (-> string? boolean?)

  )","-spec parse_bool_expr(Expression :: unicode:unicode_binary()) -> boolean().
parse_bool_expr(Expression) ->
  .","defmodule Solution do
  @spec parse_bool_expr(expression :: String.t) :: boolean
  def parse_bool_expr(expression) do

  end
end","class Solution {
  bool parseBoolExpr(String expression) {

  }
}",,,,parsing-a-boolean-expression
177,1125,Smallest Sufficient Team,"In a project, you have a list of required skills `req_skills`, and a list of people. The `ith` person `people[i]` contains a list of skills that the person has.
Consider a sufficient team: a set of people such that for every required skill in `req_skills`, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.
For example, `team = [0, 1, 3]` represents the people with skills `people[0]`, `people[1]`, and `people[3]`.
Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.
It is guaranteed an answer exists.",0,Hard,,46.9,7.5,https://leetcode.com/problems/smallest-sufficient-team,125,11.8K,25.1K,Google,"Dynamic Programming,Bit Manipulation",469,9,98,1,,"class Solution {
public:
    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
        
    }
};","class Solution {
    public int[] smallestSufficientTeam(String[] req_skills, List<List<String>> people) {
        
    }
}","class Solution(object):
    def smallestSufficientTeam(self, req_skills, people):
        """"""
        :type req_skills: List[str]
        :type people: List[List[str]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* smallestSufficientTeam(char ** req_skills, int req_skillsSize, char *** people, int peopleSize, int* peopleColSize, int* returnSize){

}","public class Solution {
    public int[] SmallestSufficientTeam(string[] req_skills, IList<IList<string>> people) {
        
    }
}","/**
 * @param {string[]} req_skills
 * @param {string[][]} people
 * @return {number[]}
 */
var smallestSufficientTeam = function(req_skills, people) {
    
};","# @param {String[]} req_skills
# @param {String[][]} people
# @return {Integer[]}
def smallest_sufficient_team(req_skills, people)
    
end","class Solution {
    func smallestSufficientTeam(_ req_skills: [String], _ people: [[String]]) -> [Int] {
        
    }
}","func smallestSufficientTeam(req_skills []string, people [][]string) []int {
    
}","object Solution {
    def smallestSufficientTeam(req_skills: Array[String], people: List[List[String]]): Array[Int] = {
        
    }
}","class Solution {
    fun smallestSufficientTeam(req_skills: Array<String>, people: List<List<String>>): IntArray {
        
    }
}","impl Solution {
    pub fn smallest_sufficient_team(req_skills: Vec<String>, people: Vec<Vec<String>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param String[] $req_skills
     * @param String[][] $people
     * @return Integer[]
     */
    function smallestSufficientTeam($req_skills, $people) {
        
    }
}","function smallestSufficientTeam(req_skills: string[], people: string[][]): number[] {

};","(define/contract (smallest-sufficient-team req_skills people)
  (-> (listof string?) (listof (listof string?)) (listof exact-integer?))

  )","-spec smallest_sufficient_team(Req_skills :: [unicode:unicode_binary()], People :: [[unicode:unicode_binary()]]) -> [integer()].
smallest_sufficient_team(Req_skills, People) ->
  .","defmodule Solution do
  @spec smallest_sufficient_team(req_skills :: [String.t], people :: [[String.t]]) :: [integer]
  def smallest_sufficient_team(req_skills, people) do

  end
end","class Solution {
  List<int> smallestSufficientTeam(List<String> req_skills, List<List<String>> people) {

  }
}",,,,smallest-sufficient-team
178,1147,Longest Chunked Palindrome Decomposition,"You are given a string `text`. You should split it to k substrings `(subtext1, subtext2, ..., subtextk)` such that:
`subtexti` is a non-empty string.
The concatenation of all the substrings is equal to `text` (i.e., `subtext1 + subtext2 + ... + subtextk == text`).
`subtexti == subtextk - i + 1` for all valid values of `i` (i.e., `1 <= i <= k`).
Return the largest possible value of `k`.",0,Hard,,59.5,0.0,https://leetcode.com/problems/longest-chunked-palindrome-decomposition,205,12.3K,20.6K,Google,"Dynamic Programming,Rolling Hash",264,16,94,1,,"class Solution {
public:
    int longestDecomposition(string text) {
        
    }
};","class Solution {
    public int longestDecomposition(String text) {
        
    }
}","class Solution(object):
    def longestDecomposition(self, text):
        """"""
        :type text: str
        :rtype: int
        """"""
        ","class Solution:
    def longestDecomposition(self, text: str) -> int:
        ","int longestDecomposition(char * text){

}","public class Solution {
    public int LongestDecomposition(string text) {
        
    }
}","/**
 * @param {string} text
 * @return {number}
 */
var longestDecomposition = function(text) {
    
};","# @param {String} text
# @return {Integer}
def longest_decomposition(text)
    
end","class Solution {
    func longestDecomposition(_ text: String) -> Int {
        
    }
}","func longestDecomposition(text string) int {
    
}","object Solution {
    def longestDecomposition(text: String): Int = {
        
    }
}","class Solution {
    fun longestDecomposition(text: String): Int {
        
    }
}","impl Solution {
    pub fn longest_decomposition(text: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $text
     * @return Integer
     */
    function longestDecomposition($text) {
        
    }
}","function longestDecomposition(text: string): number {

};","(define/contract (longest-decomposition text)
  (-> string? exact-integer?)

  )","-spec longest_decomposition(Text :: unicode:unicode_binary()) -> integer().
longest_decomposition(Text) ->
  .","defmodule Solution do
  @spec longest_decomposition(text :: String.t) :: integer
  def longest_decomposition(text) do

  end
end","class Solution {
  int longestDecomposition(String text) {

  }
}",,,,longest-chunked-palindrome-decomposition
180,1163,Last Substring in Lexicographical Order,"Given a string `s`, return the last substring of `s` in lexicographical order.",0,Hard,,36.3,48.7,https://leetcode.com/problems/last-substring-in-lexicographical-order,233,24.3K,66.8K,"Goldman Sachs,Salesforce","String,Suffix Array",317,358,47,0,,"class Solution {
public:
    string lastSubstring(string s) {
        
    }
};","class Solution {
    public String lastSubstring(String s) {
        
    }
}","class Solution(object):
    def lastSubstring(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        ","class Solution:
    def lastSubstring(self, s: str) -> str:
        ","char * lastSubstring(char * s){

}","public class Solution {
    public string LastSubstring(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string}
 */
var lastSubstring = function(s) {
    
};","# @param {String} s
# @return {String}
def last_substring(s)
    
end","class Solution {
    func lastSubstring(_ s: String) -> String {
        
    }
}","func lastSubstring(s string) string {
    
}","object Solution {
    def lastSubstring(s: String): String = {
        
    }
}","class Solution {
    fun lastSubstring(s: String): String {
        
    }
}","impl Solution {
    pub fn last_substring(s: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String
     */
    function lastSubstring($s) {
        
    }
}","function lastSubstring(s: string): string {

};","(define/contract (last-substring s)
  (-> string? string?)

  )","-spec last_substring(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
last_substring(S) ->
  .","defmodule Solution do
  @spec last_substring(s :: String.t) :: String.t
  def last_substring(s) do

  end
end","class Solution {
  String lastSubstring(String s) {

  }
}",,,,last-substring-in-lexicographical-order
182,1178,Number of Valid Words for Each Puzzle,"With respect to a given `puzzle` string, a `word` is valid if both the following conditions are satisfied:
`word` contains the first letter of `puzzle`.
For each letter in `word`, that letter is in `puzzle`.
For example, if the puzzle is ""abcdefg"", then valid words are ""faced"", ""cabbage"", and ""baggage""; while invalid words are ""beefed"" (doesn't include ""a"") and ""based"" (includes ""s"" which isn't in the puzzle).
Return an array `answer`, where `answer[i]` is the number of words in the given word list `words` that are valid with respect to the puzzle `puzzles[i]`.",0,Hard,,39.6,63.1,https://leetcode.com/problems/number-of-valid-words-for-each-puzzle,104,8.9K,22.4K,Dropbox,"Hash Table,Bit Manipulation",287,34,89,0,,"class Solution {
public:
    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {
        
    }
};","class Solution {
    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {
        
    }
}","class Solution(object):
    def findNumOfValidWords(self, words, puzzles):
        """"""
        :type words: List[str]
        :type puzzles: List[str]
        :rtype: List[int]
        """"""
        ","class Solution:
    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int* returnSize){

}","public class Solution {
    public IList<int> FindNumOfValidWords(string[] words, string[] puzzles) {
        
    }
}","/**
 * @param {string[]} words
 * @param {string[]} puzzles
 * @return {number[]}
 */
var findNumOfValidWords = function(words, puzzles) {
    
};","# @param {String[]} words
# @param {String[]} puzzles
# @return {Integer[]}
def find_num_of_valid_words(words, puzzles)
    
end","class Solution {
    func findNumOfValidWords(_ words: [String], _ puzzles: [String]) -> [Int] {
        
    }
}","func findNumOfValidWords(words []string, puzzles []string) []int {
    
}","object Solution {
    def findNumOfValidWords(words: Array[String], puzzles: Array[String]): List[Int] = {
        
    }
}","class Solution {
    fun findNumOfValidWords(words: Array<String>, puzzles: Array<String>): List<Int> {
        
    }
}","impl Solution {
    pub fn find_num_of_valid_words(words: Vec<String>, puzzles: Vec<String>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @param String[] $puzzles
     * @return Integer[]
     */
    function findNumOfValidWords($words, $puzzles) {
        
    }
}","function findNumOfValidWords(words: string[], puzzles: string[]): number[] {

};","(define/contract (find-num-of-valid-words words puzzles)
  (-> (listof string?) (listof string?) (listof exact-integer?))

  )","-spec find_num_of_valid_words(Words :: [unicode:unicode_binary()], Puzzles :: [unicode:unicode_binary()]) -> [integer()].
find_num_of_valid_words(Words, Puzzles) ->
  .","defmodule Solution do
  @spec find_num_of_valid_words(words :: [String.t], puzzles :: [String.t]) :: [integer]
  def find_num_of_valid_words(words, puzzles) do

  end
end","class Solution {
  List<int> findNumOfValidWords(List<String> words, List<String> puzzles) {

  }
}",,,,number-of-valid-words-for-each-puzzle
183,1187,Make Array Strictly Increasing,"Given two integer arrays `arr1` and `arr2`, return the minimum number of operations (possibly zero) needed to make `arr1` strictly increasing.
In one operation, you can choose two indices `0 <= i < arr1.length` and `0 <= j < arr2.length` and do the assignment `arr1[i] = arr2[j]`.
If there is no way to make `arr1` strictly increasing, return `-1`.",0,Hard,,42.0,5.9,https://leetcode.com/problems/make-array-strictly-increasing,84,7.4K,17.7K,,,372,11,97,0,,"class Solution {
public:
    int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {
        
    }
};","class Solution {
    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        
    }
}","class Solution(object):
    def makeArrayIncreasing(self, arr1, arr2):
        """"""
        :type arr1: List[int]
        :type arr2: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
        ","

int makeArrayIncreasing(int* arr1, int arr1Size, int* arr2, int arr2Size){

}","public class Solution {
    public int MakeArrayIncreasing(int[] arr1, int[] arr2) {
        
    }
}","/**
 * @param {number[]} arr1
 * @param {number[]} arr2
 * @return {number}
 */
var makeArrayIncreasing = function(arr1, arr2) {
    
};","# @param {Integer[]} arr1
# @param {Integer[]} arr2
# @return {Integer}
def make_array_increasing(arr1, arr2)
    
end","class Solution {
    func makeArrayIncreasing(_ arr1: [Int], _ arr2: [Int]) -> Int {
        
    }
}","func makeArrayIncreasing(arr1 []int, arr2 []int) int {
    
}","object Solution {
    def makeArrayIncreasing(arr1: Array[Int], arr2: Array[Int]): Int = {
        
    }
}","class Solution {
    fun makeArrayIncreasing(arr1: IntArray, arr2: IntArray): Int {
        
    }
}","impl Solution {
    pub fn make_array_increasing(arr1: Vec<i32>, arr2: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr1
     * @param Integer[] $arr2
     * @return Integer
     */
    function makeArrayIncreasing($arr1, $arr2) {
        
    }
}","function makeArrayIncreasing(arr1: number[], arr2: number[]): number {

};",,,,,,,,make-array-strictly-increasing
184,1192,Critical Connections in a Network,"There are `n` servers numbered from `0` to `n-1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [a, b]` represents a connection between servers `a` and `b`. Any server can reach any other server directly or indirectly through the network.
A critical connection is a connection that, if removed, will make some server unable to reach some other server.
Return all critical connections in the network in any order.",0,Hard,/articles/critical-connections-in-a-network,50.3,76.3,https://leetcode.com/problems/critical-connections-in-a-network,436,101.6K,202.1K,"Amazon,Adobe",Depth-first Search,2165,110,95,1,,"class Solution {
public:
    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
        
    }
};","class Solution {
    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
        
    }
}","class Solution(object):
    def criticalConnections(self, n, connections):
        """"""
        :type n: int
        :type connections: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** criticalConnections(int n, int** connections, int connectionsSize, int* connectionsColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public IList<IList<int>> CriticalConnections(int n, IList<IList<int>> connections) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number[][]}
 */
var criticalConnections = function(n, connections) {
    
};","# @param {Integer} n
# @param {Integer[][]} connections
# @return {Integer[][]}
def critical_connections(n, connections)
    
end","class Solution {
    func criticalConnections(_ n: Int, _ connections: [[Int]]) -> [[Int]] {
        
    }
}","func criticalConnections(n int, connections [][]int) [][]int {
    
}","object Solution {
    def criticalConnections(n: Int, connections: List[List[Int]]): List[List[Int]] = {
        
    }
}","class Solution {
    fun criticalConnections(n: Int, connections: List<List<Int>>): List<List<Int>> {
        
    }
}","impl Solution {
    pub fn critical_connections(n: i32, connections: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $connections
     * @return Integer[][]
     */
    function criticalConnections($n, $connections) {
        
    }
}","function criticalConnections(n: number, connections: number[][]): number[][] {

};","(define/contract (critical-connections n connections)
  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)))

  )","-spec critical_connections(N :: integer(), Connections :: [[integer()]]) -> [[integer()]].
critical_connections(N, Connections) ->
  .","defmodule Solution do
  @spec critical_connections(n :: integer, connections :: [[integer]]) :: [[integer]]
  def critical_connections(n, connections) do

  end
end","class Solution {
  List<List<int>> criticalConnections(int n, List<List<int>> connections) {

  }
}",,,,critical-connections-in-a-network
185,1203,Sort Items by Groups Respecting Dependencies,"There are `n` items each belonging to zero or one of `m` groups where `group[i]` is the group that the `i`-th item belongs to and it's equal to `-1` if the `i`-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.
Return a sorted list of the items such that:
The items that belong to the same group are next to each other in the sorted list.
There are some relations between these items where `beforeItems[i]` is a list containing all the items that should come before the `i`-th item in the sorted array (to the left of the `i`-th item).
Return any solution if there is more than one solution and return an empty list if there is no solution.",0,Hard,,48.4,9.0,https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies,109,8.9K,18.4K,Google,"Depth-first Search,Graph,Topological Sort",387,68,85,1,,"class Solution {
public:
    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {
        
    }
};","class Solution {
    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {
        
    }
}","class Solution(object):
    def sortItems(self, n, m, group, beforeItems):
        """"""
        :type n: int
        :type m: int
        :type group: List[int]
        :type beforeItems: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortItems(int n, int m, int* group, int groupSize, int** beforeItems, int beforeItemsSize, int* beforeItemsColSize, int* returnSize){

}","public class Solution {
    public int[] SortItems(int n, int m, int[] group, IList<IList<int>> beforeItems) {
        
    }
}","/**
 * @param {number} n
 * @param {number} m
 * @param {number[]} group
 * @param {number[][]} beforeItems
 * @return {number[]}
 */
var sortItems = function(n, m, group, beforeItems) {
    
};","# @param {Integer} n
# @param {Integer} m
# @param {Integer[]} group
# @param {Integer[][]} before_items
# @return {Integer[]}
def sort_items(n, m, group, before_items)
    
end","class Solution {
    func sortItems(_ n: Int, _ m: Int, _ group: [Int], _ beforeItems: [[Int]]) -> [Int] {
        
    }
}","func sortItems(n int, m int, group []int, beforeItems [][]int) []int {
    
}","object Solution {
    def sortItems(n: Int, m: Int, group: Array[Int], beforeItems: List[List[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun sortItems(n: Int, m: Int, group: IntArray, beforeItems: List<List<Int>>): IntArray {
        
    }
}","impl Solution {
    pub fn sort_items(n: i32, m: i32, group: Vec<i32>, before_items: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $m
     * @param Integer[] $group
     * @param Integer[][] $beforeItems
     * @return Integer[]
     */
    function sortItems($n, $m, $group, $beforeItems) {
        
    }
}","function sortItems(n: number, m: number, group: number[], beforeItems: number[][]): number[] {

};","(define/contract (sort-items n m group beforeItems)
  (-> exact-integer? exact-integer? (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec sort_items(N :: integer(), M :: integer(), Group :: [integer()], BeforeItems :: [[integer()]]) -> [integer()].
sort_items(N, M, Group, BeforeItems) ->
  .","defmodule Solution do
  @spec sort_items(n :: integer, m :: integer, group :: [integer], before_items :: [[integer]]) :: [integer]
  def sort_items(n, m, group, before_items) do

  end
end","class Solution {
  List<int> sortItems(int n, int m, List<int> group, List<List<int>> beforeItems) {

  }
}",,,,sort-items-by-groups-respecting-dependencies
187,1210,Minimum Moves to Reach Target with Rotations,"In an `n*n` grid, there is a snake that spans 2 cells and starts moving from the top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.
In one move the snake can:
Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.
Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.
Return the minimum number of moves to reach the target.
If there is no way to reach the target, return `-1`.",0,Hard,,46.6,0.0,https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations,137,6K,12.8K,Kakao,Breadth-first Search,155,46,77,0,,"class Solution {
public:
    int minimumMoves(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int minimumMoves(int[][] grid) {
        
    }
}","class Solution(object):
    def minimumMoves(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        ","

int minimumMoves(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int MinimumMoves(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var minimumMoves = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def minimum_moves(grid)
    
end","class Solution {
    func minimumMoves(_ grid: [[Int]]) -> Int {
        
    }
}","func minimumMoves(grid [][]int) int {
    
}","object Solution {
    def minimumMoves(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minimumMoves(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function minimumMoves($grid) {
        
    }
}","function minimumMoves(grid: number[][]): number {

};",,,,,,,,minimum-moves-to-reach-target-with-rotations
188,1220,Count Vowels Permutation,"Given an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:
Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)
Each vowel `'a'` may only be followed by an `'e'`.
Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.
Each vowel `'i'` may not be followed by another `'i'`.
Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.
Each vowel `'u'` may only be followed by an `'a'.`
Since the answer may be too large, return it modulo `10^9 + 7.`",0,Hard,,54.0,62.9,https://leetcode.com/problems/count-vowels-permutation,239,16.7K,30.9K,Swiggy,Dynamic Programming,309,57,84,0,,"class Solution {
public:
    int countVowelPermutation(int n) {
        
    }
};","class Solution {
    public int countVowelPermutation(int n) {
        
    }
}","class Solution(object):
    def countVowelPermutation(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def countVowelPermutation(self, n: int) -> int:
        ","int countVowelPermutation(int n){

}","public class Solution {
    public int CountVowelPermutation(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var countVowelPermutation = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def count_vowel_permutation(n)
    
end","class Solution {
    func countVowelPermutation(_ n: Int) -> Int {
        
    }
}","func countVowelPermutation(n int) int {
    
}","object Solution {
    def countVowelPermutation(n: Int): Int = {
        
    }
}","class Solution {
    fun countVowelPermutation(n: Int): Int {
        
    }
}","impl Solution {
    pub fn count_vowel_permutation(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function countVowelPermutation($n) {
        
    }
}","function countVowelPermutation(n: number): number {

};","(define/contract (count-vowel-permutation n)
  (-> exact-integer? exact-integer?)

  )","-spec count_vowel_permutation(N :: integer()) -> integer().
count_vowel_permutation(N) ->
  .","defmodule Solution do
  @spec count_vowel_permutation(n :: integer) :: integer
  def count_vowel_permutation(n) do

  end
end","class Solution {
  int countVowelPermutation(int n) {

  }
}",,,,count-vowels-permutation
189,1223,Dice Roll Simulation,"A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (1-indexed) consecutive times.
Given an array of integers `rollMax` and an integer `n`, return the number of distinct sequences that can be obtained with exact `n` rolls.
Two sequences are considered different if at least one element differs from each other. Since the answer may be too large, return it modulo `10^9 + 7`.",0,Hard,,46.7,6.4,https://leetcode.com/problems/dice-roll-simulation,180,17.1K,36.6K,Codenation,Dynamic Programming,518,162,76,0,,"class Solution {
public:
    int dieSimulator(int n, vector<int>& rollMax) {
        
    }
};","class Solution {
    public int dieSimulator(int n, int[] rollMax) {
        
    }
}","class Solution(object):
    def dieSimulator(self, n, rollMax):
        """"""
        :type n: int
        :type rollMax: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def dieSimulator(self, n: int, rollMax: List[int]) -> int:
        ","int dieSimulator(int n, int* rollMax, int rollMaxSize){

}","public class Solution {
    public int DieSimulator(int n, int[] rollMax) {
        
    }
}","/**
 * @param {number} n
 * @param {number[]} rollMax
 * @return {number}
 */
var dieSimulator = function(n, rollMax) {
    
};","# @param {Integer} n
# @param {Integer[]} roll_max
# @return {Integer}
def die_simulator(n, roll_max)
    
end","class Solution {
    func dieSimulator(_ n: Int, _ rollMax: [Int]) -> Int {
        
    }
}","func dieSimulator(n int, rollMax []int) int {
    
}","object Solution {
    def dieSimulator(n: Int, rollMax: Array[Int]): Int = {
        
    }
}","class Solution {
    fun dieSimulator(n: Int, rollMax: IntArray): Int {
        
    }
}","impl Solution {
    pub fn die_simulator(n: i32, roll_max: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[] $rollMax
     * @return Integer
     */
    function dieSimulator($n, $rollMax) {
        
    }
}","function dieSimulator(n: number, rollMax: number[]): number {

};","(define/contract (die-simulator n rollMax)
  (-> exact-integer? (listof exact-integer?) exact-integer?)

  )","-spec die_simulator(N :: integer(), RollMax :: [integer()]) -> integer().
die_simulator(N, RollMax) ->
  .","defmodule Solution do
  @spec die_simulator(n :: integer, roll_max :: [integer]) :: integer
  def die_simulator(n, roll_max) do

  end
end","class Solution {
  int dieSimulator(int n, List<int> rollMax) {

  }
}",,,,dice-roll-simulation
190,1224,Maximum Equal Frequency,"Given an array `nums` of positive integers, return the longest possible length of an array prefix of `nums`, such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences.
If after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).",0,Hard,,35.5,0.0,https://leetcode.com/problems/maximum-equal-frequency,86,8.3K,23.5K,American Express,Hash Table,243,29,89,0,,"class Solution {
public:
    int maxEqualFreq(vector<int>& nums) {
        
    }
};","class Solution {
    public int maxEqualFreq(int[] nums) {
        
    }
}","class Solution(object):
    def maxEqualFreq(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxEqualFreq(self, nums: List[int]) -> int:
        ","int maxEqualFreq(int* nums, int numsSize){

}","public class Solution {
    public int MaxEqualFreq(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maxEqualFreq = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def max_equal_freq(nums)
    
end","class Solution {
    func maxEqualFreq(_ nums: [Int]) -> Int {
        
    }
}","func maxEqualFreq(nums []int) int {
    
}","object Solution {
    def maxEqualFreq(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxEqualFreq(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_equal_freq(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxEqualFreq($nums) {
        
    }
}","function maxEqualFreq(nums: number[]): number {

};","(define/contract (max-equal-freq nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_equal_freq(Nums :: [integer()]) -> integer().
max_equal_freq(Nums) ->
  .","defmodule Solution do
  @spec max_equal_freq(nums :: [integer]) :: integer
  def max_equal_freq(nums) do

  end
end","class Solution {
  int maxEqualFreq(List<int> nums) {

  }
}",,,,maximum-equal-frequency
191,1235,Maximum Profit in Job Scheduling,"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.
You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.",0,Hard,,47.6,82.7,https://leetcode.com/problems/maximum-profit-in-job-scheduling,271,36.9K,77.4K,"LinkedIn,DoorDash,ByteDance,Amazon,Cisco,Databricks,Bloomberg,Dunzo,Swiggy","Binary Search,Dynamic Programming,Sort",1183,13,99,1,,"class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        
    }
};","class Solution {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
        
    }
}","class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        """"""
        :type startTime: List[int]
        :type endTime: List[int]
        :type profit: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        ","int jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize){

}","public class Solution {
    public int JobScheduling(int[] startTime, int[] endTime, int[] profit) {
        
    }
}","/**
 * @param {number[]} startTime
 * @param {number[]} endTime
 * @param {number[]} profit
 * @return {number}
 */
var jobScheduling = function(startTime, endTime, profit) {
    
};","# @param {Integer[]} start_time
# @param {Integer[]} end_time
# @param {Integer[]} profit
# @return {Integer}
def job_scheduling(start_time, end_time, profit)
    
end","class Solution {
    func jobScheduling(_ startTime: [Int], _ endTime: [Int], _ profit: [Int]) -> Int {
        
    }
}","func jobScheduling(startTime []int, endTime []int, profit []int) int {
    
}","object Solution {
    def jobScheduling(startTime: Array[Int], endTime: Array[Int], profit: Array[Int]): Int = {
        
    }
}","class Solution {
    fun jobScheduling(startTime: IntArray, endTime: IntArray, profit: IntArray): Int {
        
    }
}","impl Solution {
    pub fn job_scheduling(start_time: Vec<i32>, end_time: Vec<i32>, profit: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $startTime
     * @param Integer[] $endTime
     * @param Integer[] $profit
     * @return Integer
     */
    function jobScheduling($startTime, $endTime, $profit) {
        
    }
}","function jobScheduling(startTime: number[], endTime: number[], profit: number[]): number {

};","(define/contract (job-scheduling startTime endTime profit)
  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec job_scheduling(StartTime :: [integer()], EndTime :: [integer()], Profit :: [integer()]) -> integer().
job_scheduling(StartTime, EndTime, Profit) ->
  .","defmodule Solution do
  @spec job_scheduling(start_time :: [integer], end_time :: [integer], profit :: [integer]) :: integer
  def job_scheduling(start_time, end_time, profit) do

  end
end","class Solution {
  int jobScheduling(List<int> startTime, List<int> endTime, List<int> profit) {

  }
}",,,,maximum-profit-in-job-scheduling
192,1240,Tiling a Rectangle with the Fewest Squares,"Given a rectangle of size `n` x `m`, find the minimum number of integer-sided squares that tile the rectangle.",0,Hard,,52.8,22.9,https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares,114,11.6K,22K,Google,"Dynamic Programming,Backtracking",293,298,50,1,,"class Solution {
public:
    int tilingRectangle(int n, int m) {
        
    }
};","class Solution {
    public int tilingRectangle(int n, int m) {
        
    }
}","class Solution(object):
    def tilingRectangle(self, n, m):
        """"""
        :type n: int
        :type m: int
        :rtype: int
        """"""
        ","class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        ","int tilingRectangle(int n, int m){

}","public class Solution {
    public int TilingRectangle(int n, int m) {
        
    }
}","/**
 * @param {number} n
 * @param {number} m
 * @return {number}
 */
var tilingRectangle = function(n, m) {
    
};","# @param {Integer} n
# @param {Integer} m
# @return {Integer}
def tiling_rectangle(n, m)
    
end","class Solution {
    func tilingRectangle(_ n: Int, _ m: Int) -> Int {
        
    }
}","func tilingRectangle(n int, m int) int {
    
}","object Solution {
    def tilingRectangle(n: Int, m: Int): Int = {
        
    }
}","class Solution {
    fun tilingRectangle(n: Int, m: Int): Int {
        
    }
}","impl Solution {
    pub fn tiling_rectangle(n: i32, m: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $m
     * @return Integer
     */
    function tilingRectangle($n, $m) {
        
    }
}","function tilingRectangle(n: number, m: number): number {

};","(define/contract (tiling-rectangle n m)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec tiling_rectangle(N :: integer(), M :: integer()) -> integer().
tiling_rectangle(N, M) ->
  .","defmodule Solution do
  @spec tiling_rectangle(n :: integer, m :: integer) :: integer
  def tiling_rectangle(n, m) do

  end
end","class Solution {
  int tilingRectangle(int n, int m) {

  }
}",,,,tiling-a-rectangle-with-the-fewest-squares
193,1250,Check If It Is a Good Array,"Given an array `nums` of positive integers. Your task is to select some subset of `nums`, multiply each element by an integer and add all these numbers. The array is said to be good if you can obtain a sum of `1` from the array by any possible subset and multiplicand.
Return `True` if the array is good otherwise return `False`.",0,Hard,,56.2,0.0,https://leetcode.com/problems/check-if-it-is-a-good-array,79,9.1K,16.2K,Dropbox,Math,134,207,39,0,,"class Solution {
public:
    bool isGoodArray(vector<int>& nums) {
        
    }
};","class Solution {
    public boolean isGoodArray(int[] nums) {
        
    }
}","class Solution(object):
    def isGoodArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def isGoodArray(self, nums: List[int]) -> bool:
        ","bool isGoodArray(int* nums, int numsSize){

}","public class Solution {
    public bool IsGoodArray(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {boolean}
 */
var isGoodArray = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Boolean}
def is_good_array(nums)
    
end","class Solution {
    func isGoodArray(_ nums: [Int]) -> Bool {
        
    }
}","func isGoodArray(nums []int) bool {
    
}","object Solution {
    def isGoodArray(nums: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun isGoodArray(nums: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn is_good_array(nums: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    function isGoodArray($nums) {
        
    }
}","function isGoodArray(nums: number[]): boolean {

};","(define/contract (is-good-array nums)
  (-> (listof exact-integer?) boolean?)

  )","-spec is_good_array(Nums :: [integer()]) -> boolean().
is_good_array(Nums) ->
  .","defmodule Solution do
  @spec is_good_array(nums :: [integer]) :: boolean
  def is_good_array(nums) do

  end
end","class Solution {
  bool isGoodArray(List<int> nums) {

  }
}",,,,check-if-it-is-a-good-array
194,1255,Maximum Score Words Formed by Letters,"Given a list of `words`, list of  single `letters` (might be repeating) and `score` of every character.
Return the maximum score of any valid set of words formed by using the given letters (`words[i]` cannot be used two or more times).
It is not necessary to use all characters in `letters` and each letter can only be used once. Score of letters `'a'`, `'b'`, `'c'`, ... ,`'z'` is given by `score[0]`, `score[1]`, ... , `score[25]` respectively.",0,Hard,,70.1,13.4,https://leetcode.com/problems/maximum-score-words-formed-by-letters,201,12K,17.2K,Google,Bit Manipulation,274,26,91,1,,"class Solution {
public:
    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {
        
    }
};","class Solution {
    public int maxScoreWords(String[] words, char[] letters, int[] score) {
        
    }
}","class Solution(object):
    def maxScoreWords(self, words, letters, score):
        """"""
        :type words: List[str]
        :type letters: List[str]
        :type score: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:
        ","int maxScoreWords(char ** words, int wordsSize, char* letters, int lettersSize, int* score, int scoreSize){

}","public class Solution {
    public int MaxScoreWords(string[] words, char[] letters, int[] score) {
        
    }
}","/**
 * @param {string[]} words
 * @param {character[]} letters
 * @param {number[]} score
 * @return {number}
 */
var maxScoreWords = function(words, letters, score) {
    
};","# @param {String[]} words
# @param {Character[]} letters
# @param {Integer[]} score
# @return {Integer}
def max_score_words(words, letters, score)
    
end","class Solution {
    func maxScoreWords(_ words: [String], _ letters: [Character], _ score: [Int]) -> Int {
        
    }
}","func maxScoreWords(words []string, letters []byte, score []int) int {
    
}","object Solution {
    def maxScoreWords(words: Array[String], letters: Array[Char], score: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxScoreWords(words: Array<String>, letters: CharArray, score: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_score_words(words: Vec<String>, letters: Vec<char>, score: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @param String[] $letters
     * @param Integer[] $score
     * @return Integer
     */
    function maxScoreWords($words, $letters, $score) {
        
    }
}","function maxScoreWords(words: string[], letters: string[], score: number[]): number {

};","(define/contract (max-score-words words letters score)
  (-> (listof string?) (listof char?) (listof exact-integer?) exact-integer?)

  )","-spec max_score_words(Words :: [unicode:unicode_binary()], Letters :: [char()], Score :: [integer()]) -> integer().
max_score_words(Words, Letters, Score) ->
  .","defmodule Solution do
  @spec max_score_words(words :: [String.t], letters :: [char], score :: [integer]) :: integer
  def max_score_words(words, letters, score) do

  end
end","class Solution {
  int maxScoreWords(List<String> words, List<String> letters, List<int> score) {

  }
}",,,,maximum-score-words-formed-by-letters
195,1263,Minimum Moves to Move a Box to Their Target Location,"Storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.
The game is represented by a `grid` of size `m x n`, where each element is a wall, floor, or a box.
Your task is move the box `'B'` to the target position `'T'` under the following rules:
Player is represented by character `'S'` and can move up, down, left, right in the `grid` if it is a floor (empy cell).
Floor is represented by character `'.'` that means free cell to walk.
Wall is represented by character `'#'` that means obstacle  (impossible to walk there).
There is only one box `'B'` and one target cell `'T'` in the `grid`.
The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.
The player cannot walk through the box.
Return the minimum number of pushes to move the box to the target. If there is no way to reach the target, return `-1`.",0,Hard,,43.6,6.2,https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location,105,6K,13.8K,,,288,12,96,0,,"class Solution {
public:
    int minPushBox(vector<vector<char>>& grid) {
        
    }
};","class Solution {
    public int minPushBox(char[][] grid) {
        
    }
}","class Solution(object):
    def minPushBox(self, grid):
        """"""
        :type grid: List[List[str]]
        :rtype: int
        """"""
        ","class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        ","int minPushBox(char** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int MinPushBox(char[][] grid) {
        
    }
}","/**
 * @param {character[][]} grid
 * @return {number}
 */
var minPushBox = function(grid) {
    
};","# @param {Character[][]} grid
# @return {Integer}
def min_push_box(grid)
    
end","class Solution {
    func minPushBox(_ grid: [[Character]]) -> Int {
        
    }
}","func minPushBox(grid [][]byte) int {
    
}","object Solution {
    def minPushBox(grid: Array[Array[Char]]): Int = {
        
    }
}","class Solution {
    fun minPushBox(grid: Array<CharArray>): Int {
        
    }
}","impl Solution {
    pub fn min_push_box(grid: Vec<Vec<char>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[][] $grid
     * @return Integer
     */
    function minPushBox($grid) {
        
    }
}","function minPushBox(grid: string[][]): number {

};","(define/contract (min-push-box grid)
  (-> (listof (listof char?)) exact-integer?)

  )","-spec min_push_box(Grid :: [[char()]]) -> integer().
min_push_box(Grid) ->
  .","defmodule Solution do
  @spec min_push_box(grid :: [[char]]) :: integer
  def min_push_box(grid) do

  end
end","class Solution {
  int minPushBox(List<List<String>> grid) {

  }
}",,,,minimum-moves-to-move-a-box-to-their-target-location
196,1269,Number of Ways to Stay in the Same Place After Some Steps,"You have a pointer at index `0` in an array of size `arrLen`. At each step, you can move 1 position to the left, 1 position to the right in the array or stay in the same place  (The pointer should not be placed outside the array at any time).
Given two integers `steps` and `arrLen`, return the number of ways such that your pointer still at index `0` after exactly `steps` steps.
Since the answer may be too large, return it modulo `10^9 + 7`.",0,Hard,,43.3,2.2,https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps,220,19.1K,44.2K,Facebook,Dynamic Programming,361,21,95,1,,"class Solution {
public:
    int numWays(int steps, int arrLen) {
        
    }
};","class Solution {
    public int numWays(int steps, int arrLen) {
        
    }
}","class Solution(object):
    def numWays(self, steps, arrLen):
        """"""
        :type steps: int
        :type arrLen: int
        :rtype: int
        """"""
        ","class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        ","int numWays(int steps, int arrLen){

}","public class Solution {
    public int NumWays(int steps, int arrLen) {
        
    }
}","/**
 * @param {number} steps
 * @param {number} arrLen
 * @return {number}
 */
var numWays = function(steps, arrLen) {
    
};","# @param {Integer} steps
# @param {Integer} arr_len
# @return {Integer}
def num_ways(steps, arr_len)
    
end","class Solution {
    func numWays(_ steps: Int, _ arrLen: Int) -> Int {
        
    }
}","func numWays(steps int, arrLen int) int {
    
}","object Solution {
    def numWays(steps: Int, arrLen: Int): Int = {
        
    }
}","class Solution {
    fun numWays(steps: Int, arrLen: Int): Int {
        
    }
}","impl Solution {
    pub fn num_ways(steps: i32, arr_len: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $steps
     * @param Integer $arrLen
     * @return Integer
     */
    function numWays($steps, $arrLen) {
        
    }
}","function numWays(steps: number, arrLen: number): number {

};","(define/contract (num-ways steps arrLen)
  (-> exact-integer? exact-integer? exact-integer?)

  )","-spec num_ways(Steps :: integer(), ArrLen :: integer()) -> integer().
num_ways(Steps, ArrLen) ->
  .","defmodule Solution do
  @spec num_ways(steps :: integer, arr_len :: integer) :: integer
  def num_ways(steps, arr_len) do

  end
end","class Solution {
  int numWays(int steps, int arrLen) {

  }
}",,,,number-of-ways-to-stay-in-the-same-place-after-some-steps
197,1278,Palindrome Partitioning III,"You are given a string `s` containing lowercase letters and an integer `k`. You need to :
First, change some characters of `s` to other lowercase English letters.
Then divide `s` into `k` non-empty disjoint substrings such that each substring is palindrome.
Return the minimal number of characters that you need to change to divide the string.",0,Hard,,61.1,0.0,https://leetcode.com/problems/palindrome-partitioning-iii,184,12.4K,20.2K,"Uber,Apple",Dynamic Programming,426,9,98,1,"[Palindrome Partitioning IV, /problems/palindrome-partitioning-iv/, Hard]","class Solution {
public:
    int palindromePartition(string s, int k) {
        
    }
};","class Solution {
    public int palindromePartition(String s, int k) {
        
    }
}","class Solution(object):
    def palindromePartition(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def palindromePartition(self, s: str, k: int) -> int:
        ","int palindromePartition(char * s, int k){

}","public class Solution {
    public int PalindromePartition(string s, int k) {
        
    }
}","/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var palindromePartition = function(s, k) {
    
};","# @param {String} s
# @param {Integer} k
# @return {Integer}
def palindrome_partition(s, k)
    
end","class Solution {
    func palindromePartition(_ s: String, _ k: Int) -> Int {
        
    }
}","func palindromePartition(s string, k int) int {
    
}","object Solution {
    def palindromePartition(s: String, k: Int): Int = {
        
    }
}","class Solution {
    fun palindromePartition(s: String, k: Int): Int {
        
    }
}","impl Solution {
    pub fn palindrome_partition(s: String, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param Integer $k
     * @return Integer
     */
    function palindromePartition($s, $k) {
        
    }
}","function palindromePartition(s: string, k: number): number {

};","(define/contract (palindrome-partition s k)
  (-> string? exact-integer? exact-integer?)

  )","-spec palindrome_partition(S :: unicode:unicode_binary(), K :: integer()) -> integer().
palindrome_partition(S, K) ->
  .","defmodule Solution do
  @spec palindrome_partition(s :: String.t, k :: integer) :: integer
  def palindrome_partition(s, k) do

  end
end","class Solution {
  int palindromePartition(String s, int k) {

  }
}",,,,palindrome-partitioning-iii
198,1284,Minimum Number of Flips to Convert Binary Matrix to Zero Matrix,"Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and flip it and all the four neighbours of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighboors if they share one edge.
Return the minimum number of steps required to convert `mat` to a zero matrix or -1 if you cannot.
Binary matrix is a matrix with all cells equal to 0 or 1 only.
Zero matrix is a matrix with all cells equal to 0.",0,Hard,,70.1,22.2,https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix,186,11.4K,16.3K,"Google,Airbnb",Breadth-first Search,291,34,90,1,,"class Solution {
public:
    int minFlips(vector<vector<int>>& mat) {
        
    }
};","class Solution {
    public int minFlips(int[][] mat) {
        
    }
}","class Solution(object):
    def minFlips(self, mat):
        """"""
        :type mat: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minFlips(self, mat: List[List[int]]) -> int:
        ","int minFlips(int** mat, int matSize, int* matColSize){

}","public class Solution {
    public int MinFlips(int[][] mat) {
        
    }
}","/**
 * @param {number[][]} mat
 * @return {number}
 */
var minFlips = function(mat) {
    
};","# @param {Integer[][]} mat
# @return {Integer}
def min_flips(mat)
    
end","class Solution {
    func minFlips(_ mat: [[Int]]) -> Int {
        
    }
}","func minFlips(mat [][]int) int {
    
}","object Solution {
    def minFlips(mat: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minFlips(mat: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn min_flips(mat: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $mat
     * @return Integer
     */
    function minFlips($mat) {
        
    }
}","function minFlips(mat: number[][]): number {

};","(define/contract (min-flips mat)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec min_flips(Mat :: [[integer()]]) -> integer().
min_flips(Mat) ->
  .","defmodule Solution do
  @spec min_flips(mat :: [[integer]]) :: integer
  def min_flips(mat) do

  end
end","class Solution {
  int minFlips(List<List<int>> mat) {

  }
}",,,,minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix
199,1289,Minimum Falling Path Sum II,"Given a square grid of integers `arr`, a falling path with non-zero shifts is a choice of exactly one element from each row of `arr`, such that no two elements chosen in adjacent rows are in the same column.
Return the minimum sum of a falling path with non-zero shifts.",0,Hard,,62.6,20.1,https://leetcode.com/problems/minimum-falling-path-sum-ii,231,16.4K,26.2K,Roblox,Dynamic Programming,370,38,91,0,"[Minimum Falling Path Sum, /problems/minimum-falling-path-sum/, Medium]","class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int minFallingPathSum(int[][] grid) {
        
    }
}","class Solution(object):
    def minFallingPathSum(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        ","int minFallingPathSum(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int MinFallingPathSum(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var minFallingPathSum = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def min_falling_path_sum(grid)
    
end","class Solution {
    func minFallingPathSum(_ grid: [[Int]]) -> Int {
        
    }
}","func minFallingPathSum(grid [][]int) int {
    
}","object Solution {
    def minFallingPathSum(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minFallingPathSum(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn min_falling_path_sum(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function minFallingPathSum($grid) {
        
    }
}","function minFallingPathSum(grid: number[][]): number {

};","(define/contract (min-falling-path-sum grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec min_falling_path_sum(Grid :: [[integer()]]) -> integer().
min_falling_path_sum(Grid) ->
  .","defmodule Solution do
  @spec min_falling_path_sum(grid :: [[integer]]) :: integer
  def min_falling_path_sum(grid) do

  end
end","class Solution {
  int minFallingPathSum(List<List<int>> grid) {

  }
}",,,,minimum-falling-path-sum-ii
200,1293,Shortest Path in a Grid with Obstacles Elimination,"Given a `m * n` grid, where each cell is either `0` (empty) or `1` (obstacle). In one step, you can move up, down, left or right from and to an empty cell.
Return the minimum number of steps to walk from the upper left corner `(0, 0)` to the lower right corner `(m-1, n-1)` given that you can eliminate at most `k` obstacles. If it is not possible to find such walk return -1.",0,Hard,,43.1,48.8,https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination,268,26.2K,60.9K,"Google,ByteDance,Amazon",Breadth-first Search,724,12,98,1,"[Shortest Path to Get Food, /problems/shortest-path-to-get-food/, Medium]","class Solution {
public:
    int shortestPath(vector<vector<int>>& grid, int k) {
        
    }
};","class Solution {
    public int shortestPath(int[][] grid, int k) {
        
    }
}","class Solution(object):
    def shortestPath(self, grid, k):
        """"""
        :type grid: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def shortestPath(self, grid: List[List[int]], k: int) -> int:
        ","int shortestPath(int** grid, int gridSize, int* gridColSize, int k){

}","public class Solution {
    public int ShortestPath(int[][] grid, int k) {
        
    }
}","/**
 * @param {number[][]} grid
 * @param {number} k
 * @return {number}
 */
var shortestPath = function(grid, k) {
    
};","# @param {Integer[][]} grid
# @param {Integer} k
# @return {Integer}
def shortest_path(grid, k)
    
end","class Solution {
    func shortestPath(_ grid: [[Int]], _ k: Int) -> Int {
        
    }
}","func shortestPath(grid [][]int, k int) int {
    
}","object Solution {
    def shortestPath(grid: Array[Array[Int]], k: Int): Int = {
        
    }
}","class Solution {
    fun shortestPath(grid: Array<IntArray>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn shortest_path(grid: Vec<Vec<i32>>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @param Integer $k
     * @return Integer
     */
    function shortestPath($grid, $k) {
        
    }
}","function shortestPath(grid: number[][], k: number): number {

};","(define/contract (shortest-path grid k)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec shortest_path(Grid :: [[integer()]], K :: integer()) -> integer().
shortest_path(Grid, K) ->
  .","defmodule Solution do
  @spec shortest_path(grid :: [[integer]], k :: integer) :: integer
  def shortest_path(grid, k) do

  end
end","class Solution {
  int shortestPath(List<List<int>> grid, int k) {

  }
}",,,,shortest-path-in-a-grid-with-obstacles-elimination
201,1298,Maximum Candies You Can Get from Boxes,"Given `n` boxes, each box is given in the format `[status, candies, keys, containedBoxes]` where:
`status[i]`: an integer which is 1 if `box[i]` is open and 0 if `box[i]` is closed.
`candies[i]`: an integer representing the number of candies in `box[i]`.
`keys[i]`: an array contains the indices of the boxes you can open with the key in `box[i]`.
`containedBoxes[i]`: an array contains the indices of the boxes found in `box[i]`.
You will start with some boxes given in `initialBoxes` array. You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it.
Return the maximum number of candies you can get following the rules above.",0,Hard,,59.8,0.0,https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes,150,7.8K,13K,Airbnb,Breadth-first Search,118,94,56,0,,"class Solution {
public:
    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {
        
    }
};","class Solution {
    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {
        
    }
}","class Solution(object):
    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):
        """"""
        :type status: List[int]
        :type candies: List[int]
        :type keys: List[List[int]]
        :type containedBoxes: List[List[int]]
        :type initialBoxes: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:
        ","int maxCandies(int* status, int statusSize, int* candies, int candiesSize, int** keys, int keysSize, int* keysColSize, int** containedBoxes, int containedBoxesSize, int* containedBoxesColSize, int* initialBoxes, int initialBoxesSize){

}","public class Solution {
    public int MaxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {
        
    }
}","/**
 * @param {number[]} status
 * @param {number[]} candies
 * @param {number[][]} keys
 * @param {number[][]} containedBoxes
 * @param {number[]} initialBoxes
 * @return {number}
 */
var maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {
    
};","# @param {Integer[]} status
# @param {Integer[]} candies
# @param {Integer[][]} keys
# @param {Integer[][]} contained_boxes
# @param {Integer[]} initial_boxes
# @return {Integer}
def max_candies(status, candies, keys, contained_boxes, initial_boxes)
    
end","class Solution {
    func maxCandies(_ status: [Int], _ candies: [Int], _ keys: [[Int]], _ containedBoxes: [[Int]], _ initialBoxes: [Int]) -> Int {
        
    }
}","func maxCandies(status []int, candies []int, keys [][]int, containedBoxes [][]int, initialBoxes []int) int {
    
}","object Solution {
    def maxCandies(status: Array[Int], candies: Array[Int], keys: Array[Array[Int]], containedBoxes: Array[Array[Int]], initialBoxes: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxCandies(status: IntArray, candies: IntArray, keys: Array<IntArray>, containedBoxes: Array<IntArray>, initialBoxes: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_candies(status: Vec<i32>, candies: Vec<i32>, keys: Vec<Vec<i32>>, contained_boxes: Vec<Vec<i32>>, initial_boxes: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $status
     * @param Integer[] $candies
     * @param Integer[][] $keys
     * @param Integer[][] $containedBoxes
     * @param Integer[] $initialBoxes
     * @return Integer
     */
    function maxCandies($status, $candies, $keys, $containedBoxes, $initialBoxes) {
        
    }
}","function maxCandies(status: number[], candies: number[], keys: number[][], containedBoxes: number[][], initialBoxes: number[]): number {

};",,,,"class Solution {
  int maxCandies(List<int> status, List<int> candies, List<List<int>> keys, List<List<int>> containedBoxes, List<int> initialBoxes) {

  }
}",,,,maximum-candies-you-can-get-from-boxes
202,1301,Number of Paths with Max Score,"You are given a square `board` of characters. You can move on the board starting at the bottom right square marked with the character `'S'`.
You need to reach the top left square marked with the character `'E'`. The rest of the squares are labeled either with a numeric character `1, 2, ..., 9` or with an obstacle `'X'`. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.
Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, taken modulo `10^9 + 7`.
In case there is no path, return `[0, 0]`.",0,Hard,,38.2,0.0,https://leetcode.com/problems/number-of-paths-with-max-score,119,6.9K,17.9K,Samsung,Dynamic Programming,199,11,95,0,,"class Solution {
public:
    vector<int> pathsWithMaxScore(vector<string>& board) {
        
    }
};","class Solution {
    public int[] pathsWithMaxScore(List<String> board) {
        
    }
}","class Solution(object):
    def pathsWithMaxScore(self, board):
        """"""
        :type board: List[str]
        :rtype: List[int]
        """"""
        ","class Solution:
    def pathsWithMaxScore(self, board: List[str]) -> List[int]:
        ","

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* pathsWithMaxScore(char ** board, int boardSize, int* returnSize){

}","public class Solution {
    public int[] PathsWithMaxScore(IList<string> board) {
        
    }
}","/**
 * @param {string[]} board
 * @return {number[]}
 */
var pathsWithMaxScore = function(board) {
    
};","# @param {String[]} board
# @return {Integer[]}
def paths_with_max_score(board)
    
end","class Solution {
    func pathsWithMaxScore(_ board: [String]) -> [Int] {
        
    }
}","func pathsWithMaxScore(board []string) []int {
    
}","object Solution {
    def pathsWithMaxScore(board: List[String]): Array[Int] = {
        
    }
}","class Solution {
    fun pathsWithMaxScore(board: List<String>): IntArray {
        
    }
}","impl Solution {
    pub fn paths_with_max_score(board: Vec<String>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param String[] $board
     * @return Integer[]
     */
    function pathsWithMaxScore($board) {
        
    }
}","function pathsWithMaxScore(board: string[]): number[] {

};",,,,,,,,number-of-paths-with-max-score
203,1307,Verbal Arithmetic Puzzle,"Given an equation, represented by `words` on left side and the `result` on right side.
You need to check if the equation is solvable under the following rules:
Each character is decoded as one digit (0 - 9).
Every pair of different characters they must map to different digits.
Each `words[i]` and `result` are decoded as one number without leading zeros.
Sum of numbers on left side (`words`) will equal to the number on right side (`result`).
Return `True` if the equation is solvable otherwise return `False`.",0,Hard,,36.6,0.0,https://leetcode.com/problems/verbal-arithmetic-puzzle,117,5.5K,15.1K,Atlassian,"Math,Backtracking",205,65,76,0,,"class Solution {
public:
    bool isSolvable(vector<string>& words, string result) {
        
    }
};","class Solution {
    public boolean isSolvable(String[] words, String result) {
        
    }
}","class Solution(object):
    def isSolvable(self, words, result):
        """"""
        :type words: List[str]
        :type result: str
        :rtype: bool
        """"""
        ","class Solution:
    def isSolvable(self, words: List[str], result: str) -> bool:
        ","bool isSolvable(char ** words, int wordsSize, char * result){

}","public class Solution {
    public bool IsSolvable(string[] words, string result) {
        
    }
}","/**
 * @param {string[]} words
 * @param {string} result
 * @return {boolean}
 */
var isSolvable = function(words, result) {
    
};","# @param {String[]} words
# @param {String} result
# @return {Boolean}
def is_solvable(words, result)
    
end","class Solution {
    func isSolvable(_ words: [String], _ result: String) -> Bool {
        
    }
}","func isSolvable(words []string, result string) bool {
    
}","object Solution {
    def isSolvable(words: Array[String], result: String): Boolean = {
        
    }
}","class Solution {
    fun isSolvable(words: Array<String>, result: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_solvable(words: Vec<String>, result: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @param String $result
     * @return Boolean
     */
    function isSolvable($words, $result) {
        
    }
}","function isSolvable(words: string[], result: string): boolean {

};","(define/contract (is-solvable words result)
  (-> (listof string?) string? boolean?)

  )","-spec is_solvable(Words :: [unicode:unicode_binary()], Result :: unicode:unicode_binary()) -> boolean().
is_solvable(Words, Result) ->
  .","defmodule Solution do
  @spec is_solvable(words :: [String.t], result :: String.t) :: boolean
  def is_solvable(words, result) do

  end
end","class Solution {
  bool isSolvable(List<String> words, String result) {

  }
}",,,,verbal-arithmetic-puzzle
204,1312,Minimum Insertion Steps to Make a String Palindrome,"Given a string `s`. In one step you can insert any character at any index of the string.
Return the minimum number of steps to make `s` palindrome.
A Palindrome String is one that reads the same backward as well as forward.",0,Hard,,60.0,29.9,https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome,308,22.6K,37.6K,"Amazon,LinkedIn",Dynamic Programming,715,13,98,1,,"class Solution {
public:
    int minInsertions(string s) {
        
    }
};","class Solution {
    public int minInsertions(String s) {
        
    }
}","class Solution(object):
    def minInsertions(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def minInsertions(self, s: str) -> int:
        ","int minInsertions(char * s){

}","public class Solution {
    public int MinInsertions(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var minInsertions = function(s) {
    
};","# @param {String} s
# @return {Integer}
def min_insertions(s)
    
end","class Solution {
    func minInsertions(_ s: String) -> Int {
        
    }
}","func minInsertions(s string) int {
    
}","object Solution {
    def minInsertions(s: String): Int = {
        
    }
}","class Solution {
    fun minInsertions(s: String): Int {
        
    }
}","impl Solution {
    pub fn min_insertions(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function minInsertions($s) {
        
    }
}","function minInsertions(s: string): number {

};","(define/contract (min-insertions s)
  (-> string? exact-integer?)

  )","-spec min_insertions(S :: unicode:unicode_binary()) -> integer().
min_insertions(S) ->
  .","defmodule Solution do
  @spec min_insertions(s :: String.t) :: integer
  def min_insertions(s) do

  end
end","class Solution {
  int minInsertions(String s) {

  }
}",,,,minimum-insertion-steps-to-make-a-string-palindrome
205,1316,Distinct Echo Substrings,Return the number of distinct non-empty substrings of `text` that can be written as the concatenation of some string with itself (i.e. it can be written as `a + a` where `a` is some string).,0,Hard,,49.7,22.9,https://leetcode.com/problems/distinct-echo-substrings,116,8.7K,17.4K,Google,"String,Rolling Hash",110,137,45,1,,"class Solution {
public:
    int distinctEchoSubstrings(string text) {
        
    }
};","class Solution {
    public int distinctEchoSubstrings(String text) {
        
    }
}","class Solution(object):
    def distinctEchoSubstrings(self, text):
        """"""
        :type text: str
        :rtype: int
        """"""
        ","class Solution:
    def distinctEchoSubstrings(self, text: str) -> int:
        ","int distinctEchoSubstrings(char * text){

}","public class Solution {
    public int DistinctEchoSubstrings(string text) {
        
    }
}","/**
 * @param {string} text
 * @return {number}
 */
var distinctEchoSubstrings = function(text) {
    
};","# @param {String} text
# @return {Integer}
def distinct_echo_substrings(text)
    
end","class Solution {
    func distinctEchoSubstrings(_ text: String) -> Int {
        
    }
}","func distinctEchoSubstrings(text string) int {
    
}","object Solution {
    def distinctEchoSubstrings(text: String): Int = {
        
    }
}","class Solution {
    fun distinctEchoSubstrings(text: String): Int {
        
    }
}","impl Solution {
    pub fn distinct_echo_substrings(text: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $text
     * @return Integer
     */
    function distinctEchoSubstrings($text) {
        
    }
}","function distinctEchoSubstrings(text: string): number {

};","(define/contract (distinct-echo-substrings text)
  (-> string? exact-integer?)

  )","-spec distinct_echo_substrings(Text :: unicode:unicode_binary()) -> integer().
distinct_echo_substrings(Text) ->
  .","defmodule Solution do
  @spec distinct_echo_substrings(text :: String.t) :: integer
  def distinct_echo_substrings(text) do

  end
end","class Solution {
  int distinctEchoSubstrings(String text) {

  }
}",,,,distinct-echo-substrings
206,1320,Minimum Distance to Type a Word Using Two Fingers,"You have a keyboard layout as shown above in the XY plane, where each English uppercase letter is located at some coordinate, for example, the letter A is located at coordinate (0,0), the letter B is located at coordinate (0,1), the letter P is located at coordinate (2,3) and the letter Z is located at coordinate (4,1).
Given the string `word`, return the minimum total distance to type such string using only two fingers. The distance between coordinates (x1,y1) and (x2,y2) is |x1 - x2| + |y1 - y2|.
Note that the initial positions of your two fingers are considered free so don't count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.",0,Hard,,61.7,2.1,https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers,197,17.6K,28.5K,Google,Dynamic Programming,541,23,96,1,,"class Solution {
public:
    int minimumDistance(string word) {
        
    }
};","class Solution {
    public int minimumDistance(String word) {
        
    }
}","class Solution(object):
    def minimumDistance(self, word):
        """"""
        :type word: str
        :rtype: int
        """"""
        ","class Solution:
    def minimumDistance(self, word: str) -> int:
        ","int minimumDistance(char * word){

}","public class Solution {
    public int MinimumDistance(string word) {
        
    }
}","/**
 * @param {string} word
 * @return {number}
 */
var minimumDistance = function(word) {
    
};","# @param {String} word
# @return {Integer}
def minimum_distance(word)
    
end","class Solution {
    func minimumDistance(_ word: String) -> Int {
        
    }
}","func minimumDistance(word string) int {
    
}","object Solution {
    def minimumDistance(word: String): Int = {
        
    }
}","class Solution {
    fun minimumDistance(word: String): Int {
        
    }
}","impl Solution {
    pub fn minimum_distance(word: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $word
     * @return Integer
     */
    function minimumDistance($word) {
        
    }
}","function minimumDistance(word: string): number {

};",,"-spec minimum_distance(Word :: unicode:unicode_binary()) -> integer().
minimum_distance(Word) ->
  .","defmodule Solution do
  @spec minimum_distance(word :: String.t) :: integer
  def minimum_distance(word) do

  end
end","class Solution {
  int minimumDistance(String word) {

  }
}",,,,minimum-distance-to-type-a-word-using-two-fingers
207,1326,Minimum Number of Taps to Open to Water a Garden,"There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).
There are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.
Given an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.
Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.",0,Hard,,47.5,67.9,https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden,216,25K,52.7K,"Apple,Docusign,Twitter,Morgan Stanley","Dynamic Programming,Greedy",572,56,91,1,,"class Solution {
public:
    int minTaps(int n, vector<int>& ranges) {
        
    }
};","class Solution {
    public int minTaps(int n, int[] ranges) {
        
    }
}","class Solution(object):
    def minTaps(self, n, ranges):
        """"""
        :type n: int
        :type ranges: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        ","int minTaps(int n, int* ranges, int rangesSize){

}","public class Solution {
    public int MinTaps(int n, int[] ranges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[]} ranges
 * @return {number}
 */
var minTaps = function(n, ranges) {
    
};","# @param {Integer} n
# @param {Integer[]} ranges
# @return {Integer}
def min_taps(n, ranges)
    
end","class Solution {
    func minTaps(_ n: Int, _ ranges: [Int]) -> Int {
        
    }
}","func minTaps(n int, ranges []int) int {
    
}","object Solution {
    def minTaps(n: Int, ranges: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minTaps(n: Int, ranges: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_taps(n: i32, ranges: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[] $ranges
     * @return Integer
     */
    function minTaps($n, $ranges) {
        
    }
}","function minTaps(n: number, ranges: number[]): number {

};","(define/contract (min-taps n ranges)
  (-> exact-integer? (listof exact-integer?) exact-integer?)

  )","-spec min_taps(N :: integer(), Ranges :: [integer()]) -> integer().
min_taps(N, Ranges) ->
  .","defmodule Solution do
  @spec min_taps(n :: integer, ranges :: [integer]) :: integer
  def min_taps(n, ranges) do

  end
end","class Solution {
  int minTaps(int n, List<int> ranges) {

  }
}",,,,minimum-number-of-taps-to-open-to-water-a-garden
208,1330,Reverse Subarray To Maximize Array Value,"You are given an integer array `nums`. The value of this array is defined as the sum of `|nums[i]-nums[i+1]|` for all `0 <= i < nums.length-1`.
You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.
Find maximum possible value of the final array.",0,Hard,,36.8,0.0,https://leetcode.com/problems/reverse-subarray-to-maximize-array-value,39,2.9K,7.9K,Codenation,"Array,Math",221,27,89,0,,"class Solution {
public:
    int maxValueAfterReverse(vector<int>& nums) {
        
    }
};","class Solution {
    public int maxValueAfterReverse(int[] nums) {
        
    }
}","class Solution(object):
    def maxValueAfterReverse(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxValueAfterReverse(self, nums: List[int]) -> int:
        ","int maxValueAfterReverse(int* nums, int numsSize){

}","public class Solution {
    public int MaxValueAfterReverse(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maxValueAfterReverse = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def max_value_after_reverse(nums)
    
end","class Solution {
    func maxValueAfterReverse(_ nums: [Int]) -> Int {
        
    }
}","func maxValueAfterReverse(nums []int) int {
    
}","object Solution {
    def maxValueAfterReverse(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxValueAfterReverse(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_value_after_reverse(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxValueAfterReverse($nums) {
        
    }
}","function maxValueAfterReverse(nums: number[]): number {

};",,"-spec max_value_after_reverse(Nums :: [integer()]) -> integer().
max_value_after_reverse(Nums) ->
  .","defmodule Solution do
  @spec max_value_after_reverse(nums :: [integer]) :: integer
  def max_value_after_reverse(nums) do

  end
end","class Solution {
  int maxValueAfterReverse(List<int> nums) {

  }
}",,,,reverse-subarray-to-maximize-array-value
209,1335,Minimum Difficulty of a Job Schedule,"You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `i-th` job, you have to finish all the jobs `j` where `0 <= j < i`).
You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done in that day.
Given an array of integers `jobDifficulty` and an integer `d`. The difficulty of the `i-th` job is `jobDifficulty[i]`.
Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.",0,Hard,,56.6,93.7,https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule,247,34.9K,61.6K,"Amazon,Swiggy",Dynamic Programming,617,78,89,1,,"class Solution {
public:
    int minDifficulty(vector<int>& jobDifficulty, int d) {
        
    }
};","class Solution {
    public int minDifficulty(int[] jobDifficulty, int d) {
        
    }
}","class Solution(object):
    def minDifficulty(self, jobDifficulty, d):
        """"""
        :type jobDifficulty: List[int]
        :type d: int
        :rtype: int
        """"""
        ","class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
        ","int minDifficulty(int* jobDifficulty, int jobDifficultySize, int d){

}","public class Solution {
    public int MinDifficulty(int[] jobDifficulty, int d) {
        
    }
}","/**
 * @param {number[]} jobDifficulty
 * @param {number} d
 * @return {number}
 */
var minDifficulty = function(jobDifficulty, d) {
    
};","# @param {Integer[]} job_difficulty
# @param {Integer} d
# @return {Integer}
def min_difficulty(job_difficulty, d)
    
end","class Solution {
    func minDifficulty(_ jobDifficulty: [Int], _ d: Int) -> Int {
        
    }
}","func minDifficulty(jobDifficulty []int, d int) int {
    
}","object Solution {
    def minDifficulty(jobDifficulty: Array[Int], d: Int): Int = {
        
    }
}","class Solution {
    fun minDifficulty(jobDifficulty: IntArray, d: Int): Int {
        
    }
}","impl Solution {
    pub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $jobDifficulty
     * @param Integer $d
     * @return Integer
     */
    function minDifficulty($jobDifficulty, $d) {
        
    }
}","function minDifficulty(jobDifficulty: number[], d: number): number {

};",,"-spec min_difficulty(JobDifficulty :: [integer()], D :: integer()) -> integer().
min_difficulty(JobDifficulty, D) ->
  .","defmodule Solution do
  @spec min_difficulty(job_difficulty :: [integer], d :: integer) :: integer
  def min_difficulty(job_difficulty, d) do

  end
end","class Solution {
  int minDifficulty(List<int> jobDifficulty, int d) {

  }
}",,,,minimum-difficulty-of-a-job-schedule
210,1340,Jump Game V,"Given an array of integers `arr` and an integer `d`. In one step you can jump from index `i` to index:
`i + x` where: `i + x < arr.length` and ` 0 < x <= d`.
`i - x` where: `i - x >= 0` and ` 0 < x <= d`.
In addition, you can only jump from index `i` to index `j` if `arr[i] > arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More formally `min(i, j) < k < max(i, j)`).
You can choose any index of the array and start jumping. Return the maximum number of indices you can visit.
Notice that you can not jump outside of the array at any time.",0,Hard,,59.3,3.3,https://leetcode.com/problems/jump-game-v,183,11.8K,19.9K,Microsoft,Dynamic Programming,334,13,96,0,,"class Solution {
public:
    int maxJumps(vector<int>& arr, int d) {
        
    }
};","class Solution {
    public int maxJumps(int[] arr, int d) {
        
    }
}","class Solution(object):
    def maxJumps(self, arr, d):
        """"""
        :type arr: List[int]
        :type d: int
        :rtype: int
        """"""
        ","class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        ","int maxJumps(int* arr, int arrSize, int d){

}","public class Solution {
    public int MaxJumps(int[] arr, int d) {
        
    }
}","/**
 * @param {number[]} arr
 * @param {number} d
 * @return {number}
 */
var maxJumps = function(arr, d) {
    
};","# @param {Integer[]} arr
# @param {Integer} d
# @return {Integer}
def max_jumps(arr, d)
    
end","class Solution {
    func maxJumps(_ arr: [Int], _ d: Int) -> Int {
        
    }
}","func maxJumps(arr []int, d int) int {
    
}","object Solution {
    def maxJumps(arr: Array[Int], d: Int): Int = {
        
    }
}","class Solution {
    fun maxJumps(arr: IntArray, d: Int): Int {
        
    }
}","impl Solution {
    pub fn max_jumps(arr: Vec<i32>, d: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr
     * @param Integer $d
     * @return Integer
     */
    function maxJumps($arr, $d) {
        
    }
}","function maxJumps(arr: number[], d: number): number {

};",,,,"class Solution {
  int maxJumps(List<int> arr, int d) {

  }
}",,,,jump-game-v
211,1345,Jump Game IV,"Given an array of integers `arr`, you are initially positioned at the first index of the array.
In one step you can jump from index `i` to index:
`i + 1` where: `i + 1 < arr.length`.
`i - 1` where: `i - 1 >= 0`.
`j` where: `arr[i] == arr[j]` and `i != j`.
Return the minimum number of steps to reach the last index of the array.
Notice that you can not jump outside of the array at any time.",0,Hard,/articles/jump-game-iv,41.9,42.0,https://leetcode.com/problems/jump-game-iv,253,31.6K,75.3K,"Amazon,Google",Breadth-first Search,588,42,93,1,,"class Solution {
public:
    int minJumps(vector<int>& arr) {
        
    }
};","class Solution {
    public int minJumps(int[] arr) {
        
    }
}","class Solution(object):
    def minJumps(self, arr):
        """"""
        :type arr: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minJumps(self, arr: List[int]) -> int:
        ","int minJumps(int* arr, int arrSize){

}","public class Solution {
    public int MinJumps(int[] arr) {
        
    }
}","/**
 * @param {number[]} arr
 * @return {number}
 */
var minJumps = function(arr) {
    
};","# @param {Integer[]} arr
# @return {Integer}
def min_jumps(arr)
    
end","class Solution {
    func minJumps(_ arr: [Int]) -> Int {
        
    }
}","func minJumps(arr []int) int {
    
}","object Solution {
    def minJumps(arr: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minJumps(arr: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_jumps(arr: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr
     * @return Integer
     */
    function minJumps($arr) {
        
    }
}","function minJumps(arr: number[]): number {

};","(define/contract (min-jumps arr)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec min_jumps(Arr :: [integer()]) -> integer().
min_jumps(Arr) ->
  .","defmodule Solution do
  @spec min_jumps(arr :: [integer]) :: integer
  def min_jumps(arr) do

  end
end","class Solution {
  int minJumps(List<int> arr) {

  }
}",,,,jump-game-iv
212,1349,Maximum Students Taking Exam,"Given a `m * n` matrix `seats`  that represent seats distributions in a classroom. If a seat is broken, it is denoted by `'#'` character otherwise it is denoted by a `'.'` character.
Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the maximum number of students that can take the exam together without any cheating being possible..
Students must be placed in seats in good condition.",0,Hard,,44.2,12.9,https://leetcode.com/problems/maximum-students-taking-exam,112,7.4K,16.7K,SAP,Dynamic Programming,388,10,97,0,,"class Solution {
public:
    int maxStudents(vector<vector<char>>& seats) {
        
    }
};","class Solution {
    public int maxStudents(char[][] seats) {
        
    }
}","class Solution(object):
    def maxStudents(self, seats):
        """"""
        :type seats: List[List[str]]
        :rtype: int
        """"""
        ","class Solution:
    def maxStudents(self, seats: List[List[str]]) -> int:
        ","int maxStudents(char** seats, int seatsSize, int* seatsColSize){

}","public class Solution {
    public int MaxStudents(char[][] seats) {
        
    }
}","/**
 * @param {character[][]} seats
 * @return {number}
 */
var maxStudents = function(seats) {
    
};","# @param {Character[][]} seats
# @return {Integer}
def max_students(seats)
    
end","class Solution {
    func maxStudents(_ seats: [[Character]]) -> Int {
        
    }
}","func maxStudents(seats [][]byte) int {
    
}","object Solution {
    def maxStudents(seats: Array[Array[Char]]): Int = {
        
    }
}","class Solution {
    fun maxStudents(seats: Array<CharArray>): Int {
        
    }
}","impl Solution {
    pub fn max_students(seats: Vec<Vec<char>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[][] $seats
     * @return Integer
     */
    function maxStudents($seats) {
        
    }
}","function maxStudents(seats: string[][]): number {

};","(define/contract (max-students seats)
  (-> (listof (listof char?)) exact-integer?)

  )","-spec max_students(Seats :: [[char()]]) -> integer().
max_students(Seats) ->
  .","defmodule Solution do
  @spec max_students(seats :: [[char]]) :: integer
  def max_students(seats) do

  end
end","class Solution {
  int maxStudents(List<List<String>> seats) {

  }
}",,,,maximum-students-taking-exam
213,1354,Construct Target Array With Multiple Sums,"Given an array of integers `target`. From a starting array, `A` consisting of all 1's, you may perform the following procedure :
let `x` be the sum of all elements currently in your array.
choose index `i`, such that `0 <= i < target.size` and set the value of `A` at index `i` to `x`.
You may repeat this procedure as many times as needed.
Return True if it is possible to construct the `target` array from `A` otherwise return False.",0,Hard,/articles/construct-target-array-with-multiple-sums,31.3,35.3,https://leetcode.com/problems/construct-target-array-with-multiple-sums,115,8.9K,28.3K,Quora,Greedy,263,35,88,0,,"class Solution {
public:
    bool isPossible(vector<int>& target) {
        
    }
};","class Solution {
    public boolean isPossible(int[] target) {
        
    }
}","class Solution(object):
    def isPossible(self, target):
        """"""
        :type target: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def isPossible(self, target: List[int]) -> bool:
        ","bool isPossible(int* target, int targetSize){

}","public class Solution {
    public bool IsPossible(int[] target) {
        
    }
}","/**
 * @param {number[]} target
 * @return {boolean}
 */
var isPossible = function(target) {
    
};","# @param {Integer[]} target
# @return {Boolean}
def is_possible(target)
    
end","class Solution {
    func isPossible(_ target: [Int]) -> Bool {
        
    }
}","func isPossible(target []int) bool {
    
}","object Solution {
    def isPossible(target: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun isPossible(target: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn is_possible(target: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $target
     * @return Boolean
     */
    function isPossible($target) {
        
    }
}","function isPossible(target: number[]): boolean {

};","(define/contract (is-possible target)
  (-> (listof exact-integer?) boolean?)

  )","-spec is_possible(Target :: [integer()]) -> boolean().
is_possible(Target) ->
  .","defmodule Solution do
  @spec is_possible(target :: [integer]) :: boolean
  def is_possible(target) do

  end
end","class Solution {
  bool isPossible(List<int> target) {

  }
}",,,,construct-target-array-with-multiple-sums
214,1359,Count All Valid Pickup and Delivery Options,"Given `n` orders, each order consist in pickup and delivery services.
Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i).
Since the answer may be too large, return it modulo 10^9 + 7.",0,Hard,,56.3,53.7,https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options,143,11.6K,20.6K,DoorDash,"Math,Dynamic Programming",287,32,90,0,,"class Solution {
public:
    int countOrders(int n) {
        
    }
};","class Solution {
    public int countOrders(int n) {
        
    }
}","class Solution(object):
    def countOrders(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def countOrders(self, n: int) -> int:
        ","int countOrders(int n){

}","public class Solution {
    public int CountOrders(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var countOrders = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def count_orders(n)
    
end","class Solution {
    func countOrders(_ n: Int) -> Int {
        
    }
}","func countOrders(n int) int {
    
}","object Solution {
    def countOrders(n: Int): Int = {
        
    }
}","class Solution {
    fun countOrders(n: Int): Int {
        
    }
}","impl Solution {
    pub fn count_orders(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function countOrders($n) {
        
    }
}","function countOrders(n: number): number {

};","(define/contract (count-orders n)
  (-> exact-integer? exact-integer?)

  )","-spec count_orders(N :: integer()) -> integer().
count_orders(N) ->
  .","defmodule Solution do
  @spec count_orders(n :: integer) :: integer
  def count_orders(n) do

  end
end","class Solution {
  int countOrders(int n) {

  }
}",,,,count-all-valid-pickup-and-delivery-options
215,1363,Largest Multiple of Three,"Given an integer array of `digits`, return the largest multiple of three that can be formed by concatenating some of the given digits in any order.
Since the answer may not fit in an integer data type, return the answer as a string.
If there is no answer return an empty string.",0,Hard,,34.1,3.9,https://leetcode.com/problems/largest-multiple-of-three,153,10K,29.4K,Amazon,"Math,Dynamic Programming",244,39,86,1,,"class Solution {
public:
    string largestMultipleOfThree(vector<int>& digits) {
        
    }
};","class Solution {
    public String largestMultipleOfThree(int[] digits) {
        
    }
}","class Solution(object):
    def largestMultipleOfThree(self, digits):
        """"""
        :type digits: List[int]
        :rtype: str
        """"""
        ","class Solution:
    def largestMultipleOfThree(self, digits: List[int]) -> str:
        ","char * largestMultipleOfThree(int* digits, int digitsSize){

}","public class Solution {
    public string LargestMultipleOfThree(int[] digits) {
        
    }
}","/**
 * @param {number[]} digits
 * @return {string}
 */
var largestMultipleOfThree = function(digits) {
    
};","# @param {Integer[]} digits
# @return {String}
def largest_multiple_of_three(digits)
    
end","class Solution {
    func largestMultipleOfThree(_ digits: [Int]) -> String {
        
    }
}","func largestMultipleOfThree(digits []int) string {
    
}","object Solution {
    def largestMultipleOfThree(digits: Array[Int]): String = {
        
    }
}","class Solution {
    fun largestMultipleOfThree(digits: IntArray): String {
        
    }
}","impl Solution {
    pub fn largest_multiple_of_three(digits: Vec<i32>) -> String {
        
    }
}","class Solution {

    /**
     * @param Integer[] $digits
     * @return String
     */
    function largestMultipleOfThree($digits) {
        
    }
}","function largestMultipleOfThree(digits: number[]): string {

};","(define/contract (largest-multiple-of-three digits)
  (-> (listof exact-integer?) string?)

  )","-spec largest_multiple_of_three(Digits :: [integer()]) -> unicode:unicode_binary().
largest_multiple_of_three(Digits) ->
  .","defmodule Solution do
  @spec largest_multiple_of_three(digits :: [integer]) :: String.t
  def largest_multiple_of_three(digits) do

  end
end","class Solution {
  String largestMultipleOfThree(List<int> digits) {

  }
}",,,,largest-multiple-of-three
216,1368,Minimum Cost to Make at Least One Valid Path in a Grid,"Given a m x n `grid`. Each cell of the `grid` has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:
1 which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)
2 which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)
3 which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)
4 which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)
Notice that there could be some invalid signs on the cells of the `grid` which points outside the `grid`.
You will initially start at the upper left cell `(0,0)`. A valid path in the grid is a path which starts from the upper left cell `(0,0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path doesn't have to be the shortest.
You can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell one time only.
Return the minimum cost to make the grid have at least one valid path.",0,Hard,,57.6,21.1,https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid,179,16.4K,28.4K,Google,Breadth-first Search,513,7,99,1,,"class Solution {
public:
    int minCost(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int minCost(int[][] grid) {
        
    }
}","class Solution(object):
    def minCost(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        ","int minCost(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int MinCost(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var minCost = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def min_cost(grid)
    
end","class Solution {
    func minCost(_ grid: [[Int]]) -> Int {
        
    }
}","func minCost(grid [][]int) int {
    
}","object Solution {
    def minCost(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minCost(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn min_cost(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function minCost($grid) {
        
    }
}","function minCost(grid: number[][]): number {

};","(define/contract (min-cost grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec min_cost(Grid :: [[integer()]]) -> integer().
min_cost(Grid) ->
  .","defmodule Solution do
  @spec min_cost(grid :: [[integer]]) :: integer
  def min_cost(grid) do

  end
end","class Solution {
  int minCost(List<List<int>> grid) {

  }
}",,,,minimum-cost-to-make-at-least-one-valid-path-in-a-grid
218,1377,Frog Position After T Seconds,"Given an undirected tree consisting of `n` vertices numbered from `1` to `n`. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.
The edges of the undirected tree are given in the array `edges`, where `edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai` and `bi`.
Return the probability that after `t` seconds the frog is on the vertex `target`.",0,Hard,,35.4,3.0,https://leetcode.com/problems/frog-position-after-t-seconds,197,12.6K,35.7K,Google,Depth-first Search,188,69,73,1,,"class Solution {
public:
    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
        
    }
};","class Solution {
    public double frogPosition(int n, int[][] edges, int t, int target) {
        
    }
}","class Solution(object):
    def frogPosition(self, n, edges, t, target):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type t: int
        :type target: int
        :rtype: float
        """"""
        ","class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        ","double frogPosition(int n, int** edges, int edgesSize, int* edgesColSize, int t, int target){

}","public class Solution {
    public double FrogPosition(int n, int[][] edges, int t, int target) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number} t
 * @param {number} target
 * @return {number}
 */
var frogPosition = function(n, edges, t, target) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @param {Integer} t
# @param {Integer} target
# @return {Float}
def frog_position(n, edges, t, target)
    
end","class Solution {
    func frogPosition(_ n: Int, _ edges: [[Int]], _ t: Int, _ target: Int) -> Double {
        
    }
}","func frogPosition(n int, edges [][]int, t int, target int) float64 {
    
}","object Solution {
    def frogPosition(n: Int, edges: Array[Array[Int]], t: Int, target: Int): Double = {
        
    }
}","class Solution {
    fun frogPosition(n: Int, edges: Array<IntArray>, t: Int, target: Int): Double {
        
    }
}","impl Solution {
    pub fn frog_position(n: i32, edges: Vec<Vec<i32>>, t: i32, target: i32) -> f64 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @param Integer $t
     * @param Integer $target
     * @return Float
     */
    function frogPosition($n, $edges, $t, $target) {
        
    }
}","function frogPosition(n: number, edges: number[][], t: number, target: number): number {

};","(define/contract (frog-position n edges t target)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? exact-integer? flonum?)

  )","-spec frog_position(N :: integer(), Edges :: [[integer()]], T :: integer(), Target :: integer()) -> float().
frog_position(N, Edges, T, Target) ->
  .","defmodule Solution do
  @spec frog_position(n :: integer, edges :: [[integer]], t :: integer, target :: integer) :: float
  def frog_position(n, edges, t, target) do

  end
end","class Solution {
  double frogPosition(int n, List<List<int>> edges, int t, int target) {

  }
}",,,,frog-position-after-t-seconds
219,1383,Maximum Performance of a Team,"There are `n` engineers numbered from 1 to `n` and two arrays: `speed` and `efficiency`, where `speed[i]` and `efficiency[i]` represent the speed and efficiency for the i-th engineer respectively. Return the maximum performance of a team composed of at most `k` engineers, since the answer can be a huge number, return this modulo 10^9 + 7.
The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.",0,Hard,,36.0,57.2,https://leetcode.com/problems/maximum-performance-of-a-team,94,13.4K,37.3K,"DoorDash,Amazon","Greedy,Sort",407,28,94,1,,"class Solution {
public:
    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {
        
    }
};","class Solution {
    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {
        
    }
}","class Solution(object):
    def maxPerformance(self, n, speed, efficiency, k):
        """"""
        :type n: int
        :type speed: List[int]
        :type efficiency: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        ","int maxPerformance(int n, int* speed, int speedSize, int* efficiency, int efficiencySize, int k){

}","public class Solution {
    public int MaxPerformance(int n, int[] speed, int[] efficiency, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number[]} speed
 * @param {number[]} efficiency
 * @param {number} k
 * @return {number}
 */
var maxPerformance = function(n, speed, efficiency, k) {
    
};","# @param {Integer} n
# @param {Integer[]} speed
# @param {Integer[]} efficiency
# @param {Integer} k
# @return {Integer}
def max_performance(n, speed, efficiency, k)
    
end","class Solution {
    func maxPerformance(_ n: Int, _ speed: [Int], _ efficiency: [Int], _ k: Int) -> Int {
        
    }
}","func maxPerformance(n int, speed []int, efficiency []int, k int) int {
    
}","object Solution {
    def maxPerformance(n: Int, speed: Array[Int], efficiency: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun maxPerformance(n: Int, speed: IntArray, efficiency: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn max_performance(n: i32, speed: Vec<i32>, efficiency: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[] $speed
     * @param Integer[] $efficiency
     * @param Integer $k
     * @return Integer
     */
    function maxPerformance($n, $speed, $efficiency, $k) {
        
    }
}","function maxPerformance(n: number, speed: number[], efficiency: number[], k: number): number {

};","(define/contract (max-performance n speed efficiency k)
  (-> exact-integer? (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec max_performance(N :: integer(), Speed :: [integer()], Efficiency :: [integer()], K :: integer()) -> integer().
max_performance(N, Speed, Efficiency, K) ->
  .","defmodule Solution do
  @spec max_performance(n :: integer, speed :: [integer], efficiency :: [integer], k :: integer) :: integer
  def max_performance(n, speed, efficiency, k) do

  end
end","class Solution {
  int maxPerformance(int n, List<int> speed, List<int> efficiency, int k) {

  }
}",,,,maximum-performance-of-a-team
220,1388,Pizza With 3n Slices,"There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:
You will pick any pizza slice.
Your friend Alice will pick next slice in anti clockwise direction of your pick.
Your friend Bob will pick next slice in clockwise direction of your pick.
Repeat until there are no more slices of pizzas.
Sizes of Pizza slices is represented by circular array `slices` in clockwise direction.
Return the maximum possible sum of slice sizes which you can have.",0,Hard,,46.2,0.0,https://leetcode.com/problems/pizza-with-3n-slices,63,5.6K,12K,Google,Dynamic Programming,343,5,99,1,,"class Solution {
public:
    int maxSizeSlices(vector<int>& slices) {
        
    }
};","class Solution {
    public int maxSizeSlices(int[] slices) {
        
    }
}","class Solution(object):
    def maxSizeSlices(self, slices):
        """"""
        :type slices: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxSizeSlices(self, slices: List[int]) -> int:
        ","int maxSizeSlices(int* slices, int slicesSize){

}","public class Solution {
    public int MaxSizeSlices(int[] slices) {
        
    }
}","/**
 * @param {number[]} slices
 * @return {number}
 */
var maxSizeSlices = function(slices) {
    
};","# @param {Integer[]} slices
# @return {Integer}
def max_size_slices(slices)
    
end","class Solution {
    func maxSizeSlices(_ slices: [Int]) -> Int {
        
    }
}","func maxSizeSlices(slices []int) int {
    
}","object Solution {
    def maxSizeSlices(slices: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxSizeSlices(slices: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_size_slices(slices: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $slices
     * @return Integer
     */
    function maxSizeSlices($slices) {
        
    }
}","function maxSizeSlices(slices: number[]): number {

};","(define/contract (max-size-slices slices)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_size_slices(Slices :: [integer()]) -> integer().
max_size_slices(Slices) ->
  .","defmodule Solution do
  @spec max_size_slices(slices :: [integer]) :: integer
  def max_size_slices(slices) do

  end
end","class Solution {
  int maxSizeSlices(List<int> slices) {

  }
}",,,,pizza-with-3n-slices
221,1392,Longest Happy Prefix,"A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).
Given a string `s`. Return the longest happy prefix of `s` .
Return an empty string if no such prefix exists.",0,Hard,,42.0,2.9,https://leetcode.com/problems/longest-happy-prefix,157,12.5K,29.8K,Google,String,330,19,95,1,,"class Solution {
public:
    string longestPrefix(string s) {
        
    }
};","class Solution {
    public String longestPrefix(String s) {
        
    }
}","class Solution(object):
    def longestPrefix(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        ","class Solution:
    def longestPrefix(self, s: str) -> str:
        ","char * longestPrefix(char * s){

}","public class Solution {
    public string LongestPrefix(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string}
 */
var longestPrefix = function(s) {
    
};","# @param {String} s
# @return {String}
def longest_prefix(s)
    
end","class Solution {
    func longestPrefix(_ s: String) -> String {
        
    }
}","func longestPrefix(s string) string {
    
}","object Solution {
    def longestPrefix(s: String): String = {
        
    }
}","class Solution {
    fun longestPrefix(s: String): String {
        
    }
}","impl Solution {
    pub fn longest_prefix(s: String) -> String {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String
     */
    function longestPrefix($s) {
        
    }
}","function longestPrefix(s: string): string {

};","(define/contract (longest-prefix s)
  (-> string? string?)

  )","-spec longest_prefix(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
longest_prefix(S) ->
  .","defmodule Solution do
  @spec longest_prefix(s :: String.t) :: String.t
  def longest_prefix(s) do

  end
end","class Solution {
  String longestPrefix(String s) {

  }
}",,,,longest-happy-prefix
222,1397,Find All Good Strings,"Given the strings `s1` and `s2` of size `n`, and the string `evil`. Return the number of good strings.
A good string has size `n`, it is alphabetically greater than or equal to `s1`, it is alphabetically smaller than or equal to `s2`, and it does not contain the string `evil` as a substring. Since the answer can be a huge number, return this modulo 10^9 + 7.",0,Hard,,38.7,0.0,https://leetcode.com/problems/find-all-good-strings,67,2.9K,7.4K,Dunzo,Dynamic Programming,179,90,67,0,,"class Solution {
public:
    int findGoodStrings(int n, string s1, string s2, string evil) {
        
    }
};","class Solution {
    public int findGoodStrings(int n, String s1, String s2, String evil) {
        
    }
}","class Solution(object):
    def findGoodStrings(self, n, s1, s2, evil):
        """"""
        :type n: int
        :type s1: str
        :type s2: str
        :type evil: str
        :rtype: int
        """"""
        ","class Solution:
    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
        ","int findGoodStrings(int n, char * s1, char * s2, char * evil){

}","public class Solution {
    public int FindGoodStrings(int n, string s1, string s2, string evil) {
        
    }
}","/**
 * @param {number} n
 * @param {string} s1
 * @param {string} s2
 * @param {string} evil
 * @return {number}
 */
var findGoodStrings = function(n, s1, s2, evil) {
    
};","# @param {Integer} n
# @param {String} s1
# @param {String} s2
# @param {String} evil
# @return {Integer}
def find_good_strings(n, s1, s2, evil)
    
end","class Solution {
    func findGoodStrings(_ n: Int, _ s1: String, _ s2: String, _ evil: String) -> Int {
        
    }
}","func findGoodStrings(n int, s1 string, s2 string, evil string) int {
    
}","object Solution {
    def findGoodStrings(n: Int, s1: String, s2: String, evil: String): Int = {
        
    }
}","class Solution {
    fun findGoodStrings(n: Int, s1: String, s2: String, evil: String): Int {
        
    }
}","impl Solution {
    pub fn find_good_strings(n: i32, s1: String, s2: String, evil: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param String $s1
     * @param String $s2
     * @param String $evil
     * @return Integer
     */
    function findGoodStrings($n, $s1, $s2, $evil) {
        
    }
}","function findGoodStrings(n: number, s1: string, s2: string, evil: string): number {

};","(define/contract (find-good-strings n s1 s2 evil)
  (-> exact-integer? string? string? string? exact-integer?)

  )","-spec find_good_strings(N :: integer(), S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary(), Evil :: unicode:unicode_binary()) -> integer().
find_good_strings(N, S1, S2, Evil) ->
  .","defmodule Solution do
  @spec find_good_strings(n :: integer, s1 :: String.t, s2 :: String.t, evil :: String.t) :: integer
  def find_good_strings(n, s1, s2, evil) do

  end
end","class Solution {
  int findGoodStrings(int n, String s1, String s2, String evil) {

  }
}",,,,find-all-good-strings
223,1402,Reducing Dishes,"A chef has collected data on the `satisfaction` level of his `n` dishes. Chef can cook any dish in 1 unit of time.
Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level  i.e.  `time[i]`*`satisfaction[i]`
Return the maximum sum of Like-time coefficient that the chef can obtain after dishes preparation.
Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.",0,Hard,,72.1,28.3,https://leetcode.com/problems/reducing-dishes,305,20.7K,28.7K,OT,Dynamic Programming,414,89,82,0,,"class Solution {
public:
    int maxSatisfaction(vector<int>& satisfaction) {
        
    }
};","class Solution {
    public int maxSatisfaction(int[] satisfaction) {
        
    }
}","class Solution(object):
    def maxSatisfaction(self, satisfaction):
        """"""
        :type satisfaction: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxSatisfaction(self, satisfaction: List[int]) -> int:
        ","int maxSatisfaction(int* satisfaction, int satisfactionSize){

}","public class Solution {
    public int MaxSatisfaction(int[] satisfaction) {
        
    }
}","/**
 * @param {number[]} satisfaction
 * @return {number}
 */
var maxSatisfaction = function(satisfaction) {
    
};","# @param {Integer[]} satisfaction
# @return {Integer}
def max_satisfaction(satisfaction)
    
end","class Solution {
    func maxSatisfaction(_ satisfaction: [Int]) -> Int {
        
    }
}","func maxSatisfaction(satisfaction []int) int {
    
}","object Solution {
    def maxSatisfaction(satisfaction: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxSatisfaction(satisfaction: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_satisfaction(satisfaction: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $satisfaction
     * @return Integer
     */
    function maxSatisfaction($satisfaction) {
        
    }
}","function maxSatisfaction(satisfaction: number[]): number {

};",,"-spec max_satisfaction(Satisfaction :: [integer()]) -> integer().
max_satisfaction(Satisfaction) ->
  .","defmodule Solution do
  @spec max_satisfaction(satisfaction :: [integer]) :: integer
  def max_satisfaction(satisfaction) do

  end
end","class Solution {
  int maxSatisfaction(List<int> satisfaction) {

  }
}",,,,reducing-dishes
224,1406,Stone Game III,"Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array `stoneValue`.
Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2 or 3 stones from the first remaining stones in the row.
The score of each player is the sum of values of the stones taken. The score of each player is 0 initially.
The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.
Assume Alice and Bob play optimally.
Return ""Alice"" if Alice will win, ""Bob"" if Bob will win or ""Tie"" if they end the game with the same score.",0,Hard,,57.8,11.5,https://leetcode.com/problems/stone-game-iii,183,17.7K,30.5K,Google,Dynamic Programming,521,9,98,1,"[Stone Game V, /problems/stone-game-v/, Hard], [Stone Game VI, /problems/stone-game-vi/, Medium], [Stone Game VII, /problems/stone-game-vii/, Medium]","class Solution {
public:
    string stoneGameIII(vector<int>& stoneValue) {
        
    }
};","class Solution {
    public String stoneGameIII(int[] stoneValue) {
        
    }
}","class Solution(object):
    def stoneGameIII(self, stoneValue):
        """"""
        :type stoneValue: List[int]
        :rtype: str
        """"""
        ","class Solution:
    def stoneGameIII(self, stoneValue: List[int]) -> str:
        ","char * stoneGameIII(int* stoneValue, int stoneValueSize){

}","public class Solution {
    public string StoneGameIII(int[] stoneValue) {
        
    }
}","/**
 * @param {number[]} stoneValue
 * @return {string}
 */
var stoneGameIII = function(stoneValue) {
    
};","# @param {Integer[]} stone_value
# @return {String}
def stone_game_iii(stone_value)
    
end","class Solution {
    func stoneGameIII(_ stoneValue: [Int]) -> String {
        
    }
}","func stoneGameIII(stoneValue []int) string {
    
}","object Solution {
    def stoneGameIII(stoneValue: Array[Int]): String = {
        
    }
}","class Solution {
    fun stoneGameIII(stoneValue: IntArray): String {
        
    }
}","impl Solution {
    pub fn stone_game_iii(stone_value: Vec<i32>) -> String {
        
    }
}","class Solution {

    /**
     * @param Integer[] $stoneValue
     * @return String
     */
    function stoneGameIII($stoneValue) {
        
    }
}","function stoneGameIII(stoneValue: number[]): string {

};",,,,"class Solution {
  String stoneGameIII(List<int> stoneValue) {

  }
}",,,,stone-game-iii
225,1416,Restore The Array,"A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits and all we know is that all integers in the array were in the range `[1, k]` and there are no leading zeros in the array.
Given the string `s` and the integer `k`. There can be multiple ways to restore the array.
Return the number of possible array that can be printed as a string `s` using the mentioned program.
The number of ways could be very large so return it modulo `10^9 + 7`",0,Hard,,36.8,9.5,https://leetcode.com/problems/restore-the-array,118,8.6K,23.3K,ByteDance,Dynamic Programming,226,8,97,0,,"class Solution {
public:
    int numberOfArrays(string s, int k) {
        
    }
};","class Solution {
    public int numberOfArrays(String s, int k) {
        
    }
}","class Solution(object):
    def numberOfArrays(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        ","int numberOfArrays(char * s, int k){

}","public class Solution {
    public int NumberOfArrays(string s, int k) {
        
    }
}","/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var numberOfArrays = function(s, k) {
    
};","# @param {String} s
# @param {Integer} k
# @return {Integer}
def number_of_arrays(s, k)
    
end","class Solution {
    func numberOfArrays(_ s: String, _ k: Int) -> Int {
        
    }
}","func numberOfArrays(s string, k int) int {
    
}","object Solution {
    def numberOfArrays(s: String, k: Int): Int = {
        
    }
}","class Solution {
    fun numberOfArrays(s: String, k: Int): Int {
        
    }
}","impl Solution {
    pub fn number_of_arrays(s: String, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param Integer $k
     * @return Integer
     */
    function numberOfArrays($s, $k) {
        
    }
}","function numberOfArrays(s: string, k: number): number {

};",,"-spec number_of_arrays(S :: unicode:unicode_binary(), K :: integer()) -> integer().
number_of_arrays(S, K) ->
  .","defmodule Solution do
  @spec number_of_arrays(s :: String.t, k :: integer) :: integer
  def number_of_arrays(s, k) do

  end
end","class Solution {
  int numberOfArrays(String s, int k) {

  }
}",,,,restore-the-array
226,1420,Build Array Where You Can Find The Maximum Exactly K Comparisons,"Given three integers `n`, `m` and `k`. Consider the following algorithm to find the maximum element of an array of positive integers:
You should build the array arr which has the following properties:
`arr` has exactly `n` integers.
`1 <= arr[i] <= m` where `(0 <= i < n)`.
After applying the mentioned algorithm to `arr`, the value `search_cost` is equal to `k`.
Return the number of ways to build the array `arr` under the mentioned conditions. As the answer may grow large, the answer must be computed modulo `10^9 + 7`.",0,Hard,,64.1,18.6,https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons,122,7.3K,11.4K,Dunzo,Dynamic Programming,276,7,98,0,,"class Solution {
public:
    int numOfArrays(int n, int m, int k) {
        
    }
};","class Solution {
    public int numOfArrays(int n, int m, int k) {
        
    }
}","class Solution(object):
    def numOfArrays(self, n, m, k):
        """"""
        :type n: int
        :type m: int
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def numOfArrays(self, n: int, m: int, k: int) -> int:
        ","int numOfArrays(int n, int m, int k){

}","public class Solution {
    public int NumOfArrays(int n, int m, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number} m
 * @param {number} k
 * @return {number}
 */
var numOfArrays = function(n, m, k) {
    
};","# @param {Integer} n
# @param {Integer} m
# @param {Integer} k
# @return {Integer}
def num_of_arrays(n, m, k)
    
end","class Solution {
    func numOfArrays(_ n: Int, _ m: Int, _ k: Int) -> Int {
        
    }
}","func numOfArrays(n int, m int, k int) int {
    
}","object Solution {
    def numOfArrays(n: Int, m: Int, k: Int): Int = {
        
    }
}","class Solution {
    fun numOfArrays(n: Int, m: Int, k: Int): Int {
        
    }
}","impl Solution {
    pub fn num_of_arrays(n: i32, m: i32, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $m
     * @param Integer $k
     * @return Integer
     */
    function numOfArrays($n, $m, $k) {
        
    }
}","function numOfArrays(n: number, m: number, k: number): number {

};",,,,"class Solution {
  int numOfArrays(int n, int m, int k) {

  }
}",,,,build-array-where-you-can-find-the-maximum-exactly-k-comparisons
227,1425,Constrained Subsequence Sum,"Given an integer array `nums` and an integer `k`, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, `nums[i]` and `nums[j]`, where `i < j`, the condition `j - i <= k` is satisfied.
A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.",0,Hard,,45.0,0.0,https://leetcode.com/problems/constrained-subsequence-sum,157,12.1K,27K,Akuna Capital,Dynamic Programming,487,22,96,0,,"class Solution {
public:
    int constrainedSubsetSum(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int constrainedSubsetSum(int[] nums, int k) {
        
    }
}","class Solution(object):
    def constrainedSubsetSum(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:
        ","int constrainedSubsetSum(int* nums, int numsSize, int k){

}","public class Solution {
    public int ConstrainedSubsetSum(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var constrainedSubsetSum = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def constrained_subset_sum(nums, k)
    
end","class Solution {
    func constrainedSubsetSum(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func constrainedSubsetSum(nums []int, k int) int {
    
}","object Solution {
    def constrainedSubsetSum(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun constrainedSubsetSum(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn constrained_subset_sum(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function constrainedSubsetSum($nums, $k) {
        
    }
}","function constrainedSubsetSum(nums: number[], k: number): number {

};",,"-spec constrained_subset_sum(Nums :: [integer()], K :: integer()) -> integer().
constrained_subset_sum(Nums, K) ->
  .","defmodule Solution do
  @spec constrained_subset_sum(nums :: [integer], k :: integer) :: integer
  def constrained_subset_sum(nums, k) do

  end
end","class Solution {
  int constrainedSubsetSum(List<int> nums, int k) {

  }
}",,,,constrained-subsequence-sum
228,1434,Number of Ways to Wear Different Hats to Each Other,"There are `n` people and 40 types of hats labeled from 1 to 40.
Given a list of list of integers `hats`, where `hats[i]` is a list of all hats preferred by the i-th` person.
Return the number of ways that the n people wear different hats to each other.
Since the answer may be too large, return it modulo `10^9 + 7`.",0,Hard,,39.6,0.0,https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other,93,6.2K,15.6K,MindTickle,"Dynamic Programming,Bit Manipulation",384,5,99,0,,"class Solution {
public:
    int numberWays(vector<vector<int>>& hats) {
        
    }
};","class Solution {
    public int numberWays(List<List<Integer>> hats) {
        
    }
}","class Solution(object):
    def numberWays(self, hats):
        """"""
        :type hats: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def numberWays(self, hats: List[List[int]]) -> int:
        ","int numberWays(int** hats, int hatsSize, int* hatsColSize){

}","public class Solution {
    public int NumberWays(IList<IList<int>> hats) {
        
    }
}","/**
 * @param {number[][]} hats
 * @return {number}
 */
var numberWays = function(hats) {
    
};","# @param {Integer[][]} hats
# @return {Integer}
def number_ways(hats)
    
end","class Solution {
    func numberWays(_ hats: [[Int]]) -> Int {
        
    }
}","func numberWays(hats [][]int) int {
    
}","object Solution {
    def numberWays(hats: List[List[Int]]): Int = {
        
    }
}","class Solution {
    fun numberWays(hats: List<List<Int>>): Int {
        
    }
}","impl Solution {
    pub fn number_ways(hats: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $hats
     * @return Integer
     */
    function numberWays($hats) {
        
    }
}","function numberWays(hats: number[][]): number {

};",,,,"class Solution {
  int numberWays(List<List<int>> hats) {

  }
}",,,,number-of-ways-to-wear-different-hats-to-each-other
229,1439,Find the Kth Smallest Sum of a Matrix With Sorted Rows,"You are given an `m * n` matrix, `mat`, and an integer `k`, which has its rows sorted in non-decreasing order.
You are allowed to choose exactly 1 element from each row to form an array. Return the Kth smallest array sum among all possible arrays.",0,Hard,,60.2,19.3,https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows,152,15.3K,25.4K,Facebook,Heap,485,7,99,1,,"class Solution {
public:
    int kthSmallest(vector<vector<int>>& mat, int k) {
        
    }
};","class Solution {
    public int kthSmallest(int[][] mat, int k) {
        
    }
}","class Solution(object):
    def kthSmallest(self, mat, k):
        """"""
        :type mat: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        ","int kthSmallest(int** mat, int matSize, int* matColSize, int k){

}","public class Solution {
    public int KthSmallest(int[][] mat, int k) {
        
    }
}","/**
 * @param {number[][]} mat
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(mat, k) {
    
};","# @param {Integer[][]} mat
# @param {Integer} k
# @return {Integer}
def kth_smallest(mat, k)
    
end","class Solution {
    func kthSmallest(_ mat: [[Int]], _ k: Int) -> Int {
        
    }
}","func kthSmallest(mat [][]int, k int) int {
    
}","object Solution {
    def kthSmallest(mat: Array[Array[Int]], k: Int): Int = {
        
    }
}","class Solution {
    fun kthSmallest(mat: Array<IntArray>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn kth_smallest(mat: Vec<Vec<i32>>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $mat
     * @param Integer $k
     * @return Integer
     */
    function kthSmallest($mat, $k) {
        
    }
}","function kthSmallest(mat: number[][], k: number): number {

};","(define/contract (kth-smallest mat k)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec kth_smallest(Mat :: [[integer()]], K :: integer()) -> integer().
kth_smallest(Mat, K) ->
  .","defmodule Solution do
  @spec kth_smallest(mat :: [[integer]], k :: integer) :: integer
  def kth_smallest(mat, k) do

  end
end","class Solution {
  int kthSmallest(List<List<int>> mat, int k) {

  }
}",,,,find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows
230,1444,Number of Ways of Cutting a Pizza,"Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.
For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.
Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.",0,Hard,,53.9,6.0,https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza,133,8.3K,15.5K,Google,Dynamic Programming,302,8,97,1,,"class Solution {
public:
    int ways(vector<string>& pizza, int k) {
        
    }
};","class Solution {
    public int ways(String[] pizza, int k) {
        
    }
}","class Solution(object):
    def ways(self, pizza, k):
        """"""
        :type pizza: List[str]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        ","

int ways(char ** pizza, int pizzaSize, int k){

}","public class Solution {
    public int Ways(string[] pizza, int k) {
        
    }
}","/**
 * @param {string[]} pizza
 * @param {number} k
 * @return {number}
 */
var ways = function(pizza, k) {
    
};","# @param {String[]} pizza
# @param {Integer} k
# @return {Integer}
def ways(pizza, k)
    
end","class Solution {
    func ways(_ pizza: [String], _ k: Int) -> Int {
        
    }
}","func ways(pizza []string, k int) int {
    
}","object Solution {
    def ways(pizza: Array[String], k: Int): Int = {
        
    }
}","class Solution {
    fun ways(pizza: Array<String>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn ways(pizza: Vec<String>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $pizza
     * @param Integer $k
     * @return Integer
     */
    function ways($pizza, $k) {
        
    }
}","function ways(pizza: string[], k: number): number {

};",,,,,,,,number-of-ways-of-cutting-a-pizza
231,1449,Form Largest Integer With Digits That Add up to Target,"Given an array of integers `cost` and an integer `target`. Return the maximum integer you can paint under the following rules:
The cost of painting a digit (i+1) is given by `cost[i]` (0 indexed).
The total cost used must be equal to `target`.
Integer does not have digits 0.
Since the answer may be too large, return it as string.
If there is no way to paint any integer given the condition, return ""0"".",0,Hard,,44.3,10.7,https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target,122,9K,20.2K,Google,"String,Dynamic Programming",332,6,98,1,,"class Solution {
public:
    string largestNumber(vector<int>& cost, int target) {
        
    }
};","class Solution {
    public String largestNumber(int[] cost, int target) {
        
    }
}","class Solution(object):
    def largestNumber(self, cost, target):
        """"""
        :type cost: List[int]
        :type target: int
        :rtype: str
        """"""
        ","class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        ","char * largestNumber(int* cost, int costSize, int target){

}","public class Solution {
    public string LargestNumber(int[] cost, int target) {
        
    }
}","/**
 * @param {number[]} cost
 * @param {number} target
 * @return {string}
 */
var largestNumber = function(cost, target) {
    
};","# @param {Integer[]} cost
# @param {Integer} target
# @return {String}
def largest_number(cost, target)
    
end","class Solution {
    func largestNumber(_ cost: [Int], _ target: Int) -> String {
        
    }
}","func largestNumber(cost []int, target int) string {
    
}","object Solution {
    def largestNumber(cost: Array[Int], target: Int): String = {
        
    }
}","class Solution {
    fun largestNumber(cost: IntArray, target: Int): String {
        
    }
}","impl Solution {
    pub fn largest_number(cost: Vec<i32>, target: i32) -> String {
        
    }
}","class Solution {

    /**
     * @param Integer[] $cost
     * @param Integer $target
     * @return String
     */
    function largestNumber($cost, $target) {
        
    }
}","function largestNumber(cost: number[], target: number): string {

};","(define/contract (largest-number cost target)
  (-> (listof exact-integer?) exact-integer? string?)

  )","-spec largest_number(Cost :: [integer()], Target :: integer()) -> unicode:unicode_binary().
largest_number(Cost, Target) ->
  .","defmodule Solution do
  @spec largest_number(cost :: [integer], target :: integer) :: String.t
  def largest_number(cost, target) do

  end
end","class Solution {
  String largestNumber(List<int> cost, int target) {

  }
}",,,,form-largest-integer-with-digits-that-add-up-to-target
232,1453,Maximum Number of Darts Inside of a Circular Dartboard,"You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of `points` on a 2D plane.
Return the maximum number of points that are within or lie on any circular dartboard of radius `r`.",0,Hard,,35.5,0.0,https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard,54,3.9K,11K,Facebook,Geometry,86,210,29,1,,"class Solution {
public:
    int numPoints(vector<vector<int>>& darts, int r) {
        
    }
};","class Solution {
    public int numPoints(int[][] darts, int r) {
        
    }
}","class Solution(object):
    def numPoints(self, darts, r):
        """"""
        :type darts: List[List[int]]
        :type r: int
        :rtype: int
        """"""
        ","class Solution:
    def numPoints(self, darts: List[List[int]], r: int) -> int:
        ","int numPoints(int** darts, int dartsSize, int* dartsColSize, int r){

}","public class Solution {
    public int NumPoints(int[][] darts, int r) {
        
    }
}","/**
 * @param {number[][]} darts
 * @param {number} r
 * @return {number}
 */
var numPoints = function(darts, r) {
    
};","# @param {Integer[][]} darts
# @param {Integer} r
# @return {Integer}
def num_points(darts, r)
    
end","class Solution {
    func numPoints(_ darts: [[Int]], _ r: Int) -> Int {
        
    }
}","func numPoints(darts [][]int, r int) int {
    
}","object Solution {
    def numPoints(darts: Array[Array[Int]], r: Int): Int = {
        
    }
}","class Solution {
    fun numPoints(darts: Array<IntArray>, r: Int): Int {
        
    }
}","impl Solution {
    pub fn num_points(darts: Vec<Vec<i32>>, r: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $darts
     * @param Integer $r
     * @return Integer
     */
    function numPoints($darts, $r) {
        
    }
}","function numPoints(darts: number[][], r: number): number {

};","(define/contract (num-points darts r)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec num_points(Darts :: [[integer()]], R :: integer()) -> integer().
num_points(Darts, R) ->
  .","defmodule Solution do
  @spec num_points(darts :: [[integer]], r :: integer) :: integer
  def num_points(darts, r) do

  end
end","class Solution {
  int numPoints(List<List<int>> darts, int r) {

  }
}",,,,maximum-number-of-darts-inside-of-a-circular-dartboard
233,1458,Max Dot Product of Two Subsequences,"Given two arrays `nums1` and `nums2`.
Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.
A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not).",0,Hard,,43.4,7.0,https://leetcode.com/problems/max-dot-product-of-two-subsequences,210,12.6K,29K,Microsoft,Dynamic Programming,410,10,98,0,,"class Solution {
public:
    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
        
    }
};","class Solution {
    public int maxDotProduct(int[] nums1, int[] nums2) {
        
    }
}","class Solution(object):
    def maxDotProduct(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        ","

int maxDotProduct(int* nums1, int nums1Size, int* nums2, int nums2Size){

}","public class Solution {
    public int MaxDotProduct(int[] nums1, int[] nums2) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var maxDotProduct = function(nums1, nums2) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer}
def max_dot_product(nums1, nums2)
    
end","class Solution {
    func maxDotProduct(_ nums1: [Int], _ nums2: [Int]) -> Int {
        
    }
}","func maxDotProduct(nums1 []int, nums2 []int) int {
    
}","object Solution {
    def maxDotProduct(nums1: Array[Int], nums2: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxDotProduct(nums1: IntArray, nums2: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_dot_product(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer
     */
    function maxDotProduct($nums1, $nums2) {
        
    }
}","function maxDotProduct(nums1: number[], nums2: number[]): number {

};",,,,,,,,max-dot-product-of-two-subsequences
234,1463,Cherry Pickup II,"Given a `rows x cols` matrix `grid` representing a field of cherries. Each cell in `grid` represents the number of cherries that you can collect.
You have two robots that can collect cherries for you, Robot #1 is located at the top-left corner (0,0) , and Robot #2 is located at the top-right corner (0, cols-1) of the grid.
Return the maximum number of cherries collection using both robots  by following the rules below:
From a cell (i,j), robots can move to cell (i+1, j-1) , (i+1, j) or (i+1, j+1).
When any robot is passing through a cell, It picks it up all cherries, and the cell becomes an empty cell (0).
When both robots stay on the same cell, only one of them takes the cherries.
Both robots cannot move outside of the grid at any moment.
Both robots should reach the bottom row in the `grid`.",0,Hard,/articles/cherry-pickup-ii,68.8,23.5,https://leetcode.com/problems/cherry-pickup-ii,264,26.3K,38.2K,Google,Dynamic Programming,742,9,99,1,,"class Solution {
public:
    int cherryPickup(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int cherryPickup(int[][] grid) {
        
    }
}","class Solution(object):
    def cherryPickup(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        ","int cherryPickup(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int CherryPickup(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var cherryPickup = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def cherry_pickup(grid)
    
end","class Solution {
    func cherryPickup(_ grid: [[Int]]) -> Int {
        
    }
}","func cherryPickup(grid [][]int) int {
    
}","object Solution {
    def cherryPickup(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun cherryPickup(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn cherry_pickup(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function cherryPickup($grid) {
        
    }
}","function cherryPickup(grid: number[][]): number {

};","(define/contract (cherry-pickup grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec cherry_pickup(Grid :: [[integer()]]) -> integer().
cherry_pickup(Grid) ->
  .","defmodule Solution do
  @spec cherry_pickup(grid :: [[integer]]) :: integer
  def cherry_pickup(grid) do

  end
end","class Solution {
  int cherryPickup(List<List<int>> grid) {

  }
}",,,,cherry-pickup-ii
235,1467,Probability of a Two Boxes Having The Same Number of Distinct Balls,"Given `2n` balls of `k` distinct colors. You will be given an integer array `balls` of size `k` where `balls[i]` is the number of balls of color `i`.
All the balls will be shuffled uniformly at random, then we will distribute the first `n` balls to the first box and the remaining `n` balls to the other box (Please read the explanation of the second example carefully).
Please note that the two boxes are considered different. For example, if we have two balls of colors `a` and `b`, and two boxes `[]` and `()`, then the distribution `[a] (b)` is considered different than the distribution `[b] (a) `(Please read the explanation of the first example carefully).
We want to calculate the probability that the two boxes have the same number of distinct balls.",0,Hard,,61.0,14.2,https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,76,5K,8.1K,,,156,119,57,0,,"class Solution {
public:
    double getProbability(vector<int>& balls) {
        
    }
};","class Solution {
    public double getProbability(int[] balls) {
        
    }
}","class Solution(object):
    def getProbability(self, balls):
        """"""
        :type balls: List[int]
        :rtype: float
        """"""
        ","class Solution:
    def getProbability(self, balls: List[int]) -> float:
        ","double getProbability(int* balls, int ballsSize){

}","public class Solution {
    public double GetProbability(int[] balls) {
        
    }
}","/**
 * @param {number[]} balls
 * @return {number}
 */
var getProbability = function(balls) {
    
};","# @param {Integer[]} balls
# @return {Float}
def get_probability(balls)
    
end","class Solution {
    func getProbability(_ balls: [Int]) -> Double {
        
    }
}","func getProbability(balls []int) float64 {
    
}","object Solution {
    def getProbability(balls: Array[Int]): Double = {
        
    }
}","class Solution {
    fun getProbability(balls: IntArray): Double {
        
    }
}","impl Solution {
    pub fn get_probability(balls: Vec<i32>) -> f64 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $balls
     * @return Float
     */
    function getProbability($balls) {
        
    }
}","function getProbability(balls: number[]): number {

};","(define/contract (get-probability balls)
  (-> (listof exact-integer?) flonum?)

  )","-spec get_probability(Balls :: [integer()]) -> float().
get_probability(Balls) ->
  .","defmodule Solution do
  @spec get_probability(balls :: [integer]) :: float
  def get_probability(balls) do

  end
end","class Solution {
  double getProbability(List<int> balls) {

  }
}",,,,probability-of-a-two-boxes-having-the-same-number-of-distinct-balls
236,1473,Paint House III,"There is a row of `m` houses in a small city, each house must be painted with one of the `n` colors (labeled from `1` to `n`), some houses that have been painted last summer should not be painted again.
A neighborhood is a maximal group of continuous houses that are painted with the same color.
For example: `houses = [1,2,2,3,3,2,1,1]` contains `5` neighborhoods `[{1}, {2,2}, {3,3}, {2}, {1,1}]`.
Given an array `houses`, an `m x n` matrix `cost` and an integer `target` where:
`houses[i]`: is the color of the house `i`, and `0` if the house is not painted yet.
`cost[i][j]`: is the cost of paint the house `i` with the color `j + 1`.
Return the minimum cost of painting all the remaining houses in such a way that there are exactly `target` neighborhoods. If it is not possible, return `-1`.",0,Hard,,48.5,18.1,https://leetcode.com/problems/paint-house-iii,164,8.7K,18K,Paypal,Dynamic Programming,335,19,95,0,,"class Solution {
public:
    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {
        
    }
};","class Solution {
    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        
    }
}","class Solution(object):
    def minCost(self, houses, cost, m, n, target):
        """"""
        :type houses: List[int]
        :type cost: List[List[int]]
        :type m: int
        :type n: int
        :type target: int
        :rtype: int
        """"""
        ","class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
        ","int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target){

}","public class Solution {
    public int MinCost(int[] houses, int[][] cost, int m, int n, int target) {
        
    }
}","/**
 * @param {number[]} houses
 * @param {number[][]} cost
 * @param {number} m
 * @param {number} n
 * @param {number} target
 * @return {number}
 */
var minCost = function(houses, cost, m, n, target) {
    
};","# @param {Integer[]} houses
# @param {Integer[][]} cost
# @param {Integer} m
# @param {Integer} n
# @param {Integer} target
# @return {Integer}
def min_cost(houses, cost, m, n, target)
    
end","class Solution {
    func minCost(_ houses: [Int], _ cost: [[Int]], _ m: Int, _ n: Int, _ target: Int) -> Int {
        
    }
}","func minCost(houses []int, cost [][]int, m int, n int, target int) int {
    
}","object Solution {
    def minCost(houses: Array[Int], cost: Array[Array[Int]], m: Int, n: Int, target: Int): Int = {
        
    }
}","class Solution {
    fun minCost(houses: IntArray, cost: Array<IntArray>, m: Int, n: Int, target: Int): Int {
        
    }
}","impl Solution {
    pub fn min_cost(houses: Vec<i32>, cost: Vec<Vec<i32>>, m: i32, n: i32, target: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $houses
     * @param Integer[][] $cost
     * @param Integer $m
     * @param Integer $n
     * @param Integer $target
     * @return Integer
     */
    function minCost($houses, $cost, $m, $n, $target) {
        
    }
}","function minCost(houses: number[], cost: number[][], m: number, n: number, target: number): number {

};","(define/contract (min-cost houses cost m n target)
  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec min_cost(Houses :: [integer()], Cost :: [[integer()]], M :: integer(), N :: integer(), Target :: integer()) -> integer().
min_cost(Houses, Cost, M, N, Target) ->
  .","defmodule Solution do
  @spec min_cost(houses :: [integer], cost :: [[integer]], m :: integer, n :: integer, target :: integer) :: integer
  def min_cost(houses, cost, m, n, target) do

  end
end","class Solution {
  int minCost(List<int> houses, List<List<int>> cost, int m, int n, int target) {

  }
}",,,,paint-house-iii
237,1478,Allocate Mailboxes,"Given the array `houses` and an integer `k`. where `houses[i]` is the location of the ith house along a street, your task is to allocate `k` mailboxes in the street.
Return the minimum total distance between each house and its nearest mailbox.
The answer is guaranteed to fit in a 32-bit signed integer.",0,Hard,,53.8,18.8,https://leetcode.com/problems/allocate-mailboxes,93,8.4K,15.7K,Bloomberg,"Math,Dynamic Programming",428,7,98,0,,"class Solution {
public:
    int minDistance(vector<int>& houses, int k) {
        
    }
};","class Solution {
    public int minDistance(int[] houses, int k) {
        
    }
}","class Solution(object):
    def minDistance(self, houses, k):
        """"""
        :type houses: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minDistance(self, houses: List[int], k: int) -> int:
        ","int minDistance(int* houses, int housesSize, int k){

}","public class Solution {
    public int MinDistance(int[] houses, int k) {
        
    }
}","/**
 * @param {number[]} houses
 * @param {number} k
 * @return {number}
 */
var minDistance = function(houses, k) {
    
};","# @param {Integer[]} houses
# @param {Integer} k
# @return {Integer}
def min_distance(houses, k)
    
end","class Solution {
    func minDistance(_ houses: [Int], _ k: Int) -> Int {
        
    }
}","func minDistance(houses []int, k int) int {
    
}","object Solution {
    def minDistance(houses: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun minDistance(houses: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn min_distance(houses: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $houses
     * @param Integer $k
     * @return Integer
     */
    function minDistance($houses, $k) {
        
    }
}","function minDistance(houses: number[], k: number): number {

};",,,,"class Solution {
  int minDistance(List<int> houses, int k) {

  }
}",,,,allocate-mailboxes
239,1489,Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree,"Given a weighted undirected connected graph with `n` vertices numbered from `0` to `n - 1`, and an array `edges` where `edges[i] = [ai, bi, weighti]` represents a bidirectional and weighted edge between nodes `ai` and `bi`. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.
Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.
Note that you can return the indices of the edges in any order.",0,Hard,,51.5,0.0,https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree,66,4.5K,8.8K,Amazon,"Depth-first Search,Union Find",222,33,87,1,,"class Solution {
public:
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {
        
    }
}","class Solution(object):
    def findCriticalAndPseudoCriticalEdges(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** findCriticalAndPseudoCriticalEdges(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[][]}
 */
var findCriticalAndPseudoCriticalEdges = function(n, edges) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer[][]}
def find_critical_and_pseudo_critical_edges(n, edges)
    
end","class Solution {
    func findCriticalAndPseudoCriticalEdges(_ n: Int, _ edges: [[Int]]) -> [[Int]] {
        
    }
}","func findCriticalAndPseudoCriticalEdges(n int, edges [][]int) [][]int {
    
}","object Solution {
    def findCriticalAndPseudoCriticalEdges(n: Int, edges: Array[Array[Int]]): List[List[Int]] = {
        
    }
}","class Solution {
    fun findCriticalAndPseudoCriticalEdges(n: Int, edges: Array<IntArray>): List<List<Int>> {
        
    }
}","impl Solution {
    pub fn find_critical_and_pseudo_critical_edges(n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @return Integer[][]
     */
    function findCriticalAndPseudoCriticalEdges($n, $edges) {
        
    }
}","function findCriticalAndPseudoCriticalEdges(n: number, edges: number[][]): number[][] {

};","(define/contract (find-critical-and-pseudo-critical-edges n edges)
  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)))

  )","-spec find_critical_and_pseudo_critical_edges(N :: integer(), Edges :: [[integer()]]) -> [[integer()]].
find_critical_and_pseudo_critical_edges(N, Edges) ->
  .","defmodule Solution do
  @spec find_critical_and_pseudo_critical_edges(n :: integer, edges :: [[integer]]) :: [[integer]]
  def find_critical_and_pseudo_critical_edges(n, edges) do

  end
end","class Solution {
  List<List<int>> findCriticalAndPseudoCriticalEdges(int n, List<List<int>> edges) {

  }
}",,,,find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree
240,1494,Parallel Courses II,"Given the integer `n` representing the number of courses at some university labeled from `1` to `n`, and the array `dependencies` where `dependencies[i] = [xi, yi]` represents a prerequisite relationship, that is, the course `xi` must be taken before the course `yi`. Also, you are given the integer `k`.
In one semester you can take at most `k` courses as long as you have taken all the prerequisites for the courses you are taking.
Return the minimum number of semesters to take all courses. It is guaranteed that you can take all courses in some way.",0,Hard,,31.2,9.3,https://leetcode.com/problems/parallel-courses-ii,146,6.5K,20.8K,Microsoft,Graph,353,28,93,0,"[Parallel Courses, /problems/parallel-courses/, Medium]","class Solution {
public:
    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {
        
    }
};","class Solution {
    public int minNumberOfSemesters(int n, int[][] relations, int k) {
        
    }
}","class Solution(object):
    def minNumberOfSemesters(self, n, relations, k):
        """"""
        :type n: int
        :type relations: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:
        ","int minNumberOfSemesters(int n, int** relations, int relationsSize, int* relationsColSize, int k){

}","public class Solution {
    public int MinNumberOfSemesters(int n, int[][] relations, int k) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} relations
 * @param {number} k
 * @return {number}
 */
var minNumberOfSemesters = function(n, relations, k) {
    
};","# @param {Integer} n
# @param {Integer[][]} relations
# @param {Integer} k
# @return {Integer}
def min_number_of_semesters(n, relations, k)
    
end","class Solution {
    func minNumberOfSemesters(_ n: Int, _ relations: [[Int]], _ k: Int) -> Int {
        
    }
}","func minNumberOfSemesters(n int, relations [][]int, k int) int {
    
}","object Solution {
    def minNumberOfSemesters(n: Int, relations: Array[Array[Int]], k: Int): Int = {
        
    }
}","class Solution {
    fun minNumberOfSemesters(n: Int, relations: Array<IntArray>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn min_number_of_semesters(n: i32, relations: Vec<Vec<i32>>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $relations
     * @param Integer $k
     * @return Integer
     */
    function minNumberOfSemesters($n, $relations, $k) {
        
    }
}","function minNumberOfSemesters(n: number, relations: number[][], k: number): number {

};","(define/contract (min-number-of-semesters n relations k)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec min_number_of_semesters(N :: integer(), Relations :: [[integer()]], K :: integer()) -> integer().
min_number_of_semesters(N, Relations, K) ->
  .","defmodule Solution do
  @spec min_number_of_semesters(n :: integer, relations :: [[integer]], k :: integer) :: integer
  def min_number_of_semesters(n, relations, k) do

  end
end","class Solution {
  int minNumberOfSemesters(int n, List<List<int>> relations, int k) {

  }
}",,,,parallel-courses-ii
241,1499,Max Value of Equation,"Given an array `points` containing the coordinates of points on a 2D plane, sorted by the x-values, where `points[i] = [xi, yi]` such that `xi < xj` for all `1 <= i < j <= points.length`. You are also given an integer `k`.
Find the maximum value of the equation `yi + yj + |xi - xj|` where `|xi - xj| <= k` and `1 <= i < j <= points.length`. It is guaranteed that there exists at least one pair of points that satisfy the constraint `|xi - xj| <= k`.",0,Hard,,45.0,26.4,https://leetcode.com/problems/max-value-of-equation,91,11.2K,24.9K,Google,"Array,Sliding Window",349,14,96,1,,"class Solution {
public:
    int findMaxValueOfEquation(vector<vector<int>>& points, int k) {
        
    }
};","class Solution {
    public int findMaxValueOfEquation(int[][] points, int k) {
        
    }
}","class Solution(object):
    def findMaxValueOfEquation(self, points, k):
        """"""
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        ","int findMaxValueOfEquation(int** points, int pointsSize, int* pointsColSize, int k){

}","public class Solution {
    public int FindMaxValueOfEquation(int[][] points, int k) {
        
    }
}","/**
 * @param {number[][]} points
 * @param {number} k
 * @return {number}
 */
var findMaxValueOfEquation = function(points, k) {
    
};","# @param {Integer[][]} points
# @param {Integer} k
# @return {Integer}
def find_max_value_of_equation(points, k)
    
end","class Solution {
    func findMaxValueOfEquation(_ points: [[Int]], _ k: Int) -> Int {
        
    }
}","func findMaxValueOfEquation(points [][]int, k int) int {
    
}","object Solution {
    def findMaxValueOfEquation(points: Array[Array[Int]], k: Int): Int = {
        
    }
}","class Solution {
    fun findMaxValueOfEquation(points: Array<IntArray>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn find_max_value_of_equation(points: Vec<Vec<i32>>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $points
     * @param Integer $k
     * @return Integer
     */
    function findMaxValueOfEquation($points, $k) {
        
    }
}","function findMaxValueOfEquation(points: number[][], k: number): number {

};","(define/contract (find-max-value-of-equation points k)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec find_max_value_of_equation(Points :: [[integer()]], K :: integer()) -> integer().
find_max_value_of_equation(Points, K) ->
  .","defmodule Solution do
  @spec find_max_value_of_equation(points :: [[integer]], k :: integer) :: integer
  def find_max_value_of_equation(points, k) do

  end
end","class Solution {
  int findMaxValueOfEquation(List<List<int>> points, int k) {

  }
}",,,,max-value-of-equation
242,1505,Minimum Possible Integer After at Most K Adjacent Swaps On Digits,"Given a string `num` representing the digits of a very large integer and an integer `k`.
You are allowed to swap any two adjacent digits of the integer at most `k` times.
Return the minimum integer you can obtain also as a string.",0,Hard,,36.4,27.2,https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits,95,5.6K,15.2K,Amazon,Greedy,212,14,94,1,,"class Solution {
public:
    string minInteger(string num, int k) {
        
    }
};","class Solution {
    public String minInteger(String num, int k) {
        
    }
}","class Solution(object):
    def minInteger(self, num, k):
        """"""
        :type num: str
        :type k: int
        :rtype: str
        """"""
        ","class Solution:
    def minInteger(self, num: str, k: int) -> str:
        ","char * minInteger(char * num, int k){

}","public class Solution {
    public string MinInteger(string num, int k) {
        
    }
}","/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var minInteger = function(num, k) {
    
};","# @param {String} num
# @param {Integer} k
# @return {String}
def min_integer(num, k)
    
end","class Solution {
    func minInteger(_ num: String, _ k: Int) -> String {
        
    }
}","func minInteger(num string, k int) string {
    
}","object Solution {
    def minInteger(num: String, k: Int): String = {
        
    }
}","class Solution {
    fun minInteger(num: String, k: Int): String {
        
    }
}","impl Solution {
    pub fn min_integer(num: String, k: i32) -> String {
        
    }
}","class Solution {

    /**
     * @param String $num
     * @param Integer $k
     * @return String
     */
    function minInteger($num, $k) {
        
    }
}","function minInteger(num: string, k: number): string {

};","(define/contract (min-integer num k)
  (-> string? exact-integer? string?)

  )","-spec min_integer(Num :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().
min_integer(Num, K) ->
  .","defmodule Solution do
  @spec min_integer(num :: String.t, k :: integer) :: String.t
  def min_integer(num, k) do

  end
end","class Solution {
  String minInteger(String num, int k) {

  }
}",,,,minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits
243,1510,Stone Game IV,"Alice and Bob take turns playing a game, with Alice starting first.
Initially, there are `n` stones in a pile.  On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.
Also, if a player cannot make a move, he/she loses the game.
Given a positive integer `n`. Return `True` if and only if Alice wins the game otherwise return `False`, assuming both players play optimally.",0,Hard,/articles/stone-game-iv,58.9,2.7,https://leetcode.com/problems/stone-game-iv,245,26.6K,45K,Microsoft,Dynamic Programming,403,25,94,0,"[Stone Game V, /problems/stone-game-v/, Hard], [Stone Game VI, /problems/stone-game-vi/, Medium], [Stone Game VII, /problems/stone-game-vii/, Medium]","class Solution {
public:
    bool winnerSquareGame(int n) {
        
    }
};","class Solution {
    public boolean winnerSquareGame(int n) {
        
    }
}","class Solution(object):
    def winnerSquareGame(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        ","class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        ","bool winnerSquareGame(int n){

}","public class Solution {
    public bool WinnerSquareGame(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {boolean}
 */
var winnerSquareGame = function(n) {
    
};","# @param {Integer} n
# @return {Boolean}
def winner_square_game(n)
    
end","class Solution {
    func winnerSquareGame(_ n: Int) -> Bool {
        
    }
}","func winnerSquareGame(n int) bool {
    
}","object Solution {
    def winnerSquareGame(n: Int): Boolean = {
        
    }
}","class Solution {
    fun winnerSquareGame(n: Int): Boolean {
        
    }
}","impl Solution {
    pub fn winner_square_game(n: i32) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Boolean
     */
    function winnerSquareGame($n) {
        
    }
}","function winnerSquareGame(n: number): boolean {

};",,,,"class Solution {
  bool winnerSquareGame(int n) {

  }
}",,,,stone-game-iv
244,1515,Best Position for a Service Centre,"A delivery company wants to build a new service centre in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new centre in a position such that the sum of the euclidean distances to all customers is minimum.
Given an array `positions` where `positions[i] = [xi, yi]` is the position of the `ith` customer on the map, return the minimum sum of the euclidean distances to all customers.
In other words, you need to choose the position of the service centre `[xcentre, ycentre]` such that the following formula is minimized:
Answers within `10^-5` of the actual value will be accepted.",0,Hard,,38.3,31.8,https://leetcode.com/problems/best-position-for-a-service-centre,96,6.3K,16.4K,"Reddit,Uber",Geometry,109,146,43,0,,"class Solution {
public:
    double getMinDistSum(vector<vector<int>>& positions) {
        
    }
};","class Solution {
    public double getMinDistSum(int[][] positions) {
        
    }
}","class Solution(object):
    def getMinDistSum(self, positions):
        """"""
        :type positions: List[List[int]]
        :rtype: float
        """"""
        ","class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        ","double getMinDistSum(int** positions, int positionsSize, int* positionsColSize){

}","public class Solution {
    public double GetMinDistSum(int[][] positions) {
        
    }
}","/**
 * @param {number[][]} positions
 * @return {number}
 */
var getMinDistSum = function(positions) {
    
};","# @param {Integer[][]} positions
# @return {Float}
def get_min_dist_sum(positions)
    
end","class Solution {
    func getMinDistSum(_ positions: [[Int]]) -> Double {
        
    }
}","func getMinDistSum(positions [][]int) float64 {
    
}","object Solution {
    def getMinDistSum(positions: Array[Array[Int]]): Double = {
        
    }
}","class Solution {
    fun getMinDistSum(positions: Array<IntArray>): Double {
        
    }
}","impl Solution {
    pub fn get_min_dist_sum(positions: Vec<Vec<i32>>) -> f64 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $positions
     * @return Float
     */
    function getMinDistSum($positions) {
        
    }
}","function getMinDistSum(positions: number[][]): number {

};","(define/contract (get-min-dist-sum positions)
  (-> (listof (listof exact-integer?)) flonum?)

  )","-spec get_min_dist_sum(Positions :: [[integer()]]) -> float().
get_min_dist_sum(Positions) ->
  .","defmodule Solution do
  @spec get_min_dist_sum(positions :: [[integer]]) :: float
  def get_min_dist_sum(positions) do

  end
end","class Solution {
  double getMinDistSum(List<List<int>> positions) {

  }
}",,,,best-position-for-a-service-centre
245,1520,Maximum Number of Non-Overlapping Substrings,"Given a string `s` of lowercase letters, you need to find the maximum number of non-empty substrings of `s` that meet the following conditions:
The substrings do not overlap, that is for any two substrings `s[i..j]` and `s[k..l]`, either `j < k` or `i > l` is true.
A substring that contains a certain character `c` must also contain all occurrences of `c`.
Find the maximum number of substrings that meet the above conditions. If there are multiple solutions with the same number of substrings, return the one with minimum total length. It can be shown that there exists a unique solution of minimum total length.
Notice that you can return the substrings in any order.",0,Hard,,36.5,0.0,https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings,90,8.1K,22.3K,Amazon,Greedy,341,46,88,1,,"class Solution {
public:
    vector<string> maxNumOfSubstrings(string s) {
        
    }
};","class Solution {
    public List<String> maxNumOfSubstrings(String s) {
        
    }
}","class Solution(object):
    def maxNumOfSubstrings(self, s):
        """"""
        :type s: str
        :rtype: List[str]
        """"""
        ","class Solution:
    def maxNumOfSubstrings(self, s: str) -> List[str]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** maxNumOfSubstrings(char * s, int* returnSize){

}","public class Solution {
    public IList<string> MaxNumOfSubstrings(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {string[]}
 */
var maxNumOfSubstrings = function(s) {
    
};","# @param {String} s
# @return {String[]}
def max_num_of_substrings(s)
    
end","class Solution {
    func maxNumOfSubstrings(_ s: String) -> [String] {
        
    }
}","func maxNumOfSubstrings(s string) []string {
    
}","object Solution {
    def maxNumOfSubstrings(s: String): List[String] = {
        
    }
}","class Solution {
    fun maxNumOfSubstrings(s: String): List<String> {
        
    }
}","impl Solution {
    pub fn max_num_of_substrings(s: String) -> Vec<String> {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return String[]
     */
    function maxNumOfSubstrings($s) {
        
    }
}","function maxNumOfSubstrings(s: string): string[] {

};","(define/contract (max-num-of-substrings s)
  (-> string? (listof string?))

  )","-spec max_num_of_substrings(S :: unicode:unicode_binary()) -> [unicode:unicode_binary()].
max_num_of_substrings(S) ->
  .","defmodule Solution do
  @spec max_num_of_substrings(s :: String.t) :: [String.t]
  def max_num_of_substrings(s) do

  end
end","class Solution {
  List<String> maxNumOfSubstrings(String s) {

  }
}",,,,maximum-number-of-non-overlapping-substrings
246,1521,Find a Value of a Mysterious Function Closest to Target,"Winston was given the above mysterious function `func`. He has an integer array `arr` and an integer `target` and he wants to find the values `l` and `r` that make the value `|func(arr, l, r) - target|` minimum possible.
Return the minimum possible value of `|func(arr, l, r) - target|`.
Notice that `func` should be called with the values `l` and `r` where `0 <= l, r < arr.length`.",0,Hard,,44.2,0.0,https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target,78,6.1K,13.7K,American Express,"Binary Search,Bit Manipulation,Segment Tree",200,8,96,0,,"class Solution {
public:
    int closestToTarget(vector<int>& arr, int target) {
        
    }
};","class Solution {
    public int closestToTarget(int[] arr, int target) {
        
    }
}","class Solution(object):
    def closestToTarget(self, arr, target):
        """"""
        :type arr: List[int]
        :type target: int
        :rtype: int
        """"""
        ","class Solution:
    def closestToTarget(self, arr: List[int], target: int) -> int:
        ","int closestToTarget(int* arr, int arrSize, int target){

}","public class Solution {
    public int ClosestToTarget(int[] arr, int target) {
        
    }
}","/**
 * @param {number[]} arr
 * @param {number} target
 * @return {number}
 */
var closestToTarget = function(arr, target) {
    
};","# @param {Integer[]} arr
# @param {Integer} target
# @return {Integer}
def closest_to_target(arr, target)
    
end","class Solution {
    func closestToTarget(_ arr: [Int], _ target: Int) -> Int {
        
    }
}","func closestToTarget(arr []int, target int) int {
    
}","object Solution {
    def closestToTarget(arr: Array[Int], target: Int): Int = {
        
    }
}","class Solution {
    fun closestToTarget(arr: IntArray, target: Int): Int {
        
    }
}","impl Solution {
    pub fn closest_to_target(arr: Vec<i32>, target: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $arr
     * @param Integer $target
     * @return Integer
     */
    function closestToTarget($arr, $target) {
        
    }
}","function closestToTarget(arr: number[], target: number): number {

};","(define/contract (closest-to-target arr target)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec closest_to_target(Arr :: [integer()], Target :: integer()) -> integer().
closest_to_target(Arr, Target) ->
  .","defmodule Solution do
  @spec closest_to_target(arr :: [integer], target :: integer) :: integer
  def closest_to_target(arr, target) do

  end
end","class Solution {
  int closestToTarget(List<int> arr, int target) {

  }
}",,,,find-a-value-of-a-mysterious-function-closest-to-target
247,1526,Minimum Number of Increments on Subarrays to Form a Target Array,"Given an array of positive integers `target` and an array `initial` of same size with all zeros.
Return the minimum number of operations to form a `target` array from `initial` if you are allowed to do the following operation:
Choose any subarray from `initial` and increment each value by one.
The answer is guaranteed to fit within the range of a 32-bit signed integer.",0,Hard,,60.3,0.0,https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array,131,7.9K,13.1K,Google,Segment Tree,302,17,95,1,,"class Solution {
public:
    int minNumberOperations(vector<int>& target) {
        
    }
};","class Solution {
    public int minNumberOperations(int[] target) {
        
    }
}","class Solution(object):
    def minNumberOperations(self, target):
        """"""
        :type target: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        ","int minNumberOperations(int* target, int targetSize){

}","public class Solution {
    public int MinNumberOperations(int[] target) {
        
    }
}","/**
 * @param {number[]} target
 * @return {number}
 */
var minNumberOperations = function(target) {
    
};","# @param {Integer[]} target
# @return {Integer}
def min_number_operations(target)
    
end","class Solution {
    func minNumberOperations(_ target: [Int]) -> Int {
        
    }
}","func minNumberOperations(target []int) int {
    
}","object Solution {
    def minNumberOperations(target: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minNumberOperations(target: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_number_operations(target: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $target
     * @return Integer
     */
    function minNumberOperations($target) {
        
    }
}","function minNumberOperations(target: number[]): number {

};","(define/contract (min-number-operations target)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec min_number_operations(Target :: [integer()]) -> integer().
min_number_operations(Target) ->
  .","defmodule Solution do
  @spec min_number_operations(target :: [integer]) :: integer
  def min_number_operations(target) do

  end
end","class Solution {
  int minNumberOperations(List<int> target) {

  }
}",,,,minimum-number-of-increments-on-subarrays-to-form-a-target-array
248,1531,String Compression II,"Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string `""aabccc""` we replace `""aa""` by `""a2""` and replace `""ccc""` by `""c3""`. Thus the compressed string becomes `""a2bc3""`.
Notice that in this problem, we are not adding `'1'` after single characters.
Given a string `s` and an integer `k`. You need to delete at most `k` characters from `s` such that the run-length encoded version of `s` has minimum length.
Find the minimum length of the run-length encoded version of `s` after deleting at most `k` characters.",0,Hard,,34.1,61.4,https://leetcode.com/problems/string-compression-ii,62,6.4K,18.7K,Toptal,"String,Dynamic Programming",286,29,91,0,,"class Solution {
public:
    int getLengthOfOptimalCompression(string s, int k) {
        
    }
};","class Solution {
    public int getLengthOfOptimalCompression(String s, int k) {
        
    }
}","class Solution(object):
    def getLengthOfOptimalCompression(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        ","int getLengthOfOptimalCompression(char * s, int k){

}","public class Solution {
    public int GetLengthOfOptimalCompression(string s, int k) {
        
    }
}","/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var getLengthOfOptimalCompression = function(s, k) {
    
};","# @param {String} s
# @param {Integer} k
# @return {Integer}
def get_length_of_optimal_compression(s, k)
    
end","class Solution {
    func getLengthOfOptimalCompression(_ s: String, _ k: Int) -> Int {
        
    }
}","func getLengthOfOptimalCompression(s string, k int) int {
    
}","object Solution {
    def getLengthOfOptimalCompression(s: String, k: Int): Int = {
        
    }
}","class Solution {
    fun getLengthOfOptimalCompression(s: String, k: Int): Int {
        
    }
}","impl Solution {
    pub fn get_length_of_optimal_compression(s: String, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param Integer $k
     * @return Integer
     */
    function getLengthOfOptimalCompression($s, $k) {
        
    }
}","function getLengthOfOptimalCompression(s: string, k: number): number {

};","(define/contract (get-length-of-optimal-compression s k)
  (-> string? exact-integer? exact-integer?)

  )","-spec get_length_of_optimal_compression(S :: unicode:unicode_binary(), K :: integer()) -> integer().
get_length_of_optimal_compression(S, K) ->
  .","defmodule Solution do
  @spec get_length_of_optimal_compression(s :: String.t, k :: integer) :: integer
  def get_length_of_optimal_compression(s, k) do

  end
end","class Solution {
  int getLengthOfOptimalCompression(String s, int k) {

  }
}",,,,string-compression-ii
249,1537,Get the Maximum Score,"You are given two sorted arrays of distinct integers `nums1` and `nums2.`
A valid path is defined as follows:
Choose array nums1 or nums2 to traverse (from index-0).
Traverse the current array from left to right.
If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).
Score is defined as the sum of uniques values in a valid path.
Return the maximum score you can obtain of all possible valid paths.
Since the answer may be too large, return it modulo 10^9 + 7.",0,Hard,,36.6,5.8,https://leetcode.com/problems/get-the-maximum-score,159,10K,27.2K,MindTickle,Dynamic Programming,324,22,94,0,,"class Solution {
public:
    int maxSum(vector<int>& nums1, vector<int>& nums2) {
        
    }
};","class Solution {
    public int maxSum(int[] nums1, int[] nums2) {
        
    }
}","class Solution(object):
    def maxSum(self, nums1, nums2):
        """"""
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
        ","int maxSum(int* nums1, int nums1Size, int* nums2, int nums2Size){

}","public class Solution {
    public int MaxSum(int[] nums1, int[] nums2) {
        
    }
}","/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var maxSum = function(nums1, nums2) {
    
};","# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer}
def max_sum(nums1, nums2)
    
end","class Solution {
    func maxSum(_ nums1: [Int], _ nums2: [Int]) -> Int {
        
    }
}","func maxSum(nums1 []int, nums2 []int) int {
    
}","object Solution {
    def maxSum(nums1: Array[Int], nums2: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxSum(nums1: IntArray, nums2: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_sum(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer
     */
    function maxSum($nums1, $nums2) {
        
    }
}","function maxSum(nums1: number[], nums2: number[]): number {

};","(define/contract (max-sum nums1 nums2)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec max_sum(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().
max_sum(Nums1, Nums2) ->
  .","defmodule Solution do
  @spec max_sum(nums1 :: [integer], nums2 :: [integer]) :: integer
  def max_sum(nums1, nums2) do

  end
end","class Solution {
  int maxSum(List<int> nums1, List<int> nums2) {

  }
}",,,,get-the-maximum-score
250,1542,Find Longest Awesome Substring,"Given a string `s`. An awesome substring is a non-empty substring of `s` such that we can make any number of swaps in order to make it palindrome.
Return the length of the maximum length awesome substring of `s`.",0,Hard,,36.7,0.0,https://leetcode.com/problems/find-longest-awesome-substring,57,5.6K,15.2K,Directi,"String,Bit Manipulation",317,7,98,0,,"class Solution {
public:
    int longestAwesome(string s) {
        
    }
};","class Solution {
    public int longestAwesome(String s) {
        
    }
}","class Solution(object):
    def longestAwesome(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        ","class Solution:
    def longestAwesome(self, s: str) -> int:
        ","int longestAwesome(char * s){

}","public class Solution {
    public int LongestAwesome(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {number}
 */
var longestAwesome = function(s) {
    
};","# @param {String} s
# @return {Integer}
def longest_awesome(s)
    
end","class Solution {
    func longestAwesome(_ s: String) -> Int {
        
    }
}","func longestAwesome(s string) int {
    
}","object Solution {
    def longestAwesome(s: String): Int = {
        
    }
}","class Solution {
    fun longestAwesome(s: String): Int {
        
    }
}","impl Solution {
    pub fn longest_awesome(s: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function longestAwesome($s) {
        
    }
}","function longestAwesome(s: string): number {

};","(define/contract (longest-awesome s)
  (-> string? exact-integer?)

  )","-spec longest_awesome(S :: unicode:unicode_binary()) -> integer().
longest_awesome(S) ->
  .","defmodule Solution do
  @spec longest_awesome(s :: String.t) :: integer
  def longest_awesome(s) do

  end
end","class Solution {
  int longestAwesome(String s) {

  }
}",,,,find-longest-awesome-substring
251,1547,Minimum Cost to Cut a Stick,"Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length 6 is labelled as follows:
Given an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.
You should perform the cuts in order, you can change the order of the cuts as you wish.
The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.
Return the minimum total cost of the cuts.",0,Hard,,52.9,15.2,https://leetcode.com/problems/minimum-cost-to-cut-a-stick,128,10.7K,20.3K,Google,Dynamic Programming,415,7,98,1,,"class Solution {
public:
    int minCost(int n, vector<int>& cuts) {
        
    }
};","class Solution {
    public int minCost(int n, int[] cuts) {
        
    }
}","class Solution(object):
    def minCost(self, n, cuts):
        """"""
        :type n: int
        :type cuts: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        ","int minCost(int n, int* cuts, int cutsSize){

}","public class Solution {
    public int MinCost(int n, int[] cuts) {
        
    }
}","/**
 * @param {number} n
 * @param {number[]} cuts
 * @return {number}
 */
var minCost = function(n, cuts) {
    
};","# @param {Integer} n
# @param {Integer[]} cuts
# @return {Integer}
def min_cost(n, cuts)
    
end","class Solution {
    func minCost(_ n: Int, _ cuts: [Int]) -> Int {
        
    }
}","func minCost(n int, cuts []int) int {
    
}","object Solution {
    def minCost(n: Int, cuts: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minCost(n: Int, cuts: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_cost(n: i32, cuts: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[] $cuts
     * @return Integer
     */
    function minCost($n, $cuts) {
        
    }
}","function minCost(n: number, cuts: number[]): number {

};",,,,"class Solution {
  int minCost(int n, List<int> cuts) {

  }
}",,,,minimum-cost-to-cut-a-stick
252,1553,Minimum Number of Days to Eat N Oranges,"There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows:
Eat one orange.
If the number of remaining oranges (`n`) is divisible by 2 then you can eat  n/2 oranges.
If the number of remaining oranges (`n`) is divisible by 3 then you can eat  2*(n/3) oranges.
You can only choose one of the actions per day.
Return the minimum number of days to eat `n` oranges.",0,Hard,,29.9,19.1,https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges,163,14.3K,48K,Google,Dynamic Programming,403,32,93,1,,"class Solution {
public:
    int minDays(int n) {
        
    }
};","class Solution {
    public int minDays(int n) {
        
    }
}","class Solution(object):
    def minDays(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def minDays(self, n: int) -> int:
        ","int minDays(int n){

}","public class Solution {
    public int MinDays(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var minDays = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def min_days(n)
    
end","class Solution {
    func minDays(_ n: Int) -> Int {
        
    }
}","func minDays(n int) int {
    
}","object Solution {
    def minDays(n: Int): Int = {
        
    }
}","class Solution {
    fun minDays(n: Int): Int {
        
    }
}","impl Solution {
    pub fn min_days(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function minDays($n) {
        
    }
}","function minDays(n: number): number {

};",,,,"class Solution {
  int minDays(int n) {

  }
}",,,,minimum-number-of-days-to-eat-n-oranges
253,1559,Detect Cycles in 2D Grid,"Given a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the same value in `grid`.
A cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.
Also, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell.
Return `true` if any cycle of the same value exists in `grid`, otherwise, return `false`.",0,Hard,,44.6,6.8,https://leetcode.com/problems/detect-cycles-in-2d-grid,191,9.7K,21.7K,Amazon,Depth-first Search,266,9,97,1,,"class Solution {
public:
    bool containsCycle(vector<vector<char>>& grid) {
        
    }
};","class Solution {
    public boolean containsCycle(char[][] grid) {
        
    }
}","class Solution(object):
    def containsCycle(self, grid):
        """"""
        :type grid: List[List[str]]
        :rtype: bool
        """"""
        ","class Solution:
    def containsCycle(self, grid: List[List[str]]) -> bool:
        ","bool containsCycle(char** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public bool ContainsCycle(char[][] grid) {
        
    }
}","/**
 * @param {character[][]} grid
 * @return {boolean}
 */
var containsCycle = function(grid) {
    
};","# @param {Character[][]} grid
# @return {Boolean}
def contains_cycle(grid)
    
end","class Solution {
    func containsCycle(_ grid: [[Character]]) -> Bool {
        
    }
}","func containsCycle(grid [][]byte) bool {
    
}","object Solution {
    def containsCycle(grid: Array[Array[Char]]): Boolean = {
        
    }
}","class Solution {
    fun containsCycle(grid: Array<CharArray>): Boolean {
        
    }
}","impl Solution {
    pub fn contains_cycle(grid: Vec<Vec<char>>) -> bool {
        
    }
}","class Solution {

    /**
     * @param String[][] $grid
     * @return Boolean
     */
    function containsCycle($grid) {
        
    }
}","function containsCycle(grid: string[][]): boolean {

};","(define/contract (contains-cycle grid)
  (-> (listof (listof char?)) boolean?)

  )","-spec contains_cycle(Grid :: [[char()]]) -> boolean().
contains_cycle(Grid) ->
  .","defmodule Solution do
  @spec contains_cycle(grid :: [[char]]) :: boolean
  def contains_cycle(grid) do

  end
end","class Solution {
  bool containsCycle(List<List<String>> grid) {

  }
}",,,,detect-cycles-in-2d-grid
254,1563,Stone Game V,"There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array `stoneValue`.
In each round of the game, Alice divides the row into two non-empty rows (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.
The game ends when there is only one stone remaining. Alice's is initially zero.
Return the maximum score that Alice can obtain.",0,Hard,,40.0,3.2,https://leetcode.com/problems/stone-game-v,135,8.6K,21.4K,,,203,45,82,0,,"class Solution {
public:
    int stoneGameV(vector<int>& stoneValue) {
        
    }
};","class Solution {
    public int stoneGameV(int[] stoneValue) {
        
    }
}","class Solution(object):
    def stoneGameV(self, stoneValue):
        """"""
        :type stoneValue: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        ","int stoneGameV(int* stoneValue, int stoneValueSize){

}","public class Solution {
    public int StoneGameV(int[] stoneValue) {
        
    }
}","/**
 * @param {number[]} stoneValue
 * @return {number}
 */
var stoneGameV = function(stoneValue) {
    
};","# @param {Integer[]} stone_value
# @return {Integer}
def stone_game_v(stone_value)
    
end","class Solution {
    func stoneGameV(_ stoneValue: [Int]) -> Int {
        
    }
}","func stoneGameV(stoneValue []int) int {
    
}","object Solution {
    def stoneGameV(stoneValue: Array[Int]): Int = {
        
    }
}","class Solution {
    fun stoneGameV(stoneValue: IntArray): Int {
        
    }
}","impl Solution {
    pub fn stone_game_v(stone_value: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $stoneValue
     * @return Integer
     */
    function stoneGameV($stoneValue) {
        
    }
}","function stoneGameV(stoneValue: number[]): number {

};","(define/contract (stone-game-v stoneValue)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec stone_game_v(StoneValue :: [integer()]) -> integer().
stone_game_v(StoneValue) ->
  .","defmodule Solution do
  @spec stone_game_v(stone_value :: [integer]) :: integer
  def stone_game_v(stone_value) do

  end
end","class Solution {
  int stoneGameV(List<int> stoneValue) {

  }
}",,,,stone-game-v
255,1568,Minimum Number of Days to Disconnect Island,"Given a 2D `grid` consisting of `1`s (land) and `0`s (water).  An island is a maximal 4-directionally (horizontal or vertical) connected group of `1`s.
The grid is said to be connected if we have exactly one island, otherwise is said disconnected.
In one day, we are allowed to change any single land cell `(1)` into a water cell `(0)`.
Return the minimum number of days to disconnect the grid.",0,Hard,,50.2,8.5,https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island,86,5.7K,11.4K,Unacademy,Greedy,180,97,65,0,,"class Solution {
public:
    int minDays(vector<vector<int>>& grid) {
        
    }
};","class Solution {
    public int minDays(int[][] grid) {
        
    }
}","class Solution(object):
    def minDays(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minDays(self, grid: List[List[int]]) -> int:
        ","int minDays(int** grid, int gridSize, int* gridColSize){

}","public class Solution {
    public int MinDays(int[][] grid) {
        
    }
}","/**
 * @param {number[][]} grid
 * @return {number}
 */
var minDays = function(grid) {
    
};","# @param {Integer[][]} grid
# @return {Integer}
def min_days(grid)
    
end","class Solution {
    func minDays(_ grid: [[Int]]) -> Int {
        
    }
}","func minDays(grid [][]int) int {
    
}","object Solution {
    def minDays(grid: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minDays(grid: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn min_days(grid: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $grid
     * @return Integer
     */
    function minDays($grid) {
        
    }
}","function minDays(grid: number[][]): number {

};","(define/contract (min-days grid)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec min_days(Grid :: [[integer()]]) -> integer().
min_days(Grid) ->
  .","defmodule Solution do
  @spec min_days(grid :: [[integer]]) :: integer
  def min_days(grid) do

  end
end","class Solution {
  int minDays(List<List<int>> grid) {

  }
}",,,,minimum-number-of-days-to-disconnect-island
256,1569,Number of Ways to Reorder Array to Get Same BST,"Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`.
For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST.
Return the number of ways to reorder `nums` such that the BST formed is identical to the original BST formed from `nums`.
Since the answer may be very large, return it modulo `10^9 + 7`.",0,Hard,,50.0,35.1,https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst,84,5.3K,10.7K,Google,Dynamic Programming,179,25,88,1,,"class Solution {
public:
    int numOfWays(vector<int>& nums) {
        
    }
};","class Solution {
    public int numOfWays(int[] nums) {
        
    }
}","class Solution(object):
    def numOfWays(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        ","int numOfWays(int* nums, int numsSize){

}","public class Solution {
    public int NumOfWays(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var numOfWays = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def num_of_ways(nums)
    
end","class Solution {
    func numOfWays(_ nums: [Int]) -> Int {
        
    }
}","func numOfWays(nums []int) int {
    
}","object Solution {
    def numOfWays(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun numOfWays(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn num_of_ways(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function numOfWays($nums) {
        
    }
}","function numOfWays(nums: number[]): number {

};","(define/contract (num-of-ways nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec num_of_ways(Nums :: [integer()]) -> integer().
num_of_ways(Nums) ->
  .","defmodule Solution do
  @spec num_of_ways(nums :: [integer]) :: integer
  def num_of_ways(nums) do

  end
end","class Solution {
  int numOfWays(List<int> nums) {

  }
}",,,,number-of-ways-to-reorder-array-to-get-same-bst
257,1575,Count All Possible Routes,"You are given an array of distinct positive integers locations where `locations[i]` represents the position of city `i`. You are also given integers `start`, `finish` and `fuel` representing the starting city, ending city, and the initial amount of fuel you have, respectively.
At each step, if you are at city `i`, you can pick any city `j` such that `j != i` and `0 <= j < locations.length` and move to city `j`. Moving from city `i` to city `j` reduces the amount of fuel you have by `|locations[i] - locations[j]|`. Please notice that `|x|` denotes the absolute value of `x`.
Notice that `fuel` cannot become negative at any point in time, and that you are allowed to visit any city more than once (including `start` and `finish`).
Return the count of all possible routes from `start` to `finish`.
Since the answer may be too large, return it modulo `10^9 + 7`.",0,Hard,,57.1,10.1,https://leetcode.com/problems/count-all-possible-routes,99,6.4K,11.2K,TSYS,Dynamic Programming,214,10,96,0,,"class Solution {
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {
        
    }
};","class Solution {
    public int countRoutes(int[] locations, int start, int finish, int fuel) {
        
    }
}","class Solution(object):
    def countRoutes(self, locations, start, finish, fuel):
        """"""
        :type locations: List[int]
        :type start: int
        :type finish: int
        :type fuel: int
        :rtype: int
        """"""
        ","class Solution:
    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
        ","int countRoutes(int* locations, int locationsSize, int start, int finish, int fuel){

}","public class Solution {
    public int CountRoutes(int[] locations, int start, int finish, int fuel) {
        
    }
}","/**
 * @param {number[]} locations
 * @param {number} start
 * @param {number} finish
 * @param {number} fuel
 * @return {number}
 */
var countRoutes = function(locations, start, finish, fuel) {
    
};","# @param {Integer[]} locations
# @param {Integer} start
# @param {Integer} finish
# @param {Integer} fuel
# @return {Integer}
def count_routes(locations, start, finish, fuel)
    
end","class Solution {
    func countRoutes(_ locations: [Int], _ start: Int, _ finish: Int, _ fuel: Int) -> Int {
        
    }
}","func countRoutes(locations []int, start int, finish int, fuel int) int {
    
}","object Solution {
    def countRoutes(locations: Array[Int], start: Int, finish: Int, fuel: Int): Int = {
        
    }
}","class Solution {
    fun countRoutes(locations: IntArray, start: Int, finish: Int, fuel: Int): Int {
        
    }
}","impl Solution {
    pub fn count_routes(locations: Vec<i32>, start: i32, finish: i32, fuel: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $locations
     * @param Integer $start
     * @param Integer $finish
     * @param Integer $fuel
     * @return Integer
     */
    function countRoutes($locations, $start, $finish, $fuel) {
        
    }
}","function countRoutes(locations: number[], start: number, finish: number, fuel: number): number {

};","(define/contract (count-routes locations start finish fuel)
  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec count_routes(Locations :: [integer()], Start :: integer(), Finish :: integer(), Fuel :: integer()) -> integer().
count_routes(Locations, Start, Finish, Fuel) ->
  .","defmodule Solution do
  @spec count_routes(locations :: [integer], start :: integer, finish :: integer, fuel :: integer) :: integer
  def count_routes(locations, start, finish, fuel) do

  end
end","class Solution {
  int countRoutes(List<int> locations, int start, int finish, int fuel) {

  }
}",,,,count-all-possible-routes
258,1579,Remove Max Number of Edges to Keep Graph Fully Traversable,"Alice and Bob have an undirected graph of `n` nodes and 3 types of edges:
Type 1: Can be traversed by Alice only.
Type 2: Can be traversed by Bob only.
Type 3: Can by traversed by both Alice and Bob.
Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.
Return the maximum number of edges you can remove, or return `-1` if it's impossible for the graph to be fully traversed by Alice and Bob.",0,Hard,,46.3,5.3,https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable,124,6.7K,14.4K,Uber,Union Find,307,3,99,0,,"class Solution {
public:
    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int maxNumEdgesToRemove(int n, int[][] edges) {
        
    }
}","class Solution(object):
    def maxNumEdgesToRemove(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
        ","int maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize){

}","public class Solution {
    public int MaxNumEdgesToRemove(int n, int[][] edges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number}
 */
var maxNumEdgesToRemove = function(n, edges) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer}
def max_num_edges_to_remove(n, edges)
    
end","class Solution {
    func maxNumEdgesToRemove(_ n: Int, _ edges: [[Int]]) -> Int {
        
    }
}","func maxNumEdgesToRemove(n int, edges [][]int) int {
    
}","object Solution {
    def maxNumEdgesToRemove(n: Int, edges: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun maxNumEdgesToRemove(n: Int, edges: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn max_num_edges_to_remove(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @return Integer
     */
    function maxNumEdgesToRemove($n, $edges) {
        
    }
}","function maxNumEdgesToRemove(n: number, edges: number[][]): number {

};","(define/contract (max-num-edges-to-remove n edges)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec max_num_edges_to_remove(N :: integer(), Edges :: [[integer()]]) -> integer().
max_num_edges_to_remove(N, Edges) ->
  .","defmodule Solution do
  @spec max_num_edges_to_remove(n :: integer, edges :: [[integer]]) :: integer
  def max_num_edges_to_remove(n, edges) do

  end
end","class Solution {
  int maxNumEdgesToRemove(int n, List<List<int>> edges) {

  }
}",,,,remove-max-number-of-edges-to-keep-graph-fully-traversable
259,1585,Check If String Is Transformable With Substring Sort Operations,"Given two strings `s` and `t`, you want to transform string `s` into string `t` using the following operation any number of times:
Choose a non-empty substring in `s` and sort it in-place so the characters are in ascending order.
For example, applying the operation on the underlined substring in `""14234""` results in `""12344""`.
Return `true` if it is possible to transform string `s` into string `t`. Otherwise, return `false`.
A substring is a contiguous sequence of characters within a string.",0,Hard,,48.5,0.0,https://leetcode.com/problems/check-if-string-is-transformable-with-substring-sort-operations,60,4.7K,9.7K,Google,"String,Greedy",233,4,98,1,,"class Solution {
public:
    bool isTransformable(string s, string t) {
        
    }
};","class Solution {
    public boolean isTransformable(String s, String t) {
        
    }
}","class Solution(object):
    def isTransformable(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: bool
        """"""
        ","class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        ","bool isTransformable(char * s, char * t){

}","public class Solution {
    public bool IsTransformable(string s, string t) {
        
    }
}","/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isTransformable = function(s, t) {
    
};","# @param {String} s
# @param {String} t
# @return {Boolean}
def is_transformable(s, t)
    
end","class Solution {
    func isTransformable(_ s: String, _ t: String) -> Bool {
        
    }
}","func isTransformable(s string, t string) bool {
    
}","object Solution {
    def isTransformable(s: String, t: String): Boolean = {
        
    }
}","class Solution {
    fun isTransformable(s: String, t: String): Boolean {
        
    }
}","impl Solution {
    pub fn is_transformable(s: String, t: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @param String $t
     * @return Boolean
     */
    function isTransformable($s, $t) {
        
    }
}","function isTransformable(s: string, t: string): boolean {

};","(define/contract (is-transformable s t)
  (-> string? string? boolean?)

  )","-spec is_transformable(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> boolean().
is_transformable(S, T) ->
  .","defmodule Solution do
  @spec is_transformable(s :: String.t, t :: String.t) :: boolean
  def is_transformable(s, t) do

  end
end","class Solution {
  bool isTransformable(String s, String t) {

  }
}",,,,check-if-string-is-transformable-with-substring-sort-operations
260,1591,Strange Printer II,"There is a strange printer with the following two special requirements:
On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.
Once the printer has used a color for the above operation, the same color cannot be used again.
You are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is the color in the position `(row, col)` of the grid.
Return `true` if it is possible to print the matrix `targetGrid`, otherwise, return `false`.",0,Hard,,55.3,0.0,https://leetcode.com/problems/strange-printer-ii,46,3.4K,6.2K,Google,Greedy,179,5,97,1,"[Strange Printer, /problems/strange-printer/, Hard]","class Solution {
public:
    bool isPrintable(vector<vector<int>>& targetGrid) {
        
    }
};","class Solution {
    public boolean isPrintable(int[][] targetGrid) {
        
    }
}","class Solution(object):
    def isPrintable(self, targetGrid):
        """"""
        :type targetGrid: List[List[int]]
        :rtype: bool
        """"""
        ","class Solution:
    def isPrintable(self, targetGrid: List[List[int]]) -> bool:
        ","bool isPrintable(int** targetGrid, int targetGridSize, int* targetGridColSize){

}","public class Solution {
    public bool IsPrintable(int[][] targetGrid) {
        
    }
}","/**
 * @param {number[][]} targetGrid
 * @return {boolean}
 */
var isPrintable = function(targetGrid) {
    
};","# @param {Integer[][]} target_grid
# @return {Boolean}
def is_printable(target_grid)
    
end","class Solution {
    func isPrintable(_ targetGrid: [[Int]]) -> Bool {
        
    }
}","func isPrintable(targetGrid [][]int) bool {
    
}","object Solution {
    def isPrintable(targetGrid: Array[Array[Int]]): Boolean = {
        
    }
}","class Solution {
    fun isPrintable(targetGrid: Array<IntArray>): Boolean {
        
    }
}","impl Solution {
    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $targetGrid
     * @return Boolean
     */
    function isPrintable($targetGrid) {
        
    }
}","function isPrintable(targetGrid: number[][]): boolean {

};","(define/contract (is-printable targetGrid)
  (-> (listof (listof exact-integer?)) boolean?)

  )","-spec is_printable(TargetGrid :: [[integer()]]) -> boolean().
is_printable(TargetGrid) ->
  .","defmodule Solution do
  @spec is_printable(target_grid :: [[integer]]) :: boolean
  def is_printable(target_grid) do

  end
end","class Solution {
  bool isPrintable(List<List<int>> targetGrid) {

  }
}",,,,strange-printer-ii
261,1595,Minimum Cost to Connect Two Groups of Points,"You are given two groups of points where the first group has `size1` points, the second group has `size2` points, and `size1 >= size2`.
The `cost` of the connection between any two points are given in an `size1 x size2` matrix where `cost[i][j]` is the cost of connecting point `i` of the first group and point `j` of the second group. The groups are connected if each point in both groups is connected to one or more points in the opposite group. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.
Return the minimum cost it takes to connect the two groups.",0,Hard,,43.6,11.9,https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points,59,4.4K,10.1K,Google,"Dynamic Programming,Graph",207,9,96,1,,"class Solution {
public:
    int connectTwoGroups(vector<vector<int>>& cost) {
        
    }
};","class Solution {
    public int connectTwoGroups(List<List<Integer>> cost) {
        
    }
}","class Solution(object):
    def connectTwoGroups(self, cost):
        """"""
        :type cost: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        ","int connectTwoGroups(int** cost, int costSize, int* costColSize){

}","public class Solution {
    public int ConnectTwoGroups(IList<IList<int>> cost) {
        
    }
}","/**
 * @param {number[][]} cost
 * @return {number}
 */
var connectTwoGroups = function(cost) {
    
};","# @param {Integer[][]} cost
# @return {Integer}
def connect_two_groups(cost)
    
end","class Solution {
    func connectTwoGroups(_ cost: [[Int]]) -> Int {
        
    }
}","func connectTwoGroups(cost [][]int) int {
    
}","object Solution {
    def connectTwoGroups(cost: List[List[Int]]): Int = {
        
    }
}","class Solution {
    fun connectTwoGroups(cost: List<List<Int>>): Int {
        
    }
}","impl Solution {
    pub fn connect_two_groups(cost: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $cost
     * @return Integer
     */
    function connectTwoGroups($cost) {
        
    }
}","function connectTwoGroups(cost: number[][]): number {

};","(define/contract (connect-two-groups cost)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec connect_two_groups(Cost :: [[integer()]]) -> integer().
connect_two_groups(Cost) ->
  .","defmodule Solution do
  @spec connect_two_groups(cost :: [[integer]]) :: integer
  def connect_two_groups(cost) do

  end
end","class Solution {
  int connectTwoGroups(List<List<int>> cost) {

  }
}",,,,minimum-cost-to-connect-two-groups-of-points
262,1601,Maximum Number of Achievable Transfer Requests,"We have `n` buildings numbered from `0` to `n - 1`. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.
You are given an array `requests` where `requests[i] = [fromi, toi]` represents an employee's request to transfer from building `fromi` to building `toi`.
All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if `n = 3` and two employees are leaving building `0`, one is leaving building `1`, and one is leaving building `2`, there should be two employees moving to building `0`, one employee moving to building `1`, and one employee moving to building `2`.
Return the maximum number of achievable requests.",0,Hard,,47.8,0.0,https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests,82,5.6K,11.8K,Amazon,Dynamic Programming,172,21,89,1,,"class Solution {
public:
    int maximumRequests(int n, vector<vector<int>>& requests) {
        
    }
};","class Solution {
    public int maximumRequests(int n, int[][] requests) {
        
    }
}","class Solution(object):
    def maximumRequests(self, n, requests):
        """"""
        :type n: int
        :type requests: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        ","int maximumRequests(int n, int** requests, int requestsSize, int* requestsColSize){

}","public class Solution {
    public int MaximumRequests(int n, int[][] requests) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} requests
 * @return {number}
 */
var maximumRequests = function(n, requests) {
    
};","# @param {Integer} n
# @param {Integer[][]} requests
# @return {Integer}
def maximum_requests(n, requests)
    
end","class Solution {
    func maximumRequests(_ n: Int, _ requests: [[Int]]) -> Int {
        
    }
}","func maximumRequests(n int, requests [][]int) int {
    
}","object Solution {
    def maximumRequests(n: Int, requests: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun maximumRequests(n: Int, requests: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn maximum_requests(n: i32, requests: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $requests
     * @return Integer
     */
    function maximumRequests($n, $requests) {
        
    }
}","function maximumRequests(n: number, requests: number[][]): number {

};","(define/contract (maximum-requests n requests)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec maximum_requests(N :: integer(), Requests :: [[integer()]]) -> integer().
maximum_requests(N, Requests) ->
  .","defmodule Solution do
  @spec maximum_requests(n :: integer, requests :: [[integer]]) :: integer
  def maximum_requests(n, requests) do

  end
end","class Solution {
  int maximumRequests(int n, List<List<int>> requests) {

  }
}",,,,maximum-number-of-achievable-transfer-requests
263,1606,Find Servers That Handled Most Number of Requests,"You have `k` servers numbered from `0` to `k-1` that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm:
The `ith` (0-indexed) request arrives.
If all servers are busy, the request is dropped (not handled at all).
If the `(i % k)th` server is available, assign the request to that server.
Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the `ith` server is busy, try to assign the request to the `(i+1)th` server, then the `(i+2)th` server, and so on.
You are given a strictly increasing array `arrival` of positive integers, where `arrival[i]` represents the arrival time of the `ith` request, and another array `load`, where `load[i]` represents the load of the `ith` request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers.
Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.",0,Hard,,37.4,28.8,https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests,72,3.9K,10.5K,Wish,Ordered Map,191,7,96,0,,"class Solution {
public:
    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {
        
    }
};","class Solution {
    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {
        
    }
}","class Solution(object):
    def busiestServers(self, k, arrival, load):
        """"""
        :type k: int
        :type arrival: List[int]
        :type load: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* busiestServers(int k, int* arrival, int arrivalSize, int* load, int loadSize, int* returnSize){

}","public class Solution {
    public IList<int> BusiestServers(int k, int[] arrival, int[] load) {
        
    }
}","/**
 * @param {number} k
 * @param {number[]} arrival
 * @param {number[]} load
 * @return {number[]}
 */
var busiestServers = function(k, arrival, load) {
    
};","# @param {Integer} k
# @param {Integer[]} arrival
# @param {Integer[]} load
# @return {Integer[]}
def busiest_servers(k, arrival, load)
    
end","class Solution {
    func busiestServers(_ k: Int, _ arrival: [Int], _ load: [Int]) -> [Int] {
        
    }
}","func busiestServers(k int, arrival []int, load []int) []int {
    
}","object Solution {
    def busiestServers(k: Int, arrival: Array[Int], load: Array[Int]): List[Int] = {
        
    }
}","class Solution {
    fun busiestServers(k: Int, arrival: IntArray, load: IntArray): List<Int> {
        
    }
}","impl Solution {
    pub fn busiest_servers(k: i32, arrival: Vec<i32>, load: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $k
     * @param Integer[] $arrival
     * @param Integer[] $load
     * @return Integer[]
     */
    function busiestServers($k, $arrival, $load) {
        
    }
}","function busiestServers(k: number, arrival: number[], load: number[]): number[] {

};","(define/contract (busiest-servers k arrival load)
  (-> exact-integer? (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))

  )","-spec busiest_servers(K :: integer(), Arrival :: [integer()], Load :: [integer()]) -> [integer()].
busiest_servers(K, Arrival, Load) ->
  .","defmodule Solution do
  @spec busiest_servers(k :: integer, arrival :: [integer], load :: [integer]) :: [integer]
  def busiest_servers(k, arrival, load) do

  end
end","class Solution {
  List<int> busiestServers(int k, List<int> arrival, List<int> load) {

  }
}",,,,find-servers-that-handled-most-number-of-requests
264,1610,Maximum Number of Visible Points,"You are given an array `points`, an integer `angle`, and your `location`, where `location = [posx, posy]` and `points[i] = [xi, yi]` both denote integral coordinates on the X-Y plane.
Initially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, `posx` and `posy` cannot be changed. Your field of view in degrees is represented by `angle`, determining how wide you can see from any given view direction. Let `d` be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles `[d - angle/2, d + angle/2]`.
Your browser does not support the video tag or this video format.
You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view.
There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.
Return the maximum number of points you can see.",0,Hard,,30.4,37.6,https://leetcode.com/problems/maximum-number-of-visible-points,78,7.4K,24.4K,"Google,Amazon","Two Pointers,Geometry",148,223,40,1,,"class Solution {
public:
    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {
        
    }
};","class Solution {
    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {
        
    }
}","class Solution(object):
    def visiblePoints(self, points, angle, location):
        """"""
        :type points: List[List[int]]
        :type angle: int
        :type location: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:
        ","int visiblePoints(int** points, int pointsSize, int* pointsColSize, int angle, int* location, int locationSize){

}","public class Solution {
    public int VisiblePoints(IList<IList<int>> points, int angle, IList<int> location) {
        
    }
}","/**
 * @param {number[][]} points
 * @param {number} angle
 * @param {number[]} location
 * @return {number}
 */
var visiblePoints = function(points, angle, location) {
    
};","# @param {Integer[][]} points
# @param {Integer} angle
# @param {Integer[]} location
# @return {Integer}
def visible_points(points, angle, location)
    
end","class Solution {
    func visiblePoints(_ points: [[Int]], _ angle: Int, _ location: [Int]) -> Int {
        
    }
}","func visiblePoints(points [][]int, angle int, location []int) int {
    
}","object Solution {
    def visiblePoints(points: List[List[Int]], angle: Int, location: List[Int]): Int = {
        
    }
}","class Solution {
    fun visiblePoints(points: List<List<Int>>, angle: Int, location: List<Int>): Int {
        
    }
}","impl Solution {
    pub fn visible_points(points: Vec<Vec<i32>>, angle: i32, location: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $points
     * @param Integer $angle
     * @param Integer[] $location
     * @return Integer
     */
    function visiblePoints($points, $angle, $location) {
        
    }
}","function visiblePoints(points: number[][], angle: number, location: number[]): number {

};","(define/contract (visible-points points angle location)
  (-> (listof (listof exact-integer?)) exact-integer? (listof exact-integer?) exact-integer?)

  )","-spec visible_points(Points :: [[integer()]], Angle :: integer(), Location :: [integer()]) -> integer().
visible_points(Points, Angle, Location) ->
  .","defmodule Solution do
  @spec visible_points(points :: [[integer]], angle :: integer, location :: [integer]) :: integer
  def visible_points(points, angle, location) do

  end
end","class Solution {
  int visiblePoints(List<List<int>> points, int angle, List<int> location) {

  }
}",,,,maximum-number-of-visible-points
265,1611,Minimum One Bit Operations to Make Integers Zero,"Given an integer `n`, you must transform it into `0` using the following operations any number of times:
Change the rightmost (`0th`) bit in the binary representation of `n`.
Change the `ith` bit in the binary representation of `n` if the `(i-1)th` bit is set to `1` and the `(i-2)th` through `0th` bits are set to `0`.
Return the minimum number of operations to transform `n` into `0`.",0,Hard,,57.7,39.8,https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero,75,3.8K,6.6K,Expedia,"Dynamic Programming,Bit Manipulation",144,100,59,0,,"class Solution {
public:
    int minimumOneBitOperations(int n) {
        
    }
};","class Solution {
    public int minimumOneBitOperations(int n) {
        
    }
}","class Solution(object):
    def minimumOneBitOperations(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        ","int minimumOneBitOperations(int n){

}","public class Solution {
    public int MinimumOneBitOperations(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var minimumOneBitOperations = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def minimum_one_bit_operations(n)
    
end","class Solution {
    func minimumOneBitOperations(_ n: Int) -> Int {
        
    }
}","func minimumOneBitOperations(n int) int {
    
}","object Solution {
    def minimumOneBitOperations(n: Int): Int = {
        
    }
}","class Solution {
    fun minimumOneBitOperations(n: Int): Int {
        
    }
}","impl Solution {
    pub fn minimum_one_bit_operations(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function minimumOneBitOperations($n) {
        
    }
}","function minimumOneBitOperations(n: number): number {

};","(define/contract (minimum-one-bit-operations n)
  (-> exact-integer? exact-integer?)

  )","-spec minimum_one_bit_operations(N :: integer()) -> integer().
minimum_one_bit_operations(N) ->
  .","defmodule Solution do
  @spec minimum_one_bit_operations(n :: integer) :: integer
  def minimum_one_bit_operations(n) do

  end
end","class Solution {
  int minimumOneBitOperations(int n) {

  }
}",,,,minimum-one-bit-operations-to-make-integers-zero
266,1617,Count Subtrees With Max Distance Between Cities,"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a tree.
A subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.
For each `d` from `1` to `n-1`, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to `d`.
Return an array of size `n-1` where the `dth` element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to `d`.
Notice that the distance between the two cities is the number of edges in the path between them.",0,Hard,,63.2,0.0,https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities,84,4.3K,6.8K,Codenation,Backtracking,156,23,87,0,"[Tree Diameter, /problems/tree-diameter/, Medium]","class Solution {
public:
    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {
        
    }
}","class Solution(object):
    def countSubgraphsForEachDiameter(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        ","

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* countSubgraphsForEachDiameter(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){

}","public class Solution {
    public int[] CountSubgraphsForEachDiameter(int n, int[][] edges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
var countSubgraphsForEachDiameter = function(n, edges) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer[]}
def count_subgraphs_for_each_diameter(n, edges)
    
end","class Solution {
    func countSubgraphsForEachDiameter(_ n: Int, _ edges: [[Int]]) -> [Int] {
        
    }
}","func countSubgraphsForEachDiameter(n int, edges [][]int) []int {
    
}","object Solution {
    def countSubgraphsForEachDiameter(n: Int, edges: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun countSubgraphsForEachDiameter(n: Int, edges: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn count_subgraphs_for_each_diameter(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @return Integer[]
     */
    function countSubgraphsForEachDiameter($n, $edges) {
        
    }
}","function countSubgraphsForEachDiameter(n: number, edges: number[][]): number[] {

};",,,,,,,,count-subtrees-with-max-distance-between-cities
268,1627,Graph Connectivity With Threshold,"We have `n` cities labeled from `1` to `n`. Two different cities with labels `x` and `y` are directly connected by a bidirectional road if and only if `x` and `y` share a common divisor strictly greater than some `threshold`. More formally, cities with labels `x` and `y` have a road between them if there exists an integer `z` such that all of the following are true:
`x % z == 0`,
`y % z == 0`, and
`z > threshold`.
Given the two integers, `n` and `threshold`, and an array of `queries`, you must determine for each `queries[i] = [ai, bi]` if cities `ai` and `bi` are connected directly or indirectly. (i.e. there is some path between them).
Return an array `answer`, where `answer.length == queries.length` and `answer[i]` is `true` if for the `ith` query, there is a path between `ai` and `bi`, or `answer[i]` is `false` if there is no path.",0,Hard,,40.2,16.2,https://leetcode.com/problems/graph-connectivity-with-threshold,92,6.1K,15.1K,Trexquant,"Math,Union Find",163,20,89,0,,"class Solution {
public:
    vector<bool> areConnected(int n, int threshold, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public List<Boolean> areConnected(int n, int threshold, int[][] queries) {
        
    }
}","class Solution(object):
    def areConnected(self, n, threshold, queries):
        """"""
        :type n: int
        :type threshold: int
        :type queries: List[List[int]]
        :rtype: List[bool]
        """"""
        ","class Solution:
    def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
bool* areConnected(int n, int threshold, int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public IList<bool> AreConnected(int n, int threshold, int[][] queries) {
        
    }
}","/**
 * @param {number} n
 * @param {number} threshold
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var areConnected = function(n, threshold, queries) {
    
};","# @param {Integer} n
# @param {Integer} threshold
# @param {Integer[][]} queries
# @return {Boolean[]}
def are_connected(n, threshold, queries)
    
end","class Solution {
    func areConnected(_ n: Int, _ threshold: Int, _ queries: [[Int]]) -> [Bool] {
        
    }
}","func areConnected(n int, threshold int, queries [][]int) []bool {
    
}","object Solution {
    def areConnected(n: Int, threshold: Int, queries: Array[Array[Int]]): List[Boolean] = {
        
    }
}","class Solution {
    fun areConnected(n: Int, threshold: Int, queries: Array<IntArray>): List<Boolean> {
        
    }
}","impl Solution {
    pub fn are_connected(n: i32, threshold: i32, queries: Vec<Vec<i32>>) -> Vec<bool> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer $threshold
     * @param Integer[][] $queries
     * @return Boolean[]
     */
    function areConnected($n, $threshold, $queries) {
        
    }
}","function areConnected(n: number, threshold: number, queries: number[][]): boolean[] {

};","(define/contract (are-connected n threshold queries)
  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) (listof boolean?))

  )","-spec are_connected(N :: integer(), Threshold :: integer(), Queries :: [[integer()]]) -> [boolean()].
are_connected(N, Threshold, Queries) ->
  .","defmodule Solution do
  @spec are_connected(n :: integer, threshold :: integer, queries :: [[integer]]) :: [boolean]
  def are_connected(n, threshold, queries) do

  end
end","class Solution {
  List<bool> areConnected(int n, int threshold, List<List<int>> queries) {

  }
}",,,,graph-connectivity-with-threshold
269,1632,Rank Transform of a Matrix,"Given an `m x n` `matrix`, return a new matrix `answer` where `answer[row][col]` is the rank of `matrix[row][col]`.
The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:
The rank is an integer starting from `1`.
If two elements `p` and `q` are in the same row or column, then:
If `p < q` then `rank(p) < rank(q)`
If `p == q` then `rank(p) == rank(q)`
If `p > q` then `rank(p) > rank(q)`
The rank should be as small as possible.
It is guaranteed that `answer` is unique under the given rules.",0,Hard,/articles/rank-transform-of-a-matrix,31.9,5.8,https://leetcode.com/problems/rank-transform-of-a-matrix,45,3.6K,11.1K,Google,"Greedy,Union Find",193,6,97,1,"[Rank Transform of an Array, /problems/rank-transform-of-an-array/, Easy]","class Solution {
public:
    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {
        
    }
};","class Solution {
    public int[][] matrixRankTransform(int[][] matrix) {
        
    }
}","class Solution(object):
    def matrixRankTransform(self, matrix):
        """"""
        :type matrix: List[List[int]]
        :rtype: List[List[int]]
        """"""
        ","class Solution:
    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
        ","/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** matrixRankTransform(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){

}","public class Solution {
    public int[][] MatrixRankTransform(int[][] matrix) {
        
    }
}","/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var matrixRankTransform = function(matrix) {
    
};","# @param {Integer[][]} matrix
# @return {Integer[][]}
def matrix_rank_transform(matrix)
    
end","class Solution {
    func matrixRankTransform(_ matrix: [[Int]]) -> [[Int]] {
        
    }
}","func matrixRankTransform(matrix [][]int) [][]int {
    
}","object Solution {
    def matrixRankTransform(matrix: Array[Array[Int]]): Array[Array[Int]] = {
        
    }
}","class Solution {
    fun matrixRankTransform(matrix: Array<IntArray>): Array<IntArray> {
        
    }
}","impl Solution {
    pub fn matrix_rank_transform(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $matrix
     * @return Integer[][]
     */
    function matrixRankTransform($matrix) {
        
    }
}","function matrixRankTransform(matrix: number[][]): number[][] {

};","(define/contract (matrix-rank-transform matrix)
  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))

  )","-spec matrix_rank_transform(Matrix :: [[integer()]]) -> [[integer()]].
matrix_rank_transform(Matrix) ->
  .","defmodule Solution do
  @spec matrix_rank_transform(matrix :: [[integer]]) :: [[integer]]
  def matrix_rank_transform(matrix) do

  end
end","class Solution {
  List<List<int>> matrixRankTransform(List<List<int>> matrix) {

  }
}",,,,rank-transform-of-a-matrix
270,1639,Number of Ways to Form a Target String Given a Dictionary,"You are given a list of strings of the same length `words` and a string `target`.
Your task is to form `target` using the given `words` under the following rules:
`target` should be formed from left to right.
To form the `ith` character (0-indexed) of `target`, you can choose the `kth` character of the `jth` string in `words` if `target[i] = words[j][k]`.
Once you use the `kth` character of the `jth` string of `words`, you can no longer use the `xth` character of any string in `words` where `x <= k`. In other words, all characters to the left of or at index `k` become unusuable for every string.
Repeat the process until you form the string `target`.
Notice that you can use multiple characters from the same string in `words` provided the conditions above are met.
Return the number of ways to form `target` from `words`. Since the answer may be too large, return it modulo `109 + 7`.",0,Hard,,40.0,7.2,https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary,61,3.9K,9.7K,Dunzo,Dynamic Programming,129,7,95,0,,"class Solution {
public:
    int numWays(vector<string>& words, string target) {
        
    }
};","class Solution {
    public int numWays(String[] words, String target) {
        
    }
}","class Solution(object):
    def numWays(self, words, target):
        """"""
        :type words: List[str]
        :type target: str
        :rtype: int
        """"""
        ","class Solution:
    def numWays(self, words: List[str], target: str) -> int:
        ","int numWays(char ** words, int wordsSize, char * target){

}","public class Solution {
    public int NumWays(string[] words, string target) {
        
    }
}","/**
 * @param {string[]} words
 * @param {string} target
 * @return {number}
 */
var numWays = function(words, target) {
    
};","# @param {String[]} words
# @param {String} target
# @return {Integer}
def num_ways(words, target)
    
end","class Solution {
    func numWays(_ words: [String], _ target: String) -> Int {
        
    }
}","func numWays(words []string, target string) int {
    
}","object Solution {
    def numWays(words: Array[String], target: String): Int = {
        
    }
}","class Solution {
    fun numWays(words: Array<String>, target: String): Int {
        
    }
}","impl Solution {
    pub fn num_ways(words: Vec<String>, target: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String[] $words
     * @param String $target
     * @return Integer
     */
    function numWays($words, $target) {
        
    }
}","function numWays(words: string[], target: string): number {

};","(define/contract (num-ways words target)
  (-> (listof string?) string? exact-integer?)

  )","-spec num_ways(Words :: [unicode:unicode_binary()], Target :: unicode:unicode_binary()) -> integer().
num_ways(Words, Target) ->
  .","defmodule Solution do
  @spec num_ways(words :: [String.t], target :: String.t) :: integer
  def num_ways(words, target) do

  end
end","class Solution {
  int numWays(List<String> words, String target) {

  }
}",,,,number-of-ways-to-form-a-target-string-given-a-dictionary
271,1643,Kth Smallest Instructions,"Bob is standing at cell `(0, 0)`, and he wants to reach `destination`: `(row, column)`. He can only travel right and down. You are going to help Bob by providing instructions for him to reach `destination`.
The instructions are represented as a string, where each character is either:
`'H'`, meaning move horizontally (go right), or
`'V'`, meaning move vertically (go down).
Multiple instructions will lead Bob to `destination`. For example, if `destination` is `(2, 3)`, both `""HHHVV""` and `""HVHVH""` are valid instructions.
However, Bob is very picky. Bob has a lucky number `k`, and he wants the `kth` lexicographically smallest instructions that will lead him to `destination`. `k` is 1-indexed.
Given an integer array `destination` and an integer `k`, return the `kth` lexicographically smallest instructions that will take Bob to `destination`.",0,Hard,,44.8,17.8,https://leetcode.com/problems/kth-smallest-instructions,100,4.9K,11K,HeavyWater,Dynamic Programming,193,3,98,0,,"class Solution {
public:
    string kthSmallestPath(vector<int>& destination, int k) {
        
    }
};","class Solution {
    public String kthSmallestPath(int[] destination, int k) {
        
    }
}","class Solution(object):
    def kthSmallestPath(self, destination, k):
        """"""
        :type destination: List[int]
        :type k: int
        :rtype: str
        """"""
        ","class Solution:
    def kthSmallestPath(self, destination: List[int], k: int) -> str:
        ","char * kthSmallestPath(int* destination, int destinationSize, int k){

}","public class Solution {
    public string KthSmallestPath(int[] destination, int k) {
        
    }
}","/**
 * @param {number[]} destination
 * @param {number} k
 * @return {string}
 */
var kthSmallestPath = function(destination, k) {
    
};","# @param {Integer[]} destination
# @param {Integer} k
# @return {String}
def kth_smallest_path(destination, k)
    
end","class Solution {
    func kthSmallestPath(_ destination: [Int], _ k: Int) -> String {
        
    }
}","func kthSmallestPath(destination []int, k int) string {
    
}","object Solution {
    def kthSmallestPath(destination: Array[Int], k: Int): String = {
        
    }
}","class Solution {
    fun kthSmallestPath(destination: IntArray, k: Int): String {
        
    }
}","impl Solution {
    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {
        
    }
}","class Solution {

    /**
     * @param Integer[] $destination
     * @param Integer $k
     * @return String
     */
    function kthSmallestPath($destination, $k) {
        
    }
}","function kthSmallestPath(destination: number[], k: number): string {

};","(define/contract (kth-smallest-path destination k)
  (-> (listof exact-integer?) exact-integer? string?)

  )","-spec kth_smallest_path(Destination :: [integer()], K :: integer()) -> unicode:unicode_binary().
kth_smallest_path(Destination, K) ->
  .","defmodule Solution do
  @spec kth_smallest_path(destination :: [integer], k :: integer) :: String.t
  def kth_smallest_path(destination, k) do

  end
end","class Solution {
  String kthSmallestPath(List<int> destination, int k) {

  }
}",,,,kth-smallest-instructions
272,1649,Create Sorted Array through Instructions,"Given an integer array `instructions`, you are asked to create a sorted array from the elements in `instructions`. You start with an empty container `nums`. For each element from left to right in `instructions`, insert it into `nums`. The cost of each insertion is the minimum of the following:
The number of elements currently in `nums` that are strictly less than `instructions[i]`.
The number of elements currently in `nums` that are strictly greater than `instructions[i]`.
For example, if inserting element `3` into `nums = [1,2,3,5]`, the cost of insertion is `min(2, 1)` (elements `1` and `2` are less than `3`, element `5` is greater than `3`) and `nums` will become `[1,2,3,3,5]`.
Return the total cost to insert all elements from `instructions` into `nums`. Since the answer may be large, return it modulo `109 + 7`",0,Hard,/articles/create-sorted-array-through-instructions,36.5,6.3,https://leetcode.com/problems/create-sorted-array-through-instructions,134,17.1K,46.7K,Akuna Capital,"Binary Search,Binary Indexed Tree,Segment Tree,Ordered Map",341,50,87,0,,"class Solution {
public:
    int createSortedArray(vector<int>& instructions) {
        
    }
};","class Solution {
    public int createSortedArray(int[] instructions) {
        
    }
}","class Solution(object):
    def createSortedArray(self, instructions):
        """"""
        :type instructions: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def createSortedArray(self, instructions: List[int]) -> int:
        ","

int createSortedArray(int* instructions, int instructionsSize){

}","public class Solution {
    public int CreateSortedArray(int[] instructions) {
        
    }
}","/**
 * @param {number[]} instructions
 * @return {number}
 */
var createSortedArray = function(instructions) {
    
};","# @param {Integer[]} instructions
# @return {Integer}
def create_sorted_array(instructions)
    
end","class Solution {
    func createSortedArray(_ instructions: [Int]) -> Int {
        
    }
}","func createSortedArray(instructions []int) int {
    
}","object Solution {
    def createSortedArray(instructions: Array[Int]): Int = {
        
    }
}","class Solution {
    fun createSortedArray(instructions: IntArray): Int {
        
    }
}","impl Solution {
    pub fn create_sorted_array(instructions: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $instructions
     * @return Integer
     */
    function createSortedArray($instructions) {
        
    }
}","function createSortedArray(instructions: number[]): number {

};",,,,,,,,create-sorted-array-through-instructions
273,1655,Distribute Repeating Integers,"You are given an array of `n` integers, `nums`, where there are at most `50` unique values in the array. You are also given an array of `m` customer order quantities, `quantity`, where `quantity[i]` is the amount of integers the `ith` customer ordered. Determine if it is possible to distribute `nums` such that:
The `ith` customer gets exactly `quantity[i]` integers,
The integers the `ith` customer gets are all equal, and
Every customer is satisfied.
Return `true` if it is possible to distribute `nums` according to the above conditions.",0,Hard,,40.0,0.0,https://leetcode.com/problems/distribute-repeating-integers,54,4.4K,11K,Google,"Dynamic Programming,Backtracking",115,11,91,1,,"class Solution {
public:
    bool canDistribute(vector<int>& nums, vector<int>& quantity) {
        
    }
};","class Solution {
    public boolean canDistribute(int[] nums, int[] quantity) {
        
    }
}","class Solution(object):
    def canDistribute(self, nums, quantity):
        """"""
        :type nums: List[int]
        :type quantity: List[int]
        :rtype: bool
        """"""
        ","class Solution:
    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        ","bool canDistribute(int* nums, int numsSize, int* quantity, int quantitySize){

}","public class Solution {
    public bool CanDistribute(int[] nums, int[] quantity) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number[]} quantity
 * @return {boolean}
 */
var canDistribute = function(nums, quantity) {
    
};","# @param {Integer[]} nums
# @param {Integer[]} quantity
# @return {Boolean}
def can_distribute(nums, quantity)
    
end","class Solution {
    func canDistribute(_ nums: [Int], _ quantity: [Int]) -> Bool {
        
    }
}","func canDistribute(nums []int, quantity []int) bool {
    
}","object Solution {
    def canDistribute(nums: Array[Int], quantity: Array[Int]): Boolean = {
        
    }
}","class Solution {
    fun canDistribute(nums: IntArray, quantity: IntArray): Boolean {
        
    }
}","impl Solution {
    pub fn can_distribute(nums: Vec<i32>, quantity: Vec<i32>) -> bool {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer[] $quantity
     * @return Boolean
     */
    function canDistribute($nums, $quantity) {
        
    }
}","function canDistribute(nums: number[], quantity: number[]): boolean {

};","(define/contract (can-distribute nums quantity)
  (-> (listof exact-integer?) (listof exact-integer?) boolean?)

  )","-spec can_distribute(Nums :: [integer()], Quantity :: [integer()]) -> boolean().
can_distribute(Nums, Quantity) ->
  .","defmodule Solution do
  @spec can_distribute(nums :: [integer], quantity :: [integer]) :: boolean
  def can_distribute(nums, quantity) do

  end
end","class Solution {
  bool canDistribute(List<int> nums, List<int> quantity) {

  }
}",,,,distribute-repeating-integers
274,1659,Maximize Grid Happiness,"You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.
You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.
The happiness of each person is calculated as follows:
Introverts start with `120` happiness and lose `30` happiness for each neighbor (introvert or extrovert).
Extroverts start with `40` happiness and gain `20` happiness for each neighbor (introvert or extrovert).
Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.
The grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.",0,Hard,,35.6,24.3,https://leetcode.com/problems/maximize-grid-happiness,36,2.5K,7.1K,Salesforce,"Dynamic Programming,Backtracking",128,42,75,0,,"class Solution {
public:
    int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
        
    }
};","class Solution {
    public int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
        
    }
}","class Solution(object):
    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):
        """"""
        :type m: int
        :type n: int
        :type introvertsCount: int
        :type extrovertsCount: int
        :rtype: int
        """"""
        ","class Solution:
    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:
        ","int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount){

}","public class Solution {
    public int GetMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
        
    }
}","/**
 * @param {number} m
 * @param {number} n
 * @param {number} introvertsCount
 * @param {number} extrovertsCount
 * @return {number}
 */
var getMaxGridHappiness = function(m, n, introvertsCount, extrovertsCount) {
    
};","# @param {Integer} m
# @param {Integer} n
# @param {Integer} introverts_count
# @param {Integer} extroverts_count
# @return {Integer}
def get_max_grid_happiness(m, n, introverts_count, extroverts_count)
    
end","class Solution {
    func getMaxGridHappiness(_ m: Int, _ n: Int, _ introvertsCount: Int, _ extrovertsCount: Int) -> Int {
        
    }
}","func getMaxGridHappiness(m int, n int, introvertsCount int, extrovertsCount int) int {
    
}","object Solution {
    def getMaxGridHappiness(m: Int, n: Int, introvertsCount: Int, extrovertsCount: Int): Int = {
        
    }
}","class Solution {
    fun getMaxGridHappiness(m: Int, n: Int, introvertsCount: Int, extrovertsCount: Int): Int {
        
    }
}","impl Solution {
    pub fn get_max_grid_happiness(m: i32, n: i32, introverts_count: i32, extroverts_count: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $m
     * @param Integer $n
     * @param Integer $introvertsCount
     * @param Integer $extrovertsCount
     * @return Integer
     */
    function getMaxGridHappiness($m, $n, $introvertsCount, $extrovertsCount) {
        
    }
}","function getMaxGridHappiness(m: number, n: number, introvertsCount: number, extrovertsCount: number): number {

};","(define/contract (get-max-grid-happiness m n introvertsCount extrovertsCount)
  (-> exact-integer? exact-integer? exact-integer? exact-integer? exact-integer?)

  )","-spec get_max_grid_happiness(M :: integer(), N :: integer(), IntrovertsCount :: integer(), ExtrovertsCount :: integer()) -> integer().
get_max_grid_happiness(M, N, IntrovertsCount, ExtrovertsCount) ->
  .","defmodule Solution do
  @spec get_max_grid_happiness(m :: integer, n :: integer, introverts_count :: integer, extroverts_count :: integer) :: integer
  def get_max_grid_happiness(m, n, introverts_count, extroverts_count) do

  end
end","class Solution {
  int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {

  }
}",,,,maximize-grid-happiness
275,1665,Minimum Initial Energy to Finish Tasks,"You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:
`actuali` is the actual amount of energy you spend to finish the `ith` task.
`minimumi` is the minimum amount of energy you require to begin the `ith` task.
For example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.
You can finish the tasks in any order you like.
Return the minimum initial amount of energy you will need to finish all the tasks.",0,Hard,,65.1,6.5,https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks,149,9.1K,14K,Akuna Capital,Greedy,207,24,90,0,,"class Solution {
public:
    int minimumEffort(vector<vector<int>>& tasks) {
        
    }
};","class Solution {
    public int minimumEffort(int[][] tasks) {
        
    }
}","class Solution(object):
    def minimumEffort(self, tasks):
        """"""
        :type tasks: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        ","int minimumEffort(int** tasks, int tasksSize, int* tasksColSize){

}","public class Solution {
    public int MinimumEffort(int[][] tasks) {
        
    }
}","/**
 * @param {number[][]} tasks
 * @return {number}
 */
var minimumEffort = function(tasks) {
    
};","# @param {Integer[][]} tasks
# @return {Integer}
def minimum_effort(tasks)
    
end","class Solution {
    func minimumEffort(_ tasks: [[Int]]) -> Int {
        
    }
}","func minimumEffort(tasks [][]int) int {
    
}","object Solution {
    def minimumEffort(tasks: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minimumEffort(tasks: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn minimum_effort(tasks: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $tasks
     * @return Integer
     */
    function minimumEffort($tasks) {
        
    }
}","function minimumEffort(tasks: number[][]): number {

};","(define/contract (minimum-effort tasks)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec minimum_effort(Tasks :: [[integer()]]) -> integer().
minimum_effort(Tasks) ->
  .","defmodule Solution do
  @spec minimum_effort(tasks :: [[integer]]) :: integer
  def minimum_effort(tasks) do

  end
end","class Solution {
  int minimumEffort(List<List<int>> tasks) {

  }
}",,,,minimum-initial-energy-to-finish-tasks
276,1671,Minimum Number of Removals to Make Mountain Array,"You may recall that an array `arr` is a mountain array if and only if:
`arr.length >= 3`
There exists some index `i` (0-indexed) with `0 < i < arr.length - 1` such that:
`arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`
`arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`
Given an integer array `nums`​​​, return the minimum number of elements to remove to make `nums​​​` a mountain array.",0,Hard,,45.4,13.4,https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array,112,5.4K,12K,Microsoft,Dynamic Programming,257,4,98,0,"[Longest Increasing Subsequence, /problems/longest-increasing-subsequence/, Medium], [Longest Mountain in Array, /problems/longest-mountain-in-array/, Medium], [Peak Index in a Mountain Array, /problems/peak-index-in-a-mountain-array/, Easy], [Valid Mountain Array, /problems/valid-mountain-array/, Easy], [Find in Mountain Array, /problems/find-in-mountain-array/, Hard]","class Solution {
public:
    int minimumMountainRemovals(vector<int>& nums) {
        
    }
};","class Solution {
    public int minimumMountainRemovals(int[] nums) {
        
    }
}","class Solution(object):
    def minimumMountainRemovals(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        ","int minimumMountainRemovals(int* nums, int numsSize){

}","public class Solution {
    public int MinimumMountainRemovals(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumMountainRemovals = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def minimum_mountain_removals(nums)
    
end","class Solution {
    func minimumMountainRemovals(_ nums: [Int]) -> Int {
        
    }
}","func minimumMountainRemovals(nums []int) int {
    
}","object Solution {
    def minimumMountainRemovals(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minimumMountainRemovals(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn minimum_mountain_removals(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function minimumMountainRemovals($nums) {
        
    }
}","function minimumMountainRemovals(nums: number[]): number {

};","(define/contract (minimum-mountain-removals nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec minimum_mountain_removals(Nums :: [integer()]) -> integer().
minimum_mountain_removals(Nums) ->
  .","defmodule Solution do
  @spec minimum_mountain_removals(nums :: [integer]) :: integer
  def minimum_mountain_removals(nums) do

  end
end","class Solution {
  int minimumMountainRemovals(List<int> nums) {

  }
}",,,,minimum-number-of-removals-to-make-mountain-array
277,1675,Minimize Deviation in Array,"You are given an array `nums` of `n` positive integers.
You can perform two types of operations on any element of the array any number of times:
If the element is even, divide it by `2`.
For example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2].`
If the element is odd, multiply it by `2`.
For example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4].`
The deviation of the array is the maximum difference between any two elements in the array.
Return the minimum deviation the array can have after performing some number of operations.",0,Hard,/articles/minimize-deviation-in-array,48.2,23.0,https://leetcode.com/problems/minimize-deviation-in-array,105,15.7K,32.6K,Samsung,"Heap,Ordered Map",406,18,96,0,,"class Solution {
public:
    int minimumDeviation(vector<int>& nums) {
        
    }
};","class Solution {
    public int minimumDeviation(int[] nums) {
        
    }
}","class Solution(object):
    def minimumDeviation(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        ","int minimumDeviation(int* nums, int numsSize){

}","public class Solution {
    public int MinimumDeviation(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumDeviation = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def minimum_deviation(nums)
    
end","class Solution {
    func minimumDeviation(_ nums: [Int]) -> Int {
        
    }
}","func minimumDeviation(nums []int) int {
    
}","object Solution {
    def minimumDeviation(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minimumDeviation(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn minimum_deviation(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function minimumDeviation($nums) {
        
    }
}","function minimumDeviation(nums: number[]): number {

};","(define/contract (minimum-deviation nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec minimum_deviation(Nums :: [integer()]) -> integer().
minimum_deviation(Nums) ->
  .","defmodule Solution do
  @spec minimum_deviation(nums :: [integer]) :: integer
  def minimum_deviation(nums) do

  end
end","class Solution {
  int minimumDeviation(List<int> nums) {

  }
}",,,,minimize-deviation-in-array
278,1681,Minimum Incompatibility,"You are given an integer array `nums`​​​ and an integer `k`. You are asked to distribute this array into `k` subsets of equal size such that there are no two equal elements in the same subset.
A subset's incompatibility is the difference between the maximum and minimum elements in that array.
Return the minimum possible sum of incompatibilities of the `k` subsets after distributing the array optimally, or return `-1` if it is not possible.
A subset is a group integers that appear in the array with no particular order.",0,Hard,,35.8,9.0,https://leetcode.com/problems/minimum-incompatibility,63,4.3K,12.2K,Microsoft,"Backtracking,Greedy",109,77,59,0,,"class Solution {
public:
    int minimumIncompatibility(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int minimumIncompatibility(int[] nums, int k) {
        
    }
}","class Solution(object):
    def minimumIncompatibility(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minimumIncompatibility(self, nums: List[int], k: int) -> int:
        ","int minimumIncompatibility(int* nums, int numsSize, int k){

}","public class Solution {
    public int MinimumIncompatibility(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minimumIncompatibility = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def minimum_incompatibility(nums, k)
    
end","class Solution {
    func minimumIncompatibility(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func minimumIncompatibility(nums []int, k int) int {
    
}","object Solution {
    def minimumIncompatibility(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun minimumIncompatibility(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn minimum_incompatibility(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function minimumIncompatibility($nums, $k) {
        
    }
}","function minimumIncompatibility(nums: number[], k: number): number {

};",,"-spec minimum_incompatibility(Nums :: [integer()], K :: integer()) -> integer().
minimum_incompatibility(Nums, K) ->
  .","defmodule Solution do
  @spec minimum_incompatibility(nums :: [integer], k :: integer) :: integer
  def minimum_incompatibility(nums, k) do

  end
end","class Solution {
  int minimumIncompatibility(List<int> nums, int k) {

  }
}",,,,minimum-incompatibility
279,1687,Delivering Boxes from Storage to Ports,"You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.
You are given an array `boxes`, where `boxes[i] = [ports​​i​, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`.
`ports​​i` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.
`portsCount` is the number of ports.
`maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.
The boxes need to be delivered in the order they are given. The ship will follow these steps:
The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.
For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.
The ship then makes a return trip to storage to take more boxes from the queue.
The ship must end at storage after all the boxes have been delivered.
Return the minimum number of trips the ship needs to make to deliver all boxes to their respective ports.",0,Hard,,35.4,6.4,https://leetcode.com/problems/delivering-boxes-from-storage-to-ports,22,2.1K,6K,Nutanix,"Two Pointers,Dynamic Programming,Segment Tree,Dequeue",129,12,91,0,,"class Solution {
public:
    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {
        
    }
};","class Solution {
    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {
        
    }
}","class Solution(object):
    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):
        """"""
        :type boxes: List[List[int]]
        :type portsCount: int
        :type maxBoxes: int
        :type maxWeight: int
        :rtype: int
        """"""
        ","class Solution:
    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:
        ","int boxDelivering(int** boxes, int boxesSize, int* boxesColSize, int portsCount, int maxBoxes, int maxWeight){

}","public class Solution {
    public int BoxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {
        
    }
}","/**
 * @param {number[][]} boxes
 * @param {number} portsCount
 * @param {number} maxBoxes
 * @param {number} maxWeight
 * @return {number}
 */
var boxDelivering = function(boxes, portsCount, maxBoxes, maxWeight) {
    
};","# @param {Integer[][]} boxes
# @param {Integer} ports_count
# @param {Integer} max_boxes
# @param {Integer} max_weight
# @return {Integer}
def box_delivering(boxes, ports_count, max_boxes, max_weight)
    
end","class Solution {
    func boxDelivering(_ boxes: [[Int]], _ portsCount: Int, _ maxBoxes: Int, _ maxWeight: Int) -> Int {
        
    }
}","func boxDelivering(boxes [][]int, portsCount int, maxBoxes int, maxWeight int) int {
    
}","object Solution {
    def boxDelivering(boxes: Array[Array[Int]], portsCount: Int, maxBoxes: Int, maxWeight: Int): Int = {
        
    }
}","class Solution {
    fun boxDelivering(boxes: Array<IntArray>, portsCount: Int, maxBoxes: Int, maxWeight: Int): Int {
        
    }
}","impl Solution {
    pub fn box_delivering(boxes: Vec<Vec<i32>>, ports_count: i32, max_boxes: i32, max_weight: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $boxes
     * @param Integer $portsCount
     * @param Integer $maxBoxes
     * @param Integer $maxWeight
     * @return Integer
     */
    function boxDelivering($boxes, $portsCount, $maxBoxes, $maxWeight) {
        
    }
}","function boxDelivering(boxes: number[][], portsCount: number, maxBoxes: number, maxWeight: number): number {

};",,,,"class Solution {
  int boxDelivering(List<List<int>> boxes, int portsCount, int maxBoxes, int maxWeight) {

  }
}",,,,delivering-boxes-from-storage-to-ports
280,1691,Maximum Height by Stacking Cuboids,"Given `n` `cuboids` where the dimensions of the `ith` cuboid is `cuboids[i] = [widthi, lengthi, heighti]` (0-indexed). Choose a subset of `cuboids` and place them on each other.
You can place cuboid `i` on cuboid `j` if `widthi <= widthj` and `lengthi <= lengthj` and `heighti <= heightj`. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.
Return the maximum height of the stacked `cuboids`.",0,Hard,,50.2,20.6,https://leetcode.com/problems/maximum-height-by-stacking-cuboids,79,4.4K,8.8K,Samsung,"Dynamic Programming,Sort",177,8,96,0,,"class Solution {
public:
    int maxHeight(vector<vector<int>>& cuboids) {
        
    }
};","class Solution {
    public int maxHeight(int[][] cuboids) {
        
    }
}","class Solution(object):
    def maxHeight(self, cuboids):
        """"""
        :type cuboids: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def maxHeight(self, cuboids: List[List[int]]) -> int:
        ","

int maxHeight(int** cuboids, int cuboidsSize, int* cuboidsColSize){

}","public class Solution {
    public int MaxHeight(int[][] cuboids) {
        
    }
}","/**
 * @param {number[][]} cuboids
 * @return {number}
 */
var maxHeight = function(cuboids) {
    
};","# @param {Integer[][]} cuboids
# @return {Integer}
def max_height(cuboids)
    
end","class Solution {
    func maxHeight(_ cuboids: [[Int]]) -> Int {
        
    }
}","func maxHeight(cuboids [][]int) int {
    
}","object Solution {
    def maxHeight(cuboids: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun maxHeight(cuboids: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn max_height(cuboids: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $cuboids
     * @return Integer
     */
    function maxHeight($cuboids) {
        
    }
}","function maxHeight(cuboids: number[][]): number {

};",,,,,,,,maximum-height-by-stacking-cuboids
281,1697,Checking Existence of Edge Length Limited Paths,"An undirected graph of `n` nodes is defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]` denotes an edge between nodes `ui` and `vi` with distance `disi`. Note that there may be multiple edges between two nodes.
Given an array `queries`, where `queries[j] = [pj, qj, limitj]`, your task is to determine for each `queries[j]` whether there is a path between `pj` and `qj` such that each edge on the path has a distance strictly less than `limitj` .
Return a boolean array `answer`, where `answer.length == queries.length` and the `jth` value of `answer` is `true` if there is a path for `queries[j]` is `true`, and `false` otherwise.",0,Hard,,54.2,16.0,https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths,69,5.4K,9.9K,Google,"Sort,Union Find",266,6,98,1,"[Checking Existence of Edge Length Limited Paths II, /problems/checking-existence-of-edge-length-limited-paths-ii/, Hard]","class Solution {
public:
    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {
        
    }
}","class Solution(object):
    def distanceLimitedPathsExist(self, n, edgeList, queries):
        """"""
        :type n: int
        :type edgeList: List[List[int]]
        :type queries: List[List[int]]
        :rtype: List[bool]
        """"""
        ","class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
bool* distanceLimitedPathsExist(int n, int** edgeList, int edgeListSize, int* edgeListColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edgeList
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var distanceLimitedPathsExist = function(n, edgeList, queries) {
    
};","# @param {Integer} n
# @param {Integer[][]} edge_list
# @param {Integer[][]} queries
# @return {Boolean[]}
def distance_limited_paths_exist(n, edge_list, queries)
    
end","class Solution {
    func distanceLimitedPathsExist(_ n: Int, _ edgeList: [[Int]], _ queries: [[Int]]) -> [Bool] {
        
    }
}","func distanceLimitedPathsExist(n int, edgeList [][]int, queries [][]int) []bool {
    
}","object Solution {
    def distanceLimitedPathsExist(n: Int, edgeList: Array[Array[Int]], queries: Array[Array[Int]]): Array[Boolean] = {
        
    }
}","class Solution {
    fun distanceLimitedPathsExist(n: Int, edgeList: Array<IntArray>, queries: Array<IntArray>): BooleanArray {
        
    }
}","impl Solution {
    pub fn distance_limited_paths_exist(n: i32, edge_list: Vec<Vec<i32>>, queries: Vec<Vec<i32>>) -> Vec<bool> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edgeList
     * @param Integer[][] $queries
     * @return Boolean[]
     */
    function distanceLimitedPathsExist($n, $edgeList, $queries) {
        
    }
}","function distanceLimitedPathsExist(n: number, edgeList: number[][], queries: number[][]): boolean[] {

};","(define/contract (distance-limited-paths-exist n edgeList queries)
  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof boolean?))

  )","-spec distance_limited_paths_exist(N :: integer(), EdgeList :: [[integer()]], Queries :: [[integer()]]) -> [boolean()].
distance_limited_paths_exist(N, EdgeList, Queries) ->
  .","defmodule Solution do
  @spec distance_limited_paths_exist(n :: integer, edge_list :: [[integer]], queries :: [[integer]]) :: [boolean]
  def distance_limited_paths_exist(n, edge_list, queries) do

  end
end","class Solution {
  List<bool> distanceLimitedPathsExist(int n, List<List<int>> edgeList, List<List<int>> queries) {

  }
}",,,,checking-existence-of-edge-length-limited-paths
282,1703,Minimum Adjacent Swaps for K Consecutive Ones,"You are given an integer array, `nums`, and an integer `k`. `nums` comprises of only `0`'s and `1`'s. In one move, you can choose two adjacent indices and swap their values.
Return the minimum number of moves required so that `nums` has `k` consecutive `1`'s.",0,Hard,,40.1,6.8,https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones,38,2.9K,7.1K,Microsoft,Stack,187,6,97,0,"[Minimum Swaps to Group All 1's Together, /problems/minimum-swaps-to-group-all-1s-together/, Medium]","class Solution {
public:
    int minMoves(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int minMoves(int[] nums, int k) {
        
    }
}","class Solution(object):
    def minMoves(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        ","int minMoves(int* nums, int numsSize, int k){

}","public class Solution {
    public int MinMoves(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minMoves = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def min_moves(nums, k)
    
end","class Solution {
    func minMoves(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func minMoves(nums []int, k int) int {
    
}","object Solution {
    def minMoves(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun minMoves(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn min_moves(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function minMoves($nums, $k) {
        
    }
}","function minMoves(nums: number[], k: number): number {

};","(define/contract (min-moves nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_moves(Nums :: [integer()], K :: integer()) -> integer().
min_moves(Nums, K) ->
  .","defmodule Solution do
  @spec min_moves(nums :: [integer], k :: integer) :: integer
  def min_moves(nums, k) do

  end
end","class Solution {
  int minMoves(List<int> nums, int k) {

  }
}",,,,minimum-adjacent-swaps-for-k-consecutive-ones
283,1707,Maximum XOR With an Element From Array,"You are given an array `nums` consisting of non-negative integers. You are also given a `queries` array, where `queries[i] = [xi, mi]`.
The answer to the `ith` query is the maximum bitwise `XOR` value of `xi` and any element of `nums` that does not exceed `mi`. In other words, the answer is `max(nums[j] XOR xi)` for all `j` such that `nums[j] <= mi`. If all elements in `nums` are larger than `mi`, then the answer is `-1`.
Return an integer array `answer` where `answer.length == queries.length` and `answer[i]` is the answer to the `ith` query.",0,Hard,,46.4,7.8,https://leetcode.com/problems/maximum-xor-with-an-element-from-array,69,5.1K,10.9K,Google,"Bit Manipulation,Trie",190,10,95,1,"[Maximum XOR of Two Numbers in an Array, /problems/maximum-xor-of-two-numbers-in-an-array/, Medium]","class Solution {
public:
    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public int[] maximizeXor(int[] nums, int[][] queries) {
        
    }
}","class Solution(object):
    def maximizeXor(self, nums, queries):
        """"""
        :type nums: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* maximizeXor(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public int[] MaximizeXor(int[] nums, int[][] queries) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number[][]} queries
 * @return {number[]}
 */
var maximizeXor = function(nums, queries) {
    
};","# @param {Integer[]} nums
# @param {Integer[][]} queries
# @return {Integer[]}
def maximize_xor(nums, queries)
    
end","class Solution {
    func maximizeXor(_ nums: [Int], _ queries: [[Int]]) -> [Int] {
        
    }
}","func maximizeXor(nums []int, queries [][]int) []int {
    
}","object Solution {
    def maximizeXor(nums: Array[Int], queries: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun maximizeXor(nums: IntArray, queries: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn maximize_xor(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer[][] $queries
     * @return Integer[]
     */
    function maximizeXor($nums, $queries) {
        
    }
}","function maximizeXor(nums: number[], queries: number[][]): number[] {

};","(define/contract (maximize-xor nums queries)
  (-> (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec maximize_xor(Nums :: [integer()], Queries :: [[integer()]]) -> [integer()].
maximize_xor(Nums, Queries) ->
  .","defmodule Solution do
  @spec maximize_xor(nums :: [integer], queries :: [[integer]]) :: [integer]
  def maximize_xor(nums, queries) do

  end
end","class Solution {
  List<int> maximizeXor(List<int> nums, List<List<int>> queries) {

  }
}",,,,maximum-xor-with-an-element-from-array
284,1713,Minimum Operations to Make a Subsequence,"You are given an array `target` that consists of distinct integers and another integer array `arr` that can have duplicates.
In one operation, you can insert any integer at any position in `arr`. For example, if `arr = [1,4,1,2]`, you can add `3` in the middle and make it `[1,4,3,1,2]`. Note that you can insert the integer at the very beginning or end of the array.
Return the minimum number of operations needed to make `target` a subsequence of `arr`.
A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not.",0,Hard,,45.6,29.8,https://leetcode.com/problems/minimum-operations-to-make-a-subsequence,62,3.9K,8.5K,Google,Greedy,223,3,99,1,,"class Solution {
public:
    int minOperations(vector<int>& target, vector<int>& arr) {
        
    }
};","class Solution {
    public int minOperations(int[] target, int[] arr) {
        
    }
}","class Solution(object):
    def minOperations(self, target, arr):
        """"""
        :type target: List[int]
        :type arr: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def minOperations(self, target: List[int], arr: List[int]) -> int:
        ","int minOperations(int* target, int targetSize, int* arr, int arrSize){

}","public class Solution {
    public int MinOperations(int[] target, int[] arr) {
        
    }
}","/**
 * @param {number[]} target
 * @param {number[]} arr
 * @return {number}
 */
var minOperations = function(target, arr) {
    
};","# @param {Integer[]} target
# @param {Integer[]} arr
# @return {Integer}
def min_operations(target, arr)
    
end","class Solution {
    func minOperations(_ target: [Int], _ arr: [Int]) -> Int {
        
    }
}","func minOperations(target []int, arr []int) int {
    
}","object Solution {
    def minOperations(target: Array[Int], arr: Array[Int]): Int = {
        
    }
}","class Solution {
    fun minOperations(target: IntArray, arr: IntArray): Int {
        
    }
}","impl Solution {
    pub fn min_operations(target: Vec<i32>, arr: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $target
     * @param Integer[] $arr
     * @return Integer
     */
    function minOperations($target, $arr) {
        
    }
}","function minOperations(target: number[], arr: number[]): number {

};","(define/contract (min-operations target arr)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)

  )","-spec min_operations(Target :: [integer()], Arr :: [integer()]) -> integer().
min_operations(Target, Arr) ->
  .","defmodule Solution do
  @spec min_operations(target :: [integer], arr :: [integer]) :: integer
  def min_operations(target, arr) do

  end
end","class Solution {
  int minOperations(List<int> target, List<int> arr) {

  }
}",,,,minimum-operations-to-make-a-subsequence
285,1719,Number Of Ways To Reconstruct A Tree,"You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and:
There are no duplicates.
`xi < yi`
Let `ways` be the number of rooted trees that satisfy the following conditions:
The tree consists of nodes whose values appeared in `pairs`.
A pair `[xi, yi]` exists in `pairs` if and only if `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`.
Note: the tree does not have to be a binary tree.
Two ways are considered to be different if there is at least one node that has different parents in both ways.
Return:
`0` if `ways == 0`
`1` if `ways == 1`
`2` if `ways > 1`
A rooted tree is a tree that has a single root node, and all edges are oriented to be outgoing from the root.
An ancestor of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.",0,Hard,,39.5,12.3,https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree,25,1.5K,3.8K,Uber,"Tree,Graph",64,46,58,0,,"class Solution {
public:
    int checkWays(vector<vector<int>>& pairs) {
        
    }
};","class Solution {
    public int checkWays(int[][] pairs) {
        
    }
}","class Solution(object):
    def checkWays(self, pairs):
        """"""
        :type pairs: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        ","int checkWays(int** pairs, int pairsSize, int* pairsColSize){

}","public class Solution {
    public int CheckWays(int[][] pairs) {
        
    }
}","/**
 * @param {number[][]} pairs
 * @return {number}
 */
var checkWays = function(pairs) {
    
};","# @param {Integer[][]} pairs
# @return {Integer}
def check_ways(pairs)
    
end","class Solution {
    func checkWays(_ pairs: [[Int]]) -> Int {
        
    }
}","func checkWays(pairs [][]int) int {
    
}","object Solution {
    def checkWays(pairs: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun checkWays(pairs: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn check_ways(pairs: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $pairs
     * @return Integer
     */
    function checkWays($pairs) {
        
    }
}","function checkWays(pairs: number[][]): number {

};","(define/contract (check-ways pairs)
  (-> (listof (listof exact-integer?)) exact-integer?)

  )","-spec check_ways(Pairs :: [[integer()]]) -> integer().
check_ways(Pairs) ->
  .","defmodule Solution do
  @spec check_ways(pairs :: [[integer]]) :: integer
  def check_ways(pairs) do

  end
end","class Solution {
  int checkWays(List<List<int>> pairs) {

  }
}",,,,number-of-ways-to-reconstruct-a-tree
286,1723,Find Minimum Time to Finish All Jobs,"You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.
There are `k` workers that you can assign jobs to. Each job should be assigned to exactly one worker. The working time of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the maximum working time of any worker is minimized.
Return the minimum possible maximum working time of any assignment.",0,Hard,,43.7,5.7,https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs,77,7.7K,17.6K,Amazon,"Backtracking,Recursion",211,10,95,1,,"class Solution {
public:
    int minimumTimeRequired(vector<int>& jobs, int k) {
        
    }
};","class Solution {
    public int minimumTimeRequired(int[] jobs, int k) {
        
    }
}","class Solution(object):
    def minimumTimeRequired(self, jobs, k):
        """"""
        :type jobs: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:
        ","int minimumTimeRequired(int* jobs, int jobsSize, int k){

}","public class Solution {
    public int MinimumTimeRequired(int[] jobs, int k) {
        
    }
}","/**
 * @param {number[]} jobs
 * @param {number} k
 * @return {number}
 */
var minimumTimeRequired = function(jobs, k) {
    
};","# @param {Integer[]} jobs
# @param {Integer} k
# @return {Integer}
def minimum_time_required(jobs, k)
    
end","class Solution {
    func minimumTimeRequired(_ jobs: [Int], _ k: Int) -> Int {
        
    }
}","func minimumTimeRequired(jobs []int, k int) int {
    
}","object Solution {
    def minimumTimeRequired(jobs: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun minimumTimeRequired(jobs: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn minimum_time_required(jobs: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $jobs
     * @param Integer $k
     * @return Integer
     */
    function minimumTimeRequired($jobs, $k) {
        
    }
}","function minimumTimeRequired(jobs: number[], k: number): number {

};","(define/contract (minimum-time-required jobs k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec minimum_time_required(Jobs :: [integer()], K :: integer()) -> integer().
minimum_time_required(Jobs, K) ->
  .","defmodule Solution do
  @spec minimum_time_required(jobs :: [integer], k :: integer) :: integer
  def minimum_time_required(jobs, k) do

  end
end","class Solution {
  int minimumTimeRequired(List<int> jobs, int k) {

  }
}",,,,find-minimum-time-to-finish-all-jobs
287,1728,Cat and Mouse II,"A game is played by a cat and a mouse named Cat and Mouse.
The environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.
Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).
Floors are represented by the character `'.'` and can be walked on.
Walls are represented by the character `'#'` and cannot be walked on.
Food is represented by the character `'F'` and can be walked on.
There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.
Mouse and Cat play according to the following rules:
Mouse moves first, then they take turns to move.
During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.
`catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.
Staying in the same position is allowed.
Mouse can jump over Cat.
The game can end in 4 ways:
If Cat occupies the same position as Mouse, Cat wins.
If Cat reaches the food first, Cat wins.
If Mouse reaches the food first, Mouse wins.
If Mouse cannot get to the food within 1000 turns, Cat wins.
Given a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` if Mouse can win the game if both Cat and Mouse play optimally, otherwise return `false`.",0,Hard,,41.0,0.0,https://leetcode.com/problems/cat-and-mouse-ii,40,3K,7.3K,Google,Dynamic Programming,79,18,81,1,"[Escape The Ghosts, /problems/escape-the-ghosts/, Medium], [Cat and Mouse, /problems/cat-and-mouse/, Hard]","class Solution {
public:
    bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {
        
    }
};","class Solution {
    public boolean canMouseWin(String[] grid, int catJump, int mouseJump) {
        
    }
}","class Solution(object):
    def canMouseWin(self, grid, catJump, mouseJump):
        """"""
        :type grid: List[str]
        :type catJump: int
        :type mouseJump: int
        :rtype: bool
        """"""
        ","class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        ","bool canMouseWin(char ** grid, int gridSize, int catJump, int mouseJump){

}","public class Solution {
    public bool CanMouseWin(string[] grid, int catJump, int mouseJump) {
        
    }
}","/**
 * @param {string[]} grid
 * @param {number} catJump
 * @param {number} mouseJump
 * @return {boolean}
 */
var canMouseWin = function(grid, catJump, mouseJump) {
    
};","# @param {String[]} grid
# @param {Integer} cat_jump
# @param {Integer} mouse_jump
# @return {Boolean}
def can_mouse_win(grid, cat_jump, mouse_jump)
    
end","class Solution {
    func canMouseWin(_ grid: [String], _ catJump: Int, _ mouseJump: Int) -> Bool {
        
    }
}","func canMouseWin(grid []string, catJump int, mouseJump int) bool {
    
}","object Solution {
    def canMouseWin(grid: Array[String], catJump: Int, mouseJump: Int): Boolean = {
        
    }
}","class Solution {
    fun canMouseWin(grid: Array<String>, catJump: Int, mouseJump: Int): Boolean {
        
    }
}","impl Solution {
    pub fn can_mouse_win(grid: Vec<String>, cat_jump: i32, mouse_jump: i32) -> bool {
        
    }
}","class Solution {

    /**
     * @param String[] $grid
     * @param Integer $catJump
     * @param Integer $mouseJump
     * @return Boolean
     */
    function canMouseWin($grid, $catJump, $mouseJump) {
        
    }
}","function canMouseWin(grid: string[], catJump: number, mouseJump: number): boolean {

};","(define/contract (can-mouse-win grid catJump mouseJump)
  (-> (listof string?) exact-integer? exact-integer? boolean?)

  )","-spec can_mouse_win(Grid :: [unicode:unicode_binary()], CatJump :: integer(), MouseJump :: integer()) -> boolean().
can_mouse_win(Grid, CatJump, MouseJump) ->
  .","defmodule Solution do
  @spec can_mouse_win(grid :: [String.t], cat_jump :: integer, mouse_jump :: integer) :: boolean
  def can_mouse_win(grid, cat_jump, mouse_jump) do

  end
end","class Solution {
  bool canMouseWin(List<String> grid, int catJump, int mouseJump) {

  }
}",,,,cat-and-mouse-ii
288,1735,Count Ways to Make Array With Product,"You are given a 2D integer array, `queries`. For each `queries[i]`, where `queries[i] = [ni, ki]`, find the number of different ways you can place positive integers into an array of size `ni` such that the product of the integers is `ki`. As the number of ways may be too large, the answer to the `ith` query is the number of ways modulo `109 + 7`.
Return an integer array `answer` where `answer.length == queries.length`, and `answer[i]` is the answer to the `ith` query.",0,Hard,,47.9,0.0,https://leetcode.com/problems/count-ways-to-make-array-with-product,31,2.1K,4.4K,Amazon,Math,92,20,82,1,,"class Solution {
public:
    vector<int> waysToFillArray(vector<vector<int>>& queries) {
        
    }
};","class Solution {
    public int[] waysToFillArray(int[][] queries) {
        
    }
}","class Solution(object):
    def waysToFillArray(self, queries):
        """"""
        :type queries: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* waysToFillArray(int** queries, int queriesSize, int* queriesColSize, int* returnSize){

}","public class Solution {
    public int[] WaysToFillArray(int[][] queries) {
        
    }
}","/**
 * @param {number[][]} queries
 * @return {number[]}
 */
var waysToFillArray = function(queries) {
    
};","# @param {Integer[][]} queries
# @return {Integer[]}
def ways_to_fill_array(queries)
    
end","class Solution {
    func waysToFillArray(_ queries: [[Int]]) -> [Int] {
        
    }
}","func waysToFillArray(queries [][]int) []int {
    
}","object Solution {
    def waysToFillArray(queries: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun waysToFillArray(queries: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn ways_to_fill_array(queries: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $queries
     * @return Integer[]
     */
    function waysToFillArray($queries) {
        
    }
}","function waysToFillArray(queries: number[][]): number[] {

};","(define/contract (ways-to-fill-array queries)
  (-> (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec ways_to_fill_array(Queries :: [[integer()]]) -> [integer()].
ways_to_fill_array(Queries) ->
  .","defmodule Solution do
  @spec ways_to_fill_array(queries :: [[integer]]) :: [integer]
  def ways_to_fill_array(queries) do

  end
end","class Solution {
  List<int> waysToFillArray(List<List<int>> queries) {

  }
}",,,,count-ways-to-make-array-with-product
289,1739,Building Boxes,"You have a cubic storeroom where the width, length, and height of the room are all equal to `n` units. You are asked to place `n` boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:
You can place the boxes anywhere on the floor.
If box `x` is placed on top of the box `y`, then each side of the four vertical sides of the box `y` must either be adjacent to another box or to a wall.
Given an integer `n`, return the minimum possible number of boxes touching the floor.",0,Hard,,49.6,11.2,https://leetcode.com/problems/building-boxes,62,3.3K,6.7K,Codenation,"Math,Binary Search",130,22,86,0,,"class Solution {
public:
    int minimumBoxes(int n) {
        
    }
};","class Solution {
    public int minimumBoxes(int n) {
        
    }
}","class Solution(object):
    def minimumBoxes(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def minimumBoxes(self, n: int) -> int:
        ","int minimumBoxes(int n){

}","public class Solution {
    public int MinimumBoxes(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var minimumBoxes = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def minimum_boxes(n)
    
end","class Solution {
    func minimumBoxes(_ n: Int) -> Int {
        
    }
}","func minimumBoxes(n int) int {
    
}","object Solution {
    def minimumBoxes(n: Int): Int = {
        
    }
}","class Solution {
    fun minimumBoxes(n: Int): Int {
        
    }
}","impl Solution {
    pub fn minimum_boxes(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function minimumBoxes($n) {
        
    }
}","function minimumBoxes(n: number): number {

};","(define/contract (minimum-boxes n)
  (-> exact-integer? exact-integer?)

  )","-spec minimum_boxes(N :: integer()) -> integer().
minimum_boxes(N) ->
  .","defmodule Solution do
  @spec minimum_boxes(n :: integer) :: integer
  def minimum_boxes(n) do

  end
end","class Solution {
  int minimumBoxes(int n) {

  }
}",,,,building-boxes
290,1745,Palindrome Partitioning IV,"Given a string `s`, return `true` if it is possible to split the string `s` into three non-empty palindromic substrings. Otherwise, return `false`.​​​​​
A string is said to be palindrome if it the same string when reversed.",0,Hard,,49.5,4.3,https://leetcode.com/problems/palindrome-partitioning-iv,115,7.4K,15K,tcs,"String,Dynamic Programming",204,4,98,0,"[Palindrome Partitioning, /problems/palindrome-partitioning/, Medium], [Palindrome Partitioning II, /problems/palindrome-partitioning-ii/, Hard], [Palindrome Partitioning III, /problems/palindrome-partitioning-iii/, Hard]","class Solution {
public:
    bool checkPartitioning(string s) {
        
    }
};","class Solution {
    public boolean checkPartitioning(String s) {
        
    }
}","class Solution(object):
    def checkPartitioning(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""
        ","class Solution:
    def checkPartitioning(self, s: str) -> bool:
        ","bool checkPartitioning(char * s){

}","public class Solution {
    public bool CheckPartitioning(string s) {
        
    }
}","/**
 * @param {string} s
 * @return {boolean}
 */
var checkPartitioning = function(s) {
    
};","# @param {String} s
# @return {Boolean}
def check_partitioning(s)
    
end","class Solution {
    func checkPartitioning(_ s: String) -> Bool {
        
    }
}","func checkPartitioning(s string) bool {
    
}","object Solution {
    def checkPartitioning(s: String): Boolean = {
        
    }
}","class Solution {
    fun checkPartitioning(s: String): Boolean {
        
    }
}","impl Solution {
    pub fn check_partitioning(s: String) -> bool {
        
    }
}","class Solution {

    /**
     * @param String $s
     * @return Boolean
     */
    function checkPartitioning($s) {
        
    }
}","function checkPartitioning(s: string): boolean {

};","(define/contract (check-partitioning s)
  (-> string? boolean?)

  )","-spec check_partitioning(S :: unicode:unicode_binary()) -> boolean().
check_partitioning(S) ->
  .","defmodule Solution do
  @spec check_partitioning(s :: String.t) :: boolean
  def check_partitioning(s) do

  end
end","class Solution {
  bool checkPartitioning(String s) {

  }
}",,,,palindrome-partitioning-iv
291,1751,Maximum Number of Events That Can Be Attended II,"You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.
You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.
Return the maximum sum of values that you can receive by attending events.",0,Hard,,48.1,10.0,https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii,80,4.7K,9.7K,Amazon,"Binary Search,Dynamic Programming",179,3,98,1,"[Maximum Number of Events That Can Be Attended, /problems/maximum-number-of-events-that-can-be-attended/, Medium]","class Solution {
public:
    int maxValue(vector<vector<int>>& events, int k) {
        
    }
};","class Solution {
    public int maxValue(int[][] events, int k) {
        
    }
}","class Solution(object):
    def maxValue(self, events, k):
        """"""
        :type events: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        ","int maxValue(int** events, int eventsSize, int* eventsColSize, int k){

}","public class Solution {
    public int MaxValue(int[][] events, int k) {
        
    }
}","/**
 * @param {number[][]} events
 * @param {number} k
 * @return {number}
 */
var maxValue = function(events, k) {
    
};","# @param {Integer[][]} events
# @param {Integer} k
# @return {Integer}
def max_value(events, k)
    
end","class Solution {
    func maxValue(_ events: [[Int]], _ k: Int) -> Int {
        
    }
}","func maxValue(events [][]int, k int) int {
    
}","object Solution {
    def maxValue(events: Array[Array[Int]], k: Int): Int = {
        
    }
}","class Solution {
    fun maxValue(events: Array<IntArray>, k: Int): Int {
        
    }
}","impl Solution {
    pub fn max_value(events: Vec<Vec<i32>>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $events
     * @param Integer $k
     * @return Integer
     */
    function maxValue($events, $k) {
        
    }
}","function maxValue(events: number[][], k: number): number {

};","(define/contract (max-value events k)
  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)

  )","-spec max_value(Events :: [[integer()]], K :: integer()) -> integer().
max_value(Events, K) ->
  .","defmodule Solution do
  @spec max_value(events :: [[integer]], k :: integer) :: integer
  def max_value(events, k) do

  end
end","class Solution {
  int maxValue(List<List<int>> events, int k) {

  }
}",,,,maximum-number-of-events-that-can-be-attended-ii
292,1755,Closest Subsequence Sum,"You are given an integer array `nums` and an integer `goal`.
You want to choose a subsequence of `nums` such that the sum of its elements is the closest possible to `goal`. That is, if the sum of the subsequence's elements is `sum`, then you want to minimize the absolute difference `abs(sum - goal)`.
Return the minimum possible value of `abs(sum - goal)`.
Note that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.",0,Hard,,35.7,2.7,https://leetcode.com/problems/closest-subsequence-sum,67,4.5K,12.6K,Sprinklr,"Divide and Conquer,Meet in the Middle",185,40,82,0,,"class Solution {
public:
    int minAbsDifference(vector<int>& nums, int goal) {
        
    }
};","class Solution {
    public int minAbsDifference(int[] nums, int goal) {
        
    }
}","class Solution(object):
    def minAbsDifference(self, nums, goal):
        """"""
        :type nums: List[int]
        :type goal: int
        :rtype: int
        """"""
        ","class Solution:
    def minAbsDifference(self, nums: List[int], goal: int) -> int:
        ","int minAbsDifference(int* nums, int numsSize, int goal){

}","public class Solution {
    public int MinAbsDifference(int[] nums, int goal) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} goal
 * @return {number}
 */
var minAbsDifference = function(nums, goal) {
    
};","# @param {Integer[]} nums
# @param {Integer} goal
# @return {Integer}
def min_abs_difference(nums, goal)
    
end","class Solution {
    func minAbsDifference(_ nums: [Int], _ goal: Int) -> Int {
        
    }
}","func minAbsDifference(nums []int, goal int) int {
    
}","object Solution {
    def minAbsDifference(nums: Array[Int], goal: Int): Int = {
        
    }
}","class Solution {
    fun minAbsDifference(nums: IntArray, goal: Int): Int {
        
    }
}","impl Solution {
    pub fn min_abs_difference(nums: Vec<i32>, goal: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $goal
     * @return Integer
     */
    function minAbsDifference($nums, $goal) {
        
    }
}","function minAbsDifference(nums: number[], goal: number): number {

};","(define/contract (min-abs-difference nums goal)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_abs_difference(Nums :: [integer()], Goal :: integer()) -> integer().
min_abs_difference(Nums, Goal) ->
  .","defmodule Solution do
  @spec min_abs_difference(nums :: [integer], goal :: integer) :: integer
  def min_abs_difference(nums, goal) do

  end
end","class Solution {
  int minAbsDifference(List<int> nums, int goal) {

  }
}",,,,closest-subsequence-sum
293,1761,Minimum Degree of a Connected Trio in a Graph,"You are given an undirected graph. You are given an integer `n` which is the number of nodes in the graph and an array `edges`, where each `edges[i] = [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`.
A connected trio is a set of three nodes where there is an edge between every pair of them.
The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.
Return the minimum degree of a connected trio in the graph, or `-1` if the graph has no connected trios.",0,Hard,,37.5,17.3,https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph,77,5.8K,15.5K,Amazon,Graph,65,118,36,1,,"class Solution {
public:
    int minTrioDegree(int n, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int minTrioDegree(int n, int[][] edges) {
        
    }
}","class Solution(object):
    def minTrioDegree(self, n, edges):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """"""
        ","class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        ","int minTrioDegree(int n, int** edges, int edgesSize, int* edgesColSize){

}","public class Solution {
    public int MinTrioDegree(int n, int[][] edges) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number}
 */
var minTrioDegree = function(n, edges) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer}
def min_trio_degree(n, edges)
    
end","class Solution {
    func minTrioDegree(_ n: Int, _ edges: [[Int]]) -> Int {
        
    }
}","func minTrioDegree(n int, edges [][]int) int {
    
}","object Solution {
    def minTrioDegree(n: Int, edges: Array[Array[Int]]): Int = {
        
    }
}","class Solution {
    fun minTrioDegree(n: Int, edges: Array<IntArray>): Int {
        
    }
}","impl Solution {
    pub fn min_trio_degree(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @return Integer
     */
    function minTrioDegree($n, $edges) {
        
    }
}","function minTrioDegree(n: number, edges: number[][]): number {

};","(define/contract (min-trio-degree n edges)
  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)

  )","-spec min_trio_degree(N :: integer(), Edges :: [[integer()]]) -> integer().
min_trio_degree(N, Edges) ->
  .","defmodule Solution do
  @spec min_trio_degree(n :: integer, edges :: [[integer]]) :: integer
  def min_trio_degree(n, edges) do

  end
end","class Solution {
  int minTrioDegree(int n, List<List<int>> edges) {

  }
}",,,,minimum-degree-of-a-connected-trio-in-a-graph
294,1766,Tree of Coprimes,"There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges. Each node has a value associated with it, and the root of the tree is node `0`.
To represent this tree, you are given an integer array `nums` and a 2D array `edges`. Each `nums[i]` represents the `ith` node's value, and each `edges[j] = [uj, vj]` represents an edge between nodes `uj` and `vj` in the tree.
Two values `x` and `y` are coprime if `gcd(x, y) == 1` where `gcd(x, y)` is the greatest common divisor of `x` and `y`.
An ancestor of a node `i` is any other node on the shortest path from node `i` to the root. A node is not considered an ancestor of itself.
Return an array `ans` of size `n`, where `ans[i]` is the closest ancestor to node `i` such that `nums[i]` and `nums[ans[i]]` are coprime, or `-1` if there is no such ancestor.",0,Hard,,36.7,2.8,https://leetcode.com/problems/tree-of-coprimes,55,2.8K,7.6K,Google,"Math,Tree,Depth-first Search,Breadth-first Search",119,8,94,1,,"class Solution {
public:
    vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {
        
    }
};","class Solution {
    public int[] getCoprimes(int[] nums, int[][] edges) {
        
    }
}","class Solution(object):
    def getCoprimes(self, nums, edges):
        """"""
        :type nums: List[int]
        :type edges: List[List[int]]
        :rtype: List[int]
        """"""
        ","class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* getCoprimes(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize, int* returnSize){

}","public class Solution {
    public int[] GetCoprimes(int[] nums, int[][] edges) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number[][]} edges
 * @return {number[]}
 */
var getCoprimes = function(nums, edges) {
    
};","# @param {Integer[]} nums
# @param {Integer[][]} edges
# @return {Integer[]}
def get_coprimes(nums, edges)
    
end","class Solution {
    func getCoprimes(_ nums: [Int], _ edges: [[Int]]) -> [Int] {
        
    }
}","func getCoprimes(nums []int, edges [][]int) []int {
    
}","object Solution {
    def getCoprimes(nums: Array[Int], edges: Array[Array[Int]]): Array[Int] = {
        
    }
}","class Solution {
    fun getCoprimes(nums: IntArray, edges: Array<IntArray>): IntArray {
        
    }
}","impl Solution {
    pub fn get_coprimes(nums: Vec<i32>, edges: Vec<Vec<i32>>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer[][] $edges
     * @return Integer[]
     */
    function getCoprimes($nums, $edges) {
        
    }
}","function getCoprimes(nums: number[], edges: number[][]): number[] {

};","(define/contract (get-coprimes nums edges)
  (-> (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))

  )","-spec get_coprimes(Nums :: [integer()], Edges :: [[integer()]]) -> [integer()].
get_coprimes(Nums, Edges) ->
  .","defmodule Solution do
  @spec get_coprimes(nums :: [integer], edges :: [[integer]]) :: [integer]
  def get_coprimes(nums, edges) do

  end
end","class Solution {
  List<int> getCoprimes(List<int> nums, List<List<int>> edges) {

  }
}",,,,tree-of-coprimes
295,1771,Maximize Palindrome Length From Subsequences,"You are given two strings, `word1` and `word2`. You want to construct a string in the following manner:
Choose some non-empty subsequence `subsequence1` from `word1`.
Choose some non-empty subsequence `subsequence2` from `word2`.
Concatenate the subsequences: `subsequence1 + subsequence2`, to make the string.
Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return `0`.
A subsequence of a string `s` is a string that can be made by deleting some (possibly none) characters from `s` without changing the order of the remaining characters.
A palindrome is a string that reads the same forward as well as backward.",0,Hard,,34.1,4.4,https://leetcode.com/problems/maximize-palindrome-length-from-subsequences,84,4.6K,13.4K,Goldman Sachs,Dynamic Programming,182,5,97,0,"[Longest Palindromic Subsequence, /problems/longest-palindromic-subsequence/, Medium]","class Solution {
public:
    int longestPalindrome(string word1, string word2) {
        
    }
};","class Solution {
    public int longestPalindrome(String word1, String word2) {
        
    }
}","class Solution(object):
    def longestPalindrome(self, word1, word2):
        """"""
        :type word1: str
        :type word2: str
        :rtype: int
        """"""
        ","class Solution:
    def longestPalindrome(self, word1: str, word2: str) -> int:
        ","int longestPalindrome(char * word1, char * word2){

}","public class Solution {
    public int LongestPalindrome(string word1, string word2) {
        
    }
}","/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var longestPalindrome = function(word1, word2) {
    
};","# @param {String} word1
# @param {String} word2
# @return {Integer}
def longest_palindrome(word1, word2)
    
end","class Solution {
    func longestPalindrome(_ word1: String, _ word2: String) -> Int {
        
    }
}","func longestPalindrome(word1 string, word2 string) int {
    
}","object Solution {
    def longestPalindrome(word1: String, word2: String): Int = {
        
    }
}","class Solution {
    fun longestPalindrome(word1: String, word2: String): Int {
        
    }
}","impl Solution {
    pub fn longest_palindrome(word1: String, word2: String) -> i32 {
        
    }
}","class Solution {

    /**
     * @param String $word1
     * @param String $word2
     * @return Integer
     */
    function longestPalindrome($word1, $word2) {
        
    }
}","function longestPalindrome(word1: string, word2: string): number {

};","(define/contract (longest-palindrome word1 word2)
  (-> string? string? exact-integer?)

  )","-spec longest_palindrome(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> integer().
longest_palindrome(Word1, Word2) ->
  .","defmodule Solution do
  @spec longest_palindrome(word1 :: String.t, word2 :: String.t) :: integer
  def longest_palindrome(word1, word2) do

  end
end","class Solution {
  int longestPalindrome(String word1, String word2) {

  }
}",,,,maximize-palindrome-length-from-subsequences
296,1776,Car Fleet II,"There are `n` cars traveling at different speeds in the same direction along a one-lane road. You are given an array `cars` of length `n`, where `cars[i] = [positioni, speedi]` represents:
`positioni` is the distance between the `ith` car and the beginning of the road in meters. It is guaranteed that `positioni < positioni+1`.
`speedi` is the initial speed of the `ith` car in meters per second.
For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet.
Return an array `answer`, where `answer[i]` is the time, in seconds, at which the `ith` car collides with the next car, or `-1` if the car does not collide with the next car. Answers within `10-5` of the actual answers are accepted.",0,Hard,,46.5,16.6,https://leetcode.com/problems/car-fleet-ii,62,3.8K,8.2K,Google,Math,167,4,98,1,"[Car Fleet, /problems/car-fleet/, Medium]","class Solution {
public:
    vector<double> getCollisionTimes(vector<vector<int>>& cars) {
        
    }
};","class Solution {
    public double[] getCollisionTimes(int[][] cars) {
        
    }
}","class Solution(object):
    def getCollisionTimes(self, cars):
        """"""
        :type cars: List[List[int]]
        :rtype: List[float]
        """"""
        ","class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
double* getCollisionTimes(int** cars, int carsSize, int* carsColSize, int* returnSize){

}","public class Solution {
    public double[] GetCollisionTimes(int[][] cars) {
        
    }
}","/**
 * @param {number[][]} cars
 * @return {number[]}
 */
var getCollisionTimes = function(cars) {
    
};","# @param {Integer[][]} cars
# @return {Float[]}
def get_collision_times(cars)
    
end","class Solution {
    func getCollisionTimes(_ cars: [[Int]]) -> [Double] {
        
    }
}","func getCollisionTimes(cars [][]int) []float64 {
    
}","object Solution {
    def getCollisionTimes(cars: Array[Array[Int]]): Array[Double] = {
        
    }
}","class Solution {
    fun getCollisionTimes(cars: Array<IntArray>): DoubleArray {
        
    }
}","impl Solution {
    pub fn get_collision_times(cars: Vec<Vec<i32>>) -> Vec<f64> {
        
    }
}","class Solution {

    /**
     * @param Integer[][] $cars
     * @return Float[]
     */
    function getCollisionTimes($cars) {
        
    }
}","function getCollisionTimes(cars: number[][]): number[] {

};","(define/contract (get-collision-times cars)
  (-> (listof (listof exact-integer?)) (listof flonum?))

  )","-spec get_collision_times(Cars :: [[integer()]]) -> [float()].
get_collision_times(Cars) ->
  .","defmodule Solution do
  @spec get_collision_times(cars :: [[integer]]) :: [float]
  def get_collision_times(cars) do

  end
end","class Solution {
  List<double> getCollisionTimes(List<List<int>> cars) {

  }
}",,,,car-fleet-ii
297,1782,Count Pairs Of Nodes,"You are given an undirected graph represented by an integer `n`, which is the number of nodes, and `edges`, where `edges[i] = [ui, vi]` which indicates that there is an undirected edge between `ui` and `vi`. You are also given an integer array `queries`.
The answer to the `jth` query is the number of pairs of nodes `(a, b)` that satisfy the following conditions:
`a < b`
`cnt` is strictly greater than `queries[j]`, where `cnt` is the number of edges incident to `a` or `b`.
Return an array `answers` such that `answers.length == queries.length` and `answers[j]` is the answer of the `jth` query.
Note that there can be repeated edges.",0,Hard,,32.4,1.1,https://leetcode.com/problems/count-pairs-of-nodes,39,2.2K,6.7K,Google,Graph,101,77,57,1,,"class Solution {
public:
    vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {
        
    }
};","class Solution {
    public int[] countPairs(int n, int[][] edges, int[] queries) {
        
    }
}","class Solution(object):
    def countPairs(self, n, edges, queries):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type queries: List[int]
        :rtype: List[int]
        """"""
        ","class Solution:
    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        ","/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* countPairs(int n, int** edges, int edgesSize, int* edgesColSize, int* queries, int queriesSize, int* returnSize){

}","public class Solution {
    public int[] CountPairs(int n, int[][] edges, int[] queries) {
        
    }
}","/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number[]} queries
 * @return {number[]}
 */
var countPairs = function(n, edges, queries) {
    
};","# @param {Integer} n
# @param {Integer[][]} edges
# @param {Integer[]} queries
# @return {Integer[]}
def count_pairs(n, edges, queries)
    
end","class Solution {
    func countPairs(_ n: Int, _ edges: [[Int]], _ queries: [Int]) -> [Int] {
        
    }
}","func countPairs(n int, edges [][]int, queries []int) []int {
    
}","object Solution {
    def countPairs(n: Int, edges: Array[Array[Int]], queries: Array[Int]): Array[Int] = {
        
    }
}","class Solution {
    fun countPairs(n: Int, edges: Array<IntArray>, queries: IntArray): IntArray {
        
    }
}","impl Solution {
    pub fn count_pairs(n: i32, edges: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @param Integer[][] $edges
     * @param Integer[] $queries
     * @return Integer[]
     */
    function countPairs($n, $edges, $queries) {
        
    }
}","function countPairs(n: number, edges: number[][], queries: number[]): number[] {

};","(define/contract (count-pairs n edges queries)
  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?))

  )","-spec count_pairs(N :: integer(), Edges :: [[integer()]], Queries :: [integer()]) -> [integer()].
count_pairs(N, Edges, Queries) ->
  .","defmodule Solution do
  @spec count_pairs(n :: integer, edges :: [[integer]], queries :: [integer]) :: [integer]
  def count_pairs(n, edges, queries) do

  end
end","class Solution {
  List<int> countPairs(int n, List<List<int>> edges, List<int> queries) {

  }
}",,,,count-pairs-of-nodes
298,1787,Make the XOR of All Segments Equal to Zero,"You are given an array `nums`​​​ and an integer `k`​​​​​. The XOR of a segment `[left, right]` where `left <= right` is the `XOR` of all the elements with indices between `left` and `right`, inclusive: `nums[left] XOR nums[left+1] XOR ... XOR nums[right]`.
Return the minimum number of elements to change in the array such that the `XOR` of all segments of size `k`​​​​​​ is equal to zero.",0,Hard,,36.6,2.3,https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero,34,2.1K,5.8K,"Media.net,codeagon",Dynamic Programming,144,6,96,0,,"class Solution {
public:
    int minChanges(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int minChanges(int[] nums, int k) {
        
    }
}","class Solution(object):
    def minChanges(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        ","int minChanges(int* nums, int numsSize, int k){

}","public class Solution {
    public int MinChanges(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var minChanges = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def min_changes(nums, k)
    
end","class Solution {
    func minChanges(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func minChanges(nums []int, k int) int {
    
}","object Solution {
    def minChanges(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun minChanges(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn min_changes(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function minChanges($nums, $k) {
        
    }
}","function minChanges(nums: number[], k: number): number {

};","(define/contract (min-changes nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec min_changes(Nums :: [integer()], K :: integer()) -> integer().
min_changes(Nums, K) ->
  .","defmodule Solution do
  @spec min_changes(nums :: [integer], k :: integer) :: integer
  def min_changes(nums, k) do

  end
end","class Solution {
  int minChanges(List<int> nums, int k) {

  }
}",,,,make-the-xor-of-all-segments-equal-to-zero
299,1793,Maximum Score of a Good Subarray,"You are given an array of integers `nums` (0-indexed) and an integer `k`.
The score of a subarray `(i, j)` is defined as `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)`. A good subarray is a subarray where `i <= k <= j`.
Return the maximum possible score of a good subarray.",0,Hard,,46.2,1.1,https://leetcode.com/problems/maximum-score-of-a-good-subarray,118,5.8K,12.6K,Google,Greedy,231,14,94,1,"[Largest Rectangle in Histogram, /problems/largest-rectangle-in-histogram/, Hard]","class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        
    }
};","class Solution {
    public int maximumScore(int[] nums, int k) {
        
    }
}","class Solution(object):
    def maximumScore(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        ","class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        ","int maximumScore(int* nums, int numsSize, int k){

}","public class Solution {
    public int MaximumScore(int[] nums, int k) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maximumScore = function(nums, k) {
    
};","# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def maximum_score(nums, k)
    
end","class Solution {
    func maximumScore(_ nums: [Int], _ k: Int) -> Int {
        
    }
}","func maximumScore(nums []int, k int) int {
    
}","object Solution {
    def maximumScore(nums: Array[Int], k: Int): Int = {
        
    }
}","class Solution {
    fun maximumScore(nums: IntArray, k: Int): Int {
        
    }
}","impl Solution {
    pub fn maximum_score(nums: Vec<i32>, k: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function maximumScore($nums, $k) {
        
    }
}","function maximumScore(nums: number[], k: number): number {

};","(define/contract (maximum-score nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)

  )","-spec maximum_score(Nums :: [integer()], K :: integer()) -> integer().
maximum_score(Nums, K) ->
  .","defmodule Solution do
  @spec maximum_score(nums :: [integer], k :: integer) :: integer
  def maximum_score(nums, k) do

  end
end","class Solution {
  int maximumScore(List<int> nums, int k) {

  }
}",,,,maximum-score-of-a-good-subarray
300,1799,Maximize Score After N Operations,"You are given `nums`, an array of positive integers of size `2 * n`. You must perform `n` operations on this array.
In the `ith` operation (1-indexed), you will:
Choose two elements, `x` and `y`.
Receive a score of `i * gcd(x, y)`.
Remove `x` and `y` from `nums`.
Return the maximum score you can receive after performing `n` operations.
The function `gcd(x, y)` is the greatest common divisor of `x` and `y`.",0,Hard,,50.4,4.7,https://leetcode.com/problems/maximize-score-after-n-operations,68,4K,7.8K,Amazon,"Dynamic Programming,Backtracking,Recursion",127,7,95,1,,"class Solution {
public:
    int maxScore(vector<int>& nums) {
        
    }
};","class Solution {
    public int maxScore(int[] nums) {
        
    }
}","class Solution(object):
    def maxScore(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxScore(self, nums: List[int]) -> int:
        ","int maxScore(int* nums, int numsSize){

}","public class Solution {
    public int MaxScore(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var maxScore = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def max_score(nums)
    
end","class Solution {
    func maxScore(_ nums: [Int]) -> Int {
        
    }
}","func maxScore(nums []int) int {
    
}","object Solution {
    def maxScore(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxScore(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_score(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxScore($nums) {
        
    }
}","function maxScore(nums: number[]): number {

};","(define/contract (max-score nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec max_score(Nums :: [integer()]) -> integer().
max_score(Nums) ->
  .","defmodule Solution do
  @spec max_score(nums :: [integer]) :: integer
  def max_score(nums) do

  end
end","class Solution {
  int maxScore(List<int> nums) {

  }
}",,,,maximize-score-after-n-operations
301,1803,Count Pairs With XOR in a Range,"Given a (0-indexed) integer array `nums` and two integers `low` and `high`, return the number of nice pairs.
A nice pair is a pair `(i, j)` where `0 <= i < j < nums.length` and `low <= (nums[i] XOR nums[j]) <= high`.",0,Hard,,43.1,0.3,https://leetcode.com/problems/count-pairs-with-xor-in-a-range,37,2.7K,6.2K,Vimeo,Trie,122,8,94,0,,"class Solution {
public:
    int countPairs(vector<int>& nums, int low, int high) {
        
    }
};","class Solution {
    public int countPairs(int[] nums, int low, int high) {
        
    }
}","class Solution(object):
    def countPairs(self, nums, low, high):
        """"""
        :type nums: List[int]
        :type low: int
        :type high: int
        :rtype: int
        """"""
        ","class Solution:
    def countPairs(self, nums: List[int], low: int, high: int) -> int:
        ","

int countPairs(int* nums, int numsSize, int low, int high){

}","public class Solution {
    public int CountPairs(int[] nums, int low, int high) {
        
    }
}","/**
 * @param {number[]} nums
 * @param {number} low
 * @param {number} high
 * @return {number}
 */
var countPairs = function(nums, low, high) {
    
};","# @param {Integer[]} nums
# @param {Integer} low
# @param {Integer} high
# @return {Integer}
def count_pairs(nums, low, high)
    
end","class Solution {
    func countPairs(_ nums: [Int], _ low: Int, _ high: Int) -> Int {
        
    }
}","func countPairs(nums []int, low int, high int) int {
    
}","object Solution {
    def countPairs(nums: Array[Int], low: Int, high: Int): Int = {
        
    }
}","class Solution {
    fun countPairs(nums: IntArray, low: Int, high: Int): Int {
        
    }
}","impl Solution {
    pub fn count_pairs(nums: Vec<i32>, low: i32, high: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $low
     * @param Integer $high
     * @return Integer
     */
    function countPairs($nums, $low, $high) {
        
    }
}","function countPairs(nums: number[], low: number, high: number): number {

};","(define/contract (count-pairs nums low high)
  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)

  )",,,,,,,count-pairs-with-xor-in-a-range
302,1808,Maximize Number of Nice Divisors,"You are given a positive integer `primeFactors`. You are asked to construct a positive integer `n` that satisfies the following conditions:
The number of prime factors of `n` (not necessarily distinct) is at most `primeFactors`.
The number of nice divisors of `n` is maximized. Note that a divisor of `n` is nice if it is divisible by every prime factor of `n`. For example, if `n = 12`, then its prime factors are `[2,2,3]`, then `6` and `12` are nice divisors, while `3` and `4` are not.
Return the number of nice divisors of `n`. Since that number can be too large, return it modulo `109 + 7`.
Note that a prime number is a natural number greater than `1` that is not a product of two smaller natural numbers. The prime factors of a number `n` is a list of prime numbers such that their product equals `n`.",0,Hard,,27.3,0.0,https://leetcode.com/problems/maximize-number-of-nice-divisors,51,3.1K,11.4K,Microsoft,Math,95,103,48,0,"[Integer Break, /problems/integer-break/, Medium]","class Solution {
public:
    int maxNiceDivisors(int primeFactors) {
        
    }
};","class Solution {
    public int maxNiceDivisors(int primeFactors) {
        
    }
}","class Solution(object):
    def maxNiceDivisors(self, primeFactors):
        """"""
        :type primeFactors: int
        :rtype: int
        """"""
        ","class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        ","

int maxNiceDivisors(int primeFactors){

}","public class Solution {
    public int MaxNiceDivisors(int primeFactors) {
        
    }
}","/**
 * @param {number} primeFactors
 * @return {number}
 */
var maxNiceDivisors = function(primeFactors) {
    
};","# @param {Integer} prime_factors
# @return {Integer}
def max_nice_divisors(prime_factors)
    
end","class Solution {
    func maxNiceDivisors(_ primeFactors: Int) -> Int {
        
    }
}","func maxNiceDivisors(primeFactors int) int {
    
}","object Solution {
    def maxNiceDivisors(primeFactors: Int): Int = {
        
    }
}","class Solution {
    fun maxNiceDivisors(primeFactors: Int): Int {
        
    }
}","impl Solution {
    pub fn max_nice_divisors(prime_factors: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $primeFactors
     * @return Integer
     */
    function maxNiceDivisors($primeFactors) {
        
    }
}","function maxNiceDivisors(primeFactors: number): number {

};","(define/contract (max-nice-divisors primeFactors)
  (-> exact-integer? exact-integer?)

  )",,,,,,,maximize-number-of-nice-divisors
303,1815,Maximum Number of Groups Getting Fresh Donuts,"There is a donuts shop that bakes donuts in batches of `batchSize`. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. You are given an integer `batchSize` and an integer array `groups`, where `groups[i]` denotes that there is a group of `groups[i]` customers that will visit the shop. Each customer will get exactly one donut.
When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.
You can freely rearrange the ordering of the groups. Return the maximum possible number of happy groups after rearranging the groups.",0,Hard,,35.7,0.0,https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts,27,2.1K,5.4K,Google,Dynamic Programming,94,8,92,1,,"class Solution {
public:
    int maxHappyGroups(int batchSize, vector<int>& groups) {
        
    }
};","class Solution {
    public int maxHappyGroups(int batchSize, int[] groups) {
        
    }
}","class Solution(object):
    def maxHappyGroups(self, batchSize, groups):
        """"""
        :type batchSize: int
        :type groups: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def maxHappyGroups(self, batchSize: int, groups: List[int]) -> int:
        ","int maxHappyGroups(int batchSize, int* groups, int groupsSize){

}","public class Solution {
    public int MaxHappyGroups(int batchSize, int[] groups) {
        
    }
}","/**
 * @param {number} batchSize
 * @param {number[]} groups
 * @return {number}
 */
var maxHappyGroups = function(batchSize, groups) {
    
};","# @param {Integer} batch_size
# @param {Integer[]} groups
# @return {Integer}
def max_happy_groups(batch_size, groups)
    
end","class Solution {
    func maxHappyGroups(_ batchSize: Int, _ groups: [Int]) -> Int {
        
    }
}","func maxHappyGroups(batchSize int, groups []int) int {
    
}","object Solution {
    def maxHappyGroups(batchSize: Int, groups: Array[Int]): Int = {
        
    }
}","class Solution {
    fun maxHappyGroups(batchSize: Int, groups: IntArray): Int {
        
    }
}","impl Solution {
    pub fn max_happy_groups(batch_size: i32, groups: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $batchSize
     * @param Integer[] $groups
     * @return Integer
     */
    function maxHappyGroups($batchSize, $groups) {
        
    }
}","function maxHappyGroups(batchSize: number, groups: number[]): number {

};","(define/contract (max-happy-groups batchSize groups)
  (-> exact-integer? (listof exact-integer?) exact-integer?)

  )","-spec max_happy_groups(BatchSize :: integer(), Groups :: [integer()]) -> integer().
max_happy_groups(BatchSize, Groups) ->
  .","defmodule Solution do
  @spec max_happy_groups(batch_size :: integer, groups :: [integer]) :: integer
  def max_happy_groups(batch_size, groups) do

  end
end","class Solution {
  int maxHappyGroups(int batchSize, List<int> groups) {

  }
}",,,,maximum-number-of-groups-getting-fresh-donuts
304,1819,Number of Different Subsequences GCDs,"You are given an array `nums` that consists of positive integers.
The GCD of a sequence of numbers is defined as the greatest integer that divides all the numbers in the sequence evenly.
For example, the GCD of the sequence `[4,6,16]` is `2`.
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.
For example, `[2,5,10]` is a subsequence of `[1,2,1,2,4,1,5,10]`.
Return the number of different GCDs among all non-empty subsequences of `nums`.",0,Hard,,29.2,0.0,https://leetcode.com/problems/number-of-different-subsequences-gcds,51,2.9K,9.7K,Akuna Capital,Math,131,29,82,0,,"class Solution {
public:
    int countDifferentSubsequenceGCDs(vector<int>& nums) {
        
    }
};","class Solution {
    public int countDifferentSubsequenceGCDs(int[] nums) {
        
    }
}","class Solution(object):
    def countDifferentSubsequenceGCDs(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        ","int countDifferentSubsequenceGCDs(int* nums, int numsSize){

}","public class Solution {
    public int CountDifferentSubsequenceGCDs(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var countDifferentSubsequenceGCDs = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def count_different_subsequence_gc_ds(nums)
    
end","class Solution {
    func countDifferentSubsequenceGCDs(_ nums: [Int]) -> Int {
        
    }
}","func countDifferentSubsequenceGCDs(nums []int) int {
    
}","object Solution {
    def countDifferentSubsequenceGCDs(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun countDifferentSubsequenceGCDs(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn count_different_subsequence_gc_ds(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function countDifferentSubsequenceGCDs($nums) {
        
    }
}","function countDifferentSubsequenceGCDs(nums: number[]): number {

};","(define/contract (count-different-subsequence-gc-ds nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec count_different_subsequence_gc_ds(Nums :: [integer()]) -> integer().
count_different_subsequence_gc_ds(Nums) ->
  .","defmodule Solution do
  @spec count_different_subsequence_gc_ds(nums :: [integer]) :: integer
  def count_different_subsequence_gc_ds(nums) do

  end
end","class Solution {
  int countDifferentSubsequenceGCDs(List<int> nums) {

  }
}",,,,number-of-different-subsequences-gcds
306,446,Arithmetic Slices II - Subsequence,"A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
For example, these are arithmetic sequences:
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic.
1, 1, 2, 5, 7
A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N.
A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2.
The function should return the number of arithmetic subsequence slices in the array A.
The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.",0,Hard,/articles/arithmetic-slices-ii-subsequence,33.6,19.6,https://leetcode.com/problems/arithmetic-slices-ii-subsequence,111,24.9K,74.2K,Google,Dynamic Programming,686,66,91,1,"[Arithmetic Slices, /problems/arithmetic-slices/, Medium]","class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        
    }
};","class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        
    }
}","class Solution(object):
    def numberOfArithmeticSlices(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ","class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        ","int numberOfArithmeticSlices(int* nums, int numsSize){

}","public class Solution {
    public int NumberOfArithmeticSlices(int[] nums) {
        
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
var numberOfArithmeticSlices = function(nums) {
    
};","# @param {Integer[]} nums
# @return {Integer}
def number_of_arithmetic_slices(nums)
    
end","class Solution {
    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {
        
    }
}","func numberOfArithmeticSlices(nums []int) int {
    
}","object Solution {
    def numberOfArithmeticSlices(nums: Array[Int]): Int = {
        
    }
}","class Solution {
    fun numberOfArithmeticSlices(nums: IntArray): Int {
        
    }
}","impl Solution {
    pub fn number_of_arithmetic_slices(nums: Vec<i32>) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function numberOfArithmeticSlices($nums) {
        
    }
}","function numberOfArithmeticSlices(nums: number[]): number {

};","(define/contract (number-of-arithmetic-slices nums)
  (-> (listof exact-integer?) exact-integer?)

  )","-spec number_of_arithmetic_slices(Nums :: [integer()]) -> integer().
number_of_arithmetic_slices(Nums) ->
  .","defmodule Solution do
  @spec number_of_arithmetic_slices(nums :: [integer]) :: integer
  def number_of_arithmetic_slices(nums) do

  end
end","class Solution {
  int numberOfArithmeticSlices(List<int> nums) {

  }
}",,,,arithmetic-slices-ii-subsequence
307,1411,Number of Ways to Paint N × 3 Grid,"You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).
Given `n` the number of rows of the grid, return the number of ways you can paint this `grid`. As the answer may grow large, the answer must be computed modulo `109 + 7`.",0,Hard,,60.5,19.5,https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid,194,15.6K,25.8K,"Akuna Capital,Facebook,Paypal",Dynamic Programming,438,24,95,1,,"class Solution {
public:
    int numOfWays(int n) {
        
    }
};","class Solution {
    public int numOfWays(int n) {
        
    }
}","class Solution(object):
    def numOfWays(self, n):
        """"""
        :type n: int
        :rtype: int
        """"""
        ","class Solution:
    def numOfWays(self, n: int) -> int:
        ","int numOfWays(int n){

}","public class Solution {
    public int NumOfWays(int n) {
        
    }
}","/**
 * @param {number} n
 * @return {number}
 */
var numOfWays = function(n) {
    
};","# @param {Integer} n
# @return {Integer}
def num_of_ways(n)
    
end","class Solution {
    func numOfWays(_ n: Int) -> Int {
        
    }
}","func numOfWays(n int) int {
    
}","object Solution {
    def numOfWays(n: Int): Int = {
        
    }
}","class Solution {
    fun numOfWays(n: Int): Int {
        
    }
}","impl Solution {
    pub fn num_of_ways(n: i32) -> i32 {
        
    }
}","class Solution {

    /**
     * @param Integer $n
     * @return Integer
     */
    function numOfWays($n) {
        
    }
}","function numOfWays(n: number): number {

};","(define/contract (num-of-ways n)
  (-> exact-integer? exact-integer?)

  )","-spec num_of_ways(N :: integer()) -> integer().
num_of_ways(N) ->
  .","defmodule Solution do
  @spec num_of_ways(n :: integer) :: integer
  def num_of_ways(n) do

  end
end","class Solution {
  int numOfWays(int n) {

  }
}",,,,number-of-ways-to-paint-n-3-grid
